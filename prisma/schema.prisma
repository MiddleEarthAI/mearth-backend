// This is your Prisma schema file
generator client {
  provider = "prisma-client-js"
}

// Add seed configuration
generator seed {
  provider = "prisma-client-js"
  output   = "./seed-data"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Game {
  id                String   @id @default(uuid())
  onchainId         BigInt   @unique
  authority         String
  tokenMint         String
  rewardsVault      String
  mapDiameter       Int      @db.Integer
  isActive          Boolean  @default(true)
  lastUpdate        DateTime @default(now())
  bump              Int      @db.Integer
  dailyRewardTokens Float    @db.DoublePrecision
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  agents    Agent[]
  alliances Alliance[]
  battles   Battle[]
  coolDown  CoolDown[]
}

model AgentProfile {
  id              String   @id @default(uuid())
  onchainId       Int      @unique
  name            String
  xHandle         String   @unique
  followers       Int      @default(100)
  bio             String[]
  lore            String[]
  characteristics String[]
  knowledge       String[]
  traits          Json
  // Relations - one profile can have many agents
  agents          Agent[]
}

model Agent {
  id                    String     @id @default(cuid())
  onchainId             Int
  authority             String
  health                Int        @default(100)
  tweets                Tweet[]
  game                  Game       @relation(fields: [gameId], references: [id])
  gameId                String
  // An agent can be involved in many battles, either as attacker or defender
  battlesAsAttacker     Battle[]   @relation("attacker")
  battlesAsDefender     Battle[]   @relation("defender")
  battlesAsAttackerAlly Battle[]   @relation("attackerAlly")
  battlesAsDefenderAlly Battle[]   @relation("defenderAlly")
  coolDown              CoolDown[]

  // Alliance relationships
  initiatedAlliances Alliance[] @relation("AllianceInitiator") // Alliances initiated by this agent
  joinedAlliances    Alliance[] @relation("AllianceJoiner") // Alliances this agent joined
  mapTiles           MapTile[] // Map tiles occupied by this agent

  // Each agent belongs to exactly one profile
  profile   AgentProfile @relation(fields: [profileId], references: [id])
  profileId String
}

model Tweet {
  id             String        @id @default(cuid())
  agentId        String
  agent          Agent         @relation(fields: [agentId], references: [id])
  content        String
  type           String
  timestamp      DateTime
  conversationId String?
  interactions   Interaction[]
}

model Alliance {
  id             String         @id @default(cuid())
  combinedTokens Float?
  status         AllianceStatus @default(Active)
  timestamp      DateTime       @default(now())

  // Game relationship
  game   Game   @relation(fields: [gameId], references: [id])
  gameId String

  // Alliance relationships
  initiator   Agent     @relation("AllianceInitiator", fields: [initiatorId], references: [id])
  initiatorId String
  joiner      Agent     @relation("AllianceJoiner", fields: [joinerId], references: [id])
  joinerId    String
  endedAt     DateTime?

  @@unique([initiatorId, joinerId])
}

enum AllianceStatus {
  Active
  Pending
  Broken
}

model Battle {
  id        String     @id @default(cuid())
  timestamp DateTime   @default(now())
  type      BattleType @default(Simple)

  tokensStaked Float
  tokensLost   Float?

  outcome String? // WIN, LOSS

  // Battle must have both attacker and defender and option ally
  attackerId     String
  attacker       Agent   @relation("attacker", fields: [attackerId], references: [id])
  attackerAllyId String?
  attackerAlly   Agent?  @relation("attackerAlly", fields: [attackerAllyId], references: [id])
  defenderId     String
  defender       Agent   @relation("defender", fields: [defenderId], references: [id])
  defenderAllyId String?
  defenderAlly   Agent?  @relation("defenderAlly", fields: [defenderAllyId], references: [id])

  status BattleStatus @default(Active)

  // Battle belongs to a game
  game   Game   @relation(fields: [gameId], references: [id])
  gameId String

  startTime  DateTime  @default(now())
  resolvedAt DateTime?
}

enum BattleType {
  Simple
  AgentVsAlliance
  AllianceVsAlliance
}

enum BattleStatus {
  Active
  Resolved
  Error
}

model Interaction {
  id          String          @id @default(cuid())
  tweetId     String
  userId      String
  type        InteractionType
  content     String
  timestamp   DateTime
  userMetrics Json
  tweet       Tweet           @relation(fields: [tweetId], references: [id])
}

enum InteractionType {
  Comment
  Quote
  Mention
}

enum TerrainType {
  Plain
  Mountain
  River
}

model MapTile {
  id          String      @id @default(uuid())
  x           Int         @db.Integer
  y           Int         @db.Integer
  terrainType TerrainType
  occupiedBy  String?
  agent       Agent?      @relation(fields: [occupiedBy], references: [id])

  @@unique([x, y])
}

model CoolDown {
  id     String       @id @default(uuid())
  type   CooldownType
  endsAt DateTime

  // Relations
  cooledAgentId String
  cooledAgent   Agent  @relation(fields: [cooledAgentId], references: [id])

  gameId String
  game   Game   @relation(fields: [gameId], references: [id])
}

enum CooldownType {
  Alliance
  Battle
  Ignore
  Tweet
  Move
}

model User {
  id            String   @id
  privyUserId   String   @unique // The ID from Privy
  role          UserRole @default(USER)
  email         String?  @unique
  walletAddress String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

enum UserRole {
  ADMIN
  MANAGER
  USER
}
