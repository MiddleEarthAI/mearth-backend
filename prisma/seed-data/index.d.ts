
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Game
 * 
 */
export type Game = $Result.DefaultSelection<Prisma.$GamePayload>
/**
 * Model GameEvent
 * 
 */
export type GameEvent = $Result.DefaultSelection<Prisma.$GameEventPayload>
/**
 * Model AgentProfile
 * 
 */
export type AgentProfile = $Result.DefaultSelection<Prisma.$AgentProfilePayload>
/**
 * Model Agent
 * 
 */
export type Agent = $Result.DefaultSelection<Prisma.$AgentPayload>
/**
 * Model Ignore
 * 
 */
export type Ignore = $Result.DefaultSelection<Prisma.$IgnorePayload>
/**
 * Model MapTile
 * 
 */
export type MapTile = $Result.DefaultSelection<Prisma.$MapTilePayload>
/**
 * Model Tweet
 * 
 */
export type Tweet = $Result.DefaultSelection<Prisma.$TweetPayload>
/**
 * Model Alliance
 * 
 */
export type Alliance = $Result.DefaultSelection<Prisma.$AlliancePayload>
/**
 * Model Battle
 * 
 */
export type Battle = $Result.DefaultSelection<Prisma.$BattlePayload>
/**
 * Model Interaction
 * 
 */
export type Interaction = $Result.DefaultSelection<Prisma.$InteractionPayload>
/**
 * Model CoolDown
 * 
 */
export type CoolDown = $Result.DefaultSelection<Prisma.$CoolDownPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model GameLog
 * 
 */
export type GameLog = $Result.DefaultSelection<Prisma.$GameLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const EventType: {
  TWEET: 'TWEET',
  MOVE: 'MOVE',
  ALLIANCE_FORM: 'ALLIANCE_FORM',
  ALLIANCE_BREAK: 'ALLIANCE_BREAK',
  IGNORE: 'IGNORE',
  BATTLE: 'BATTLE',
  AGENT_DEATH: 'AGENT_DEATH'
};

export type EventType = (typeof EventType)[keyof typeof EventType]


export const AllianceStatus: {
  Active: 'Active',
  Pending: 'Pending',
  Broken: 'Broken'
};

export type AllianceStatus = (typeof AllianceStatus)[keyof typeof AllianceStatus]


export const BattleStatus: {
  Active: 'Active',
  Resolved: 'Resolved',
  Cancelled: 'Cancelled'
};

export type BattleStatus = (typeof BattleStatus)[keyof typeof BattleStatus]


export const BattleType: {
  Simple: 'Simple',
  AgentVsAlliance: 'AgentVsAlliance',
  AllianceVsAlliance: 'AllianceVsAlliance'
};

export type BattleType = (typeof BattleType)[keyof typeof BattleType]


export const InteractionType: {
  Comment: 'Comment',
  Quote: 'Quote',
  Mention: 'Mention'
};

export type InteractionType = (typeof InteractionType)[keyof typeof InteractionType]


export const TerrainType: {
  plain: 'plain',
  mountain: 'mountain',
  river: 'river'
};

export type TerrainType = (typeof TerrainType)[keyof typeof TerrainType]


export const CooldownType: {
  Alliance: 'Alliance',
  Battle: 'Battle',
  Ignore: 'Ignore',
  Move: 'Move'
};

export type CooldownType = (typeof CooldownType)[keyof typeof CooldownType]


export const UserRole: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  USER: 'USER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]

}

export type EventType = $Enums.EventType

export const EventType: typeof $Enums.EventType

export type AllianceStatus = $Enums.AllianceStatus

export const AllianceStatus: typeof $Enums.AllianceStatus

export type BattleStatus = $Enums.BattleStatus

export const BattleStatus: typeof $Enums.BattleStatus

export type BattleType = $Enums.BattleType

export const BattleType: typeof $Enums.BattleType

export type InteractionType = $Enums.InteractionType

export const InteractionType: typeof $Enums.InteractionType

export type TerrainType = $Enums.TerrainType

export const TerrainType: typeof $Enums.TerrainType

export type CooldownType = $Enums.CooldownType

export const CooldownType: typeof $Enums.CooldownType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Games
 * const games = await prisma.game.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Games
   * const games = await prisma.game.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.game`: Exposes CRUD operations for the **Game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.game.findMany()
    * ```
    */
  get game(): Prisma.GameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameEvent`: Exposes CRUD operations for the **GameEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameEvents
    * const gameEvents = await prisma.gameEvent.findMany()
    * ```
    */
  get gameEvent(): Prisma.GameEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentProfile`: Exposes CRUD operations for the **AgentProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentProfiles
    * const agentProfiles = await prisma.agentProfile.findMany()
    * ```
    */
  get agentProfile(): Prisma.AgentProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agent`: Exposes CRUD operations for the **Agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): Prisma.AgentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ignore`: Exposes CRUD operations for the **Ignore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ignores
    * const ignores = await prisma.ignore.findMany()
    * ```
    */
  get ignore(): Prisma.IgnoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mapTile`: Exposes CRUD operations for the **MapTile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapTiles
    * const mapTiles = await prisma.mapTile.findMany()
    * ```
    */
  get mapTile(): Prisma.MapTileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tweet`: Exposes CRUD operations for the **Tweet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tweets
    * const tweets = await prisma.tweet.findMany()
    * ```
    */
  get tweet(): Prisma.TweetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alliance`: Exposes CRUD operations for the **Alliance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alliances
    * const alliances = await prisma.alliance.findMany()
    * ```
    */
  get alliance(): Prisma.AllianceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.battle`: Exposes CRUD operations for the **Battle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Battles
    * const battles = await prisma.battle.findMany()
    * ```
    */
  get battle(): Prisma.BattleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interaction`: Exposes CRUD operations for the **Interaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interactions
    * const interactions = await prisma.interaction.findMany()
    * ```
    */
  get interaction(): Prisma.InteractionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coolDown`: Exposes CRUD operations for the **CoolDown** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoolDowns
    * const coolDowns = await prisma.coolDown.findMany()
    * ```
    */
  get coolDown(): Prisma.CoolDownDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameLog`: Exposes CRUD operations for the **GameLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameLogs
    * const gameLogs = await prisma.gameLog.findMany()
    * ```
    */
  get gameLog(): Prisma.GameLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.2.1
   * Query Engine version: 4123509d24aa4dede1e864b46351bf2790323b69
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Game: 'Game',
    GameEvent: 'GameEvent',
    AgentProfile: 'AgentProfile',
    Agent: 'Agent',
    Ignore: 'Ignore',
    MapTile: 'MapTile',
    Tweet: 'Tweet',
    Alliance: 'Alliance',
    Battle: 'Battle',
    Interaction: 'Interaction',
    CoolDown: 'CoolDown',
    User: 'User',
    GameLog: 'GameLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "game" | "gameEvent" | "agentProfile" | "agent" | "ignore" | "mapTile" | "tweet" | "alliance" | "battle" | "interaction" | "coolDown" | "user" | "gameLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Game: {
        payload: Prisma.$GamePayload<ExtArgs>
        fields: Prisma.GameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findFirst: {
            args: Prisma.GameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findMany: {
            args: Prisma.GameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          create: {
            args: Prisma.GameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          createMany: {
            args: Prisma.GameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          delete: {
            args: Prisma.GameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          update: {
            args: Prisma.GameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          deleteMany: {
            args: Prisma.GameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          upsert: {
            args: Prisma.GameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          aggregate: {
            args: Prisma.GameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame>
          }
          groupBy: {
            args: Prisma.GameGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameCountArgs<ExtArgs>
            result: $Utils.Optional<GameCountAggregateOutputType> | number
          }
        }
      }
      GameEvent: {
        payload: Prisma.$GameEventPayload<ExtArgs>
        fields: Prisma.GameEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          findFirst: {
            args: Prisma.GameEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          findMany: {
            args: Prisma.GameEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>[]
          }
          create: {
            args: Prisma.GameEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          createMany: {
            args: Prisma.GameEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>[]
          }
          delete: {
            args: Prisma.GameEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          update: {
            args: Prisma.GameEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          deleteMany: {
            args: Prisma.GameEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>[]
          }
          upsert: {
            args: Prisma.GameEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          aggregate: {
            args: Prisma.GameEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameEvent>
          }
          groupBy: {
            args: Prisma.GameEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameEventCountArgs<ExtArgs>
            result: $Utils.Optional<GameEventCountAggregateOutputType> | number
          }
        }
      }
      AgentProfile: {
        payload: Prisma.$AgentProfilePayload<ExtArgs>
        fields: Prisma.AgentProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload>
          }
          findFirst: {
            args: Prisma.AgentProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload>
          }
          findMany: {
            args: Prisma.AgentProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload>[]
          }
          create: {
            args: Prisma.AgentProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload>
          }
          createMany: {
            args: Prisma.AgentProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload>[]
          }
          delete: {
            args: Prisma.AgentProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload>
          }
          update: {
            args: Prisma.AgentProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload>
          }
          deleteMany: {
            args: Prisma.AgentProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload>[]
          }
          upsert: {
            args: Prisma.AgentProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload>
          }
          aggregate: {
            args: Prisma.AgentProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentProfile>
          }
          groupBy: {
            args: Prisma.AgentProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentProfileCountArgs<ExtArgs>
            result: $Utils.Optional<AgentProfileCountAggregateOutputType> | number
          }
        }
      }
      Agent: {
        payload: Prisma.$AgentPayload<ExtArgs>
        fields: Prisma.AgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findFirst: {
            args: Prisma.AgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findMany: {
            args: Prisma.AgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          create: {
            args: Prisma.AgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          createMany: {
            args: Prisma.AgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          delete: {
            args: Prisma.AgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          update: {
            args: Prisma.AgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          deleteMany: {
            args: Prisma.AgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          upsert: {
            args: Prisma.AgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          aggregate: {
            args: Prisma.AgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgent>
          }
          groupBy: {
            args: Prisma.AgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentCountArgs<ExtArgs>
            result: $Utils.Optional<AgentCountAggregateOutputType> | number
          }
        }
      }
      Ignore: {
        payload: Prisma.$IgnorePayload<ExtArgs>
        fields: Prisma.IgnoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IgnoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IgnorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IgnoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IgnorePayload>
          }
          findFirst: {
            args: Prisma.IgnoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IgnorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IgnoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IgnorePayload>
          }
          findMany: {
            args: Prisma.IgnoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IgnorePayload>[]
          }
          create: {
            args: Prisma.IgnoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IgnorePayload>
          }
          createMany: {
            args: Prisma.IgnoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IgnoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IgnorePayload>[]
          }
          delete: {
            args: Prisma.IgnoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IgnorePayload>
          }
          update: {
            args: Prisma.IgnoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IgnorePayload>
          }
          deleteMany: {
            args: Prisma.IgnoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IgnoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IgnoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IgnorePayload>[]
          }
          upsert: {
            args: Prisma.IgnoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IgnorePayload>
          }
          aggregate: {
            args: Prisma.IgnoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIgnore>
          }
          groupBy: {
            args: Prisma.IgnoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<IgnoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.IgnoreCountArgs<ExtArgs>
            result: $Utils.Optional<IgnoreCountAggregateOutputType> | number
          }
        }
      }
      MapTile: {
        payload: Prisma.$MapTilePayload<ExtArgs>
        fields: Prisma.MapTileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MapTileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MapTileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload>
          }
          findFirst: {
            args: Prisma.MapTileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MapTileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload>
          }
          findMany: {
            args: Prisma.MapTileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload>[]
          }
          create: {
            args: Prisma.MapTileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload>
          }
          createMany: {
            args: Prisma.MapTileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MapTileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload>[]
          }
          delete: {
            args: Prisma.MapTileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload>
          }
          update: {
            args: Prisma.MapTileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload>
          }
          deleteMany: {
            args: Prisma.MapTileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MapTileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MapTileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload>[]
          }
          upsert: {
            args: Prisma.MapTileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload>
          }
          aggregate: {
            args: Prisma.MapTileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMapTile>
          }
          groupBy: {
            args: Prisma.MapTileGroupByArgs<ExtArgs>
            result: $Utils.Optional<MapTileGroupByOutputType>[]
          }
          count: {
            args: Prisma.MapTileCountArgs<ExtArgs>
            result: $Utils.Optional<MapTileCountAggregateOutputType> | number
          }
        }
      }
      Tweet: {
        payload: Prisma.$TweetPayload<ExtArgs>
        fields: Prisma.TweetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TweetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TweetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload>
          }
          findFirst: {
            args: Prisma.TweetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TweetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload>
          }
          findMany: {
            args: Prisma.TweetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload>[]
          }
          create: {
            args: Prisma.TweetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload>
          }
          createMany: {
            args: Prisma.TweetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TweetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload>[]
          }
          delete: {
            args: Prisma.TweetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload>
          }
          update: {
            args: Prisma.TweetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload>
          }
          deleteMany: {
            args: Prisma.TweetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TweetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TweetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload>[]
          }
          upsert: {
            args: Prisma.TweetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload>
          }
          aggregate: {
            args: Prisma.TweetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTweet>
          }
          groupBy: {
            args: Prisma.TweetGroupByArgs<ExtArgs>
            result: $Utils.Optional<TweetGroupByOutputType>[]
          }
          count: {
            args: Prisma.TweetCountArgs<ExtArgs>
            result: $Utils.Optional<TweetCountAggregateOutputType> | number
          }
        }
      }
      Alliance: {
        payload: Prisma.$AlliancePayload<ExtArgs>
        fields: Prisma.AllianceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AllianceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlliancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AllianceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlliancePayload>
          }
          findFirst: {
            args: Prisma.AllianceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlliancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AllianceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlliancePayload>
          }
          findMany: {
            args: Prisma.AllianceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlliancePayload>[]
          }
          create: {
            args: Prisma.AllianceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlliancePayload>
          }
          createMany: {
            args: Prisma.AllianceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AllianceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlliancePayload>[]
          }
          delete: {
            args: Prisma.AllianceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlliancePayload>
          }
          update: {
            args: Prisma.AllianceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlliancePayload>
          }
          deleteMany: {
            args: Prisma.AllianceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AllianceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AllianceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlliancePayload>[]
          }
          upsert: {
            args: Prisma.AllianceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlliancePayload>
          }
          aggregate: {
            args: Prisma.AllianceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlliance>
          }
          groupBy: {
            args: Prisma.AllianceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AllianceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AllianceCountArgs<ExtArgs>
            result: $Utils.Optional<AllianceCountAggregateOutputType> | number
          }
        }
      }
      Battle: {
        payload: Prisma.$BattlePayload<ExtArgs>
        fields: Prisma.BattleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BattleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BattleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload>
          }
          findFirst: {
            args: Prisma.BattleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BattleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload>
          }
          findMany: {
            args: Prisma.BattleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload>[]
          }
          create: {
            args: Prisma.BattleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload>
          }
          createMany: {
            args: Prisma.BattleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BattleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload>[]
          }
          delete: {
            args: Prisma.BattleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload>
          }
          update: {
            args: Prisma.BattleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload>
          }
          deleteMany: {
            args: Prisma.BattleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BattleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BattleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload>[]
          }
          upsert: {
            args: Prisma.BattleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload>
          }
          aggregate: {
            args: Prisma.BattleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBattle>
          }
          groupBy: {
            args: Prisma.BattleGroupByArgs<ExtArgs>
            result: $Utils.Optional<BattleGroupByOutputType>[]
          }
          count: {
            args: Prisma.BattleCountArgs<ExtArgs>
            result: $Utils.Optional<BattleCountAggregateOutputType> | number
          }
        }
      }
      Interaction: {
        payload: Prisma.$InteractionPayload<ExtArgs>
        fields: Prisma.InteractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InteractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InteractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          findFirst: {
            args: Prisma.InteractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InteractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          findMany: {
            args: Prisma.InteractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>[]
          }
          create: {
            args: Prisma.InteractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          createMany: {
            args: Prisma.InteractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InteractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>[]
          }
          delete: {
            args: Prisma.InteractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          update: {
            args: Prisma.InteractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          deleteMany: {
            args: Prisma.InteractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InteractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InteractionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>[]
          }
          upsert: {
            args: Prisma.InteractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          aggregate: {
            args: Prisma.InteractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInteraction>
          }
          groupBy: {
            args: Prisma.InteractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InteractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InteractionCountArgs<ExtArgs>
            result: $Utils.Optional<InteractionCountAggregateOutputType> | number
          }
        }
      }
      CoolDown: {
        payload: Prisma.$CoolDownPayload<ExtArgs>
        fields: Prisma.CoolDownFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoolDownFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoolDownPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoolDownFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoolDownPayload>
          }
          findFirst: {
            args: Prisma.CoolDownFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoolDownPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoolDownFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoolDownPayload>
          }
          findMany: {
            args: Prisma.CoolDownFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoolDownPayload>[]
          }
          create: {
            args: Prisma.CoolDownCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoolDownPayload>
          }
          createMany: {
            args: Prisma.CoolDownCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoolDownCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoolDownPayload>[]
          }
          delete: {
            args: Prisma.CoolDownDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoolDownPayload>
          }
          update: {
            args: Prisma.CoolDownUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoolDownPayload>
          }
          deleteMany: {
            args: Prisma.CoolDownDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoolDownUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CoolDownUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoolDownPayload>[]
          }
          upsert: {
            args: Prisma.CoolDownUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoolDownPayload>
          }
          aggregate: {
            args: Prisma.CoolDownAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoolDown>
          }
          groupBy: {
            args: Prisma.CoolDownGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoolDownGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoolDownCountArgs<ExtArgs>
            result: $Utils.Optional<CoolDownCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      GameLog: {
        payload: Prisma.$GameLogPayload<ExtArgs>
        fields: Prisma.GameLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLogPayload>
          }
          findFirst: {
            args: Prisma.GameLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLogPayload>
          }
          findMany: {
            args: Prisma.GameLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLogPayload>[]
          }
          create: {
            args: Prisma.GameLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLogPayload>
          }
          createMany: {
            args: Prisma.GameLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLogPayload>[]
          }
          delete: {
            args: Prisma.GameLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLogPayload>
          }
          update: {
            args: Prisma.GameLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLogPayload>
          }
          deleteMany: {
            args: Prisma.GameLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLogPayload>[]
          }
          upsert: {
            args: Prisma.GameLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLogPayload>
          }
          aggregate: {
            args: Prisma.GameLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameLog>
          }
          groupBy: {
            args: Prisma.GameLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameLogCountArgs<ExtArgs>
            result: $Utils.Optional<GameLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    game?: GameOmit
    gameEvent?: GameEventOmit
    agentProfile?: AgentProfileOmit
    agent?: AgentOmit
    ignore?: IgnoreOmit
    mapTile?: MapTileOmit
    tweet?: TweetOmit
    alliance?: AllianceOmit
    battle?: BattleOmit
    interaction?: InteractionOmit
    coolDown?: CoolDownOmit
    user?: UserOmit
    gameLog?: GameLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type GameCountOutputType
   */

  export type GameCountOutputType = {
    agents: number
    alliances: number
    battles: number
    coolDown: number
    Ignore: number
    GameLog: number
    GameEvent: number
  }

  export type GameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agents?: boolean | GameCountOutputTypeCountAgentsArgs
    alliances?: boolean | GameCountOutputTypeCountAlliancesArgs
    battles?: boolean | GameCountOutputTypeCountBattlesArgs
    coolDown?: boolean | GameCountOutputTypeCountCoolDownArgs
    Ignore?: boolean | GameCountOutputTypeCountIgnoreArgs
    GameLog?: boolean | GameCountOutputTypeCountGameLogArgs
    GameEvent?: boolean | GameCountOutputTypeCountGameEventArgs
  }

  // Custom InputTypes
  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCountOutputType
     */
    select?: GameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountAlliancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllianceWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountBattlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountCoolDownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoolDownWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountIgnoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IgnoreWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountGameLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameLogWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountGameEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameEventWhereInput
  }


  /**
   * Count Type AgentProfileCountOutputType
   */

  export type AgentProfileCountOutputType = {
    agents: number
  }

  export type AgentProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agents?: boolean | AgentProfileCountOutputTypeCountAgentsArgs
  }

  // Custom InputTypes
  /**
   * AgentProfileCountOutputType without action
   */
  export type AgentProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfileCountOutputType
     */
    select?: AgentProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentProfileCountOutputType without action
   */
  export type AgentProfileCountOutputTypeCountAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
  }


  /**
   * Count Type AgentCountOutputType
   */

  export type AgentCountOutputType = {
    tweets: number
    battlesAsAttacker: number
    battlesAsDefender: number
    battlesAsAttackerAlly: number
    battlesAsDefenderAlly: number
    wonBattles: number
    coolDown: number
    initiatedAlliances: number
    joinedAlliances: number
    ignoredBy: number
    ignoring: number
    GameLog: number
    initiatedEvents: number
    targetedEvents: number
  }

  export type AgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | AgentCountOutputTypeCountTweetsArgs
    battlesAsAttacker?: boolean | AgentCountOutputTypeCountBattlesAsAttackerArgs
    battlesAsDefender?: boolean | AgentCountOutputTypeCountBattlesAsDefenderArgs
    battlesAsAttackerAlly?: boolean | AgentCountOutputTypeCountBattlesAsAttackerAllyArgs
    battlesAsDefenderAlly?: boolean | AgentCountOutputTypeCountBattlesAsDefenderAllyArgs
    wonBattles?: boolean | AgentCountOutputTypeCountWonBattlesArgs
    coolDown?: boolean | AgentCountOutputTypeCountCoolDownArgs
    initiatedAlliances?: boolean | AgentCountOutputTypeCountInitiatedAlliancesArgs
    joinedAlliances?: boolean | AgentCountOutputTypeCountJoinedAlliancesArgs
    ignoredBy?: boolean | AgentCountOutputTypeCountIgnoredByArgs
    ignoring?: boolean | AgentCountOutputTypeCountIgnoringArgs
    GameLog?: boolean | AgentCountOutputTypeCountGameLogArgs
    initiatedEvents?: boolean | AgentCountOutputTypeCountInitiatedEventsArgs
    targetedEvents?: boolean | AgentCountOutputTypeCountTargetedEventsArgs
  }

  // Custom InputTypes
  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentCountOutputType
     */
    select?: AgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountTweetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TweetWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountBattlesAsAttackerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountBattlesAsDefenderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountBattlesAsAttackerAllyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountBattlesAsDefenderAllyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountWonBattlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountCoolDownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoolDownWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountInitiatedAlliancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllianceWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountJoinedAlliancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllianceWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountIgnoredByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IgnoreWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountIgnoringArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IgnoreWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountGameLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameLogWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountInitiatedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameEventWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountTargetedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameEventWhereInput
  }


  /**
   * Count Type TweetCountOutputType
   */

  export type TweetCountOutputType = {
    interactions: number
  }

  export type TweetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interactions?: boolean | TweetCountOutputTypeCountInteractionsArgs
  }

  // Custom InputTypes
  /**
   * TweetCountOutputType without action
   */
  export type TweetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetCountOutputType
     */
    select?: TweetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TweetCountOutputType without action
   */
  export type TweetCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Game
   */

  export type AggregateGame = {
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  export type GameAvgAggregateOutputType = {
    onchainId: number | null
    mapDiameter: number | null
    bump: number | null
    dailyRewardTokens: number | null
  }

  export type GameSumAggregateOutputType = {
    onchainId: number | null
    mapDiameter: number | null
    bump: number | null
    dailyRewardTokens: number | null
  }

  export type GameMinAggregateOutputType = {
    id: string | null
    onchainId: number | null
    authority: string | null
    pda: string | null
    tokenMint: string | null
    rewardsVault: string | null
    mapDiameter: number | null
    isActive: boolean | null
    lastUpdate: Date | null
    bump: number | null
    dailyRewardTokens: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameMaxAggregateOutputType = {
    id: string | null
    onchainId: number | null
    authority: string | null
    pda: string | null
    tokenMint: string | null
    rewardsVault: string | null
    mapDiameter: number | null
    isActive: boolean | null
    lastUpdate: Date | null
    bump: number | null
    dailyRewardTokens: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameCountAggregateOutputType = {
    id: number
    onchainId: number
    authority: number
    pda: number
    tokenMint: number
    rewardsVault: number
    mapDiameter: number
    isActive: number
    lastUpdate: number
    bump: number
    dailyRewardTokens: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameAvgAggregateInputType = {
    onchainId?: true
    mapDiameter?: true
    bump?: true
    dailyRewardTokens?: true
  }

  export type GameSumAggregateInputType = {
    onchainId?: true
    mapDiameter?: true
    bump?: true
    dailyRewardTokens?: true
  }

  export type GameMinAggregateInputType = {
    id?: true
    onchainId?: true
    authority?: true
    pda?: true
    tokenMint?: true
    rewardsVault?: true
    mapDiameter?: true
    isActive?: true
    lastUpdate?: true
    bump?: true
    dailyRewardTokens?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameMaxAggregateInputType = {
    id?: true
    onchainId?: true
    authority?: true
    pda?: true
    tokenMint?: true
    rewardsVault?: true
    mapDiameter?: true
    isActive?: true
    lastUpdate?: true
    bump?: true
    dailyRewardTokens?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameCountAggregateInputType = {
    id?: true
    onchainId?: true
    authority?: true
    pda?: true
    tokenMint?: true
    rewardsVault?: true
    mapDiameter?: true
    isActive?: true
    lastUpdate?: true
    bump?: true
    dailyRewardTokens?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Game to aggregate.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Games
    **/
    _count?: true | GameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameMaxAggregateInputType
  }

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
        [P in keyof T & keyof AggregateGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>
  }




  export type GameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
    orderBy?: GameOrderByWithAggregationInput | GameOrderByWithAggregationInput[]
    by: GameScalarFieldEnum[] | GameScalarFieldEnum
    having?: GameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCountAggregateInputType | true
    _avg?: GameAvgAggregateInputType
    _sum?: GameSumAggregateInputType
    _min?: GameMinAggregateInputType
    _max?: GameMaxAggregateInputType
  }

  export type GameGroupByOutputType = {
    id: string
    onchainId: number
    authority: string
    pda: string
    tokenMint: string
    rewardsVault: string
    mapDiameter: number
    isActive: boolean
    lastUpdate: Date
    bump: number
    dailyRewardTokens: number
    createdAt: Date
    updatedAt: Date
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  type GetGameGroupByPayload<T extends GameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGroupByOutputType[P]>
            : GetScalarType<T[P], GameGroupByOutputType[P]>
        }
      >
    >


  export type GameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    onchainId?: boolean
    authority?: boolean
    pda?: boolean
    tokenMint?: boolean
    rewardsVault?: boolean
    mapDiameter?: boolean
    isActive?: boolean
    lastUpdate?: boolean
    bump?: boolean
    dailyRewardTokens?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agents?: boolean | Game$agentsArgs<ExtArgs>
    alliances?: boolean | Game$alliancesArgs<ExtArgs>
    battles?: boolean | Game$battlesArgs<ExtArgs>
    coolDown?: boolean | Game$coolDownArgs<ExtArgs>
    Ignore?: boolean | Game$IgnoreArgs<ExtArgs>
    GameLog?: boolean | Game$GameLogArgs<ExtArgs>
    GameEvent?: boolean | Game$GameEventArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    onchainId?: boolean
    authority?: boolean
    pda?: boolean
    tokenMint?: boolean
    rewardsVault?: boolean
    mapDiameter?: boolean
    isActive?: boolean
    lastUpdate?: boolean
    bump?: boolean
    dailyRewardTokens?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["game"]>

  export type GameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    onchainId?: boolean
    authority?: boolean
    pda?: boolean
    tokenMint?: boolean
    rewardsVault?: boolean
    mapDiameter?: boolean
    isActive?: boolean
    lastUpdate?: boolean
    bump?: boolean
    dailyRewardTokens?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["game"]>

  export type GameSelectScalar = {
    id?: boolean
    onchainId?: boolean
    authority?: boolean
    pda?: boolean
    tokenMint?: boolean
    rewardsVault?: boolean
    mapDiameter?: boolean
    isActive?: boolean
    lastUpdate?: boolean
    bump?: boolean
    dailyRewardTokens?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "onchainId" | "authority" | "pda" | "tokenMint" | "rewardsVault" | "mapDiameter" | "isActive" | "lastUpdate" | "bump" | "dailyRewardTokens" | "createdAt" | "updatedAt", ExtArgs["result"]["game"]>
  export type GameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agents?: boolean | Game$agentsArgs<ExtArgs>
    alliances?: boolean | Game$alliancesArgs<ExtArgs>
    battles?: boolean | Game$battlesArgs<ExtArgs>
    coolDown?: boolean | Game$coolDownArgs<ExtArgs>
    Ignore?: boolean | Game$IgnoreArgs<ExtArgs>
    GameLog?: boolean | Game$GameLogArgs<ExtArgs>
    GameEvent?: boolean | Game$GameEventArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Game"
    objects: {
      agents: Prisma.$AgentPayload<ExtArgs>[]
      alliances: Prisma.$AlliancePayload<ExtArgs>[]
      battles: Prisma.$BattlePayload<ExtArgs>[]
      coolDown: Prisma.$CoolDownPayload<ExtArgs>[]
      Ignore: Prisma.$IgnorePayload<ExtArgs>[]
      GameLog: Prisma.$GameLogPayload<ExtArgs>[]
      GameEvent: Prisma.$GameEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      onchainId: number
      authority: string
      pda: string
      tokenMint: string
      rewardsVault: string
      mapDiameter: number
      isActive: boolean
      lastUpdate: Date
      bump: number
      dailyRewardTokens: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["game"]>
    composites: {}
  }

  type GameGetPayload<S extends boolean | null | undefined | GameDefaultArgs> = $Result.GetResult<Prisma.$GamePayload, S>

  type GameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameCountAggregateInputType | true
    }

  export interface GameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Game'], meta: { name: 'Game' } }
    /**
     * Find zero or one Game that matches the filter.
     * @param {GameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameFindUniqueArgs>(args: SelectSubset<T, GameFindUniqueArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameFindUniqueOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameFindUniqueOrThrowArgs>(args: SelectSubset<T, GameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameFindFirstArgs>(args?: SelectSubset<T, GameFindFirstArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameFindFirstOrThrowArgs>(args?: SelectSubset<T, GameFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameFindManyArgs>(args?: SelectSubset<T, GameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Game.
     * @param {GameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     * 
     */
    create<T extends GameCreateArgs>(args: SelectSubset<T, GameCreateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Games.
     * @param {GameCreateManyArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameCreateManyArgs>(args?: SelectSubset<T, GameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Games and returns the data saved in the database.
     * @param {GameCreateManyAndReturnArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameCreateManyAndReturnArgs>(args?: SelectSubset<T, GameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Game.
     * @param {GameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     * 
     */
    delete<T extends GameDeleteArgs>(args: SelectSubset<T, GameDeleteArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Game.
     * @param {GameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameUpdateArgs>(args: SelectSubset<T, GameUpdateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Games.
     * @param {GameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameDeleteManyArgs>(args?: SelectSubset<T, GameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameUpdateManyArgs>(args: SelectSubset<T, GameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games and returns the data updated in the database.
     * @param {GameUpdateManyAndReturnArgs} args - Arguments to update many Games.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameUpdateManyAndReturnArgs>(args: SelectSubset<T, GameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Game.
     * @param {GameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
     */
    upsert<T extends GameUpsertArgs>(args: SelectSubset<T, GameUpsertArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends GameCountArgs>(
      args?: Subset<T, GameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAggregateArgs>(args: Subset<T, GameAggregateArgs>): Prisma.PrismaPromise<GetGameAggregateType<T>>

    /**
     * Group by Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameGroupByArgs['orderBy'] }
        : { orderBy?: GameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Game model
   */
  readonly fields: GameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agents<T extends Game$agentsArgs<ExtArgs> = {}>(args?: Subset<T, Game$agentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    alliances<T extends Game$alliancesArgs<ExtArgs> = {}>(args?: Subset<T, Game$alliancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlliancePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    battles<T extends Game$battlesArgs<ExtArgs> = {}>(args?: Subset<T, Game$battlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    coolDown<T extends Game$coolDownArgs<ExtArgs> = {}>(args?: Subset<T, Game$coolDownArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoolDownPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Ignore<T extends Game$IgnoreArgs<ExtArgs> = {}>(args?: Subset<T, Game$IgnoreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IgnorePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    GameLog<T extends Game$GameLogArgs<ExtArgs> = {}>(args?: Subset<T, Game$GameLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameLogPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    GameEvent<T extends Game$GameEventArgs<ExtArgs> = {}>(args?: Subset<T, Game$GameEventArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Game model
   */ 
  interface GameFieldRefs {
    readonly id: FieldRef<"Game", 'String'>
    readonly onchainId: FieldRef<"Game", 'Int'>
    readonly authority: FieldRef<"Game", 'String'>
    readonly pda: FieldRef<"Game", 'String'>
    readonly tokenMint: FieldRef<"Game", 'String'>
    readonly rewardsVault: FieldRef<"Game", 'String'>
    readonly mapDiameter: FieldRef<"Game", 'Int'>
    readonly isActive: FieldRef<"Game", 'Boolean'>
    readonly lastUpdate: FieldRef<"Game", 'DateTime'>
    readonly bump: FieldRef<"Game", 'Int'>
    readonly dailyRewardTokens: FieldRef<"Game", 'Float'>
    readonly createdAt: FieldRef<"Game", 'DateTime'>
    readonly updatedAt: FieldRef<"Game", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Game findUnique
   */
  export type GameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findUniqueOrThrow
   */
  export type GameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findFirst
   */
  export type GameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findFirstOrThrow
   */
  export type GameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findMany
   */
  export type GameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Games to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game create
   */
  export type GameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to create a Game.
     */
    data: XOR<GameCreateInput, GameUncheckedCreateInput>
  }

  /**
   * Game createMany
   */
  export type GameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Game createManyAndReturn
   */
  export type GameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Game update
   */
  export type GameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to update a Game.
     */
    data: XOR<GameUpdateInput, GameUncheckedUpdateInput>
    /**
     * Choose, which Game to update.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game updateMany
   */
  export type GameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
  }

  /**
   * Game updateManyAndReturn
   */
  export type GameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
  }

  /**
   * Game upsert
   */
  export type GameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The filter to search for the Game to update in case it exists.
     */
    where: GameWhereUniqueInput
    /**
     * In case the Game found by the `where` argument doesn't exist, create a new Game with this data.
     */
    create: XOR<GameCreateInput, GameUncheckedCreateInput>
    /**
     * In case the Game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameUpdateInput, GameUncheckedUpdateInput>
  }

  /**
   * Game delete
   */
  export type GameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter which Game to delete.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game deleteMany
   */
  export type GameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Games to delete
     */
    where?: GameWhereInput
  }

  /**
   * Game.agents
   */
  export type Game$agentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    cursor?: AgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Game.alliances
   */
  export type Game$alliancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alliance
     */
    select?: AllianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alliance
     */
    omit?: AllianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllianceInclude<ExtArgs> | null
    where?: AllianceWhereInput
    orderBy?: AllianceOrderByWithRelationInput | AllianceOrderByWithRelationInput[]
    cursor?: AllianceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AllianceScalarFieldEnum | AllianceScalarFieldEnum[]
  }

  /**
   * Game.battles
   */
  export type Game$battlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    where?: BattleWhereInput
    orderBy?: BattleOrderByWithRelationInput | BattleOrderByWithRelationInput[]
    cursor?: BattleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BattleScalarFieldEnum | BattleScalarFieldEnum[]
  }

  /**
   * Game.coolDown
   */
  export type Game$coolDownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoolDown
     */
    select?: CoolDownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoolDown
     */
    omit?: CoolDownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoolDownInclude<ExtArgs> | null
    where?: CoolDownWhereInput
    orderBy?: CoolDownOrderByWithRelationInput | CoolDownOrderByWithRelationInput[]
    cursor?: CoolDownWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoolDownScalarFieldEnum | CoolDownScalarFieldEnum[]
  }

  /**
   * Game.Ignore
   */
  export type Game$IgnoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ignore
     */
    select?: IgnoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ignore
     */
    omit?: IgnoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IgnoreInclude<ExtArgs> | null
    where?: IgnoreWhereInput
    orderBy?: IgnoreOrderByWithRelationInput | IgnoreOrderByWithRelationInput[]
    cursor?: IgnoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IgnoreScalarFieldEnum | IgnoreScalarFieldEnum[]
  }

  /**
   * Game.GameLog
   */
  export type Game$GameLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLog
     */
    select?: GameLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLog
     */
    omit?: GameLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLogInclude<ExtArgs> | null
    where?: GameLogWhereInput
    orderBy?: GameLogOrderByWithRelationInput | GameLogOrderByWithRelationInput[]
    cursor?: GameLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameLogScalarFieldEnum | GameLogScalarFieldEnum[]
  }

  /**
   * Game.GameEvent
   */
  export type Game$GameEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    where?: GameEventWhereInput
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    cursor?: GameEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameEventScalarFieldEnum | GameEventScalarFieldEnum[]
  }

  /**
   * Game without action
   */
  export type GameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
  }


  /**
   * Model GameEvent
   */

  export type AggregateGameEvent = {
    _count: GameEventCountAggregateOutputType | null
    _min: GameEventMinAggregateOutputType | null
    _max: GameEventMaxAggregateOutputType | null
  }

  export type GameEventMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    eventType: $Enums.EventType | null
    initiatorId: string | null
    targetId: string | null
    message: string | null
    gameId: string | null
  }

  export type GameEventMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    eventType: $Enums.EventType | null
    initiatorId: string | null
    targetId: string | null
    message: string | null
    gameId: string | null
  }

  export type GameEventCountAggregateOutputType = {
    id: number
    createdAt: number
    eventType: number
    initiatorId: number
    targetId: number
    message: number
    metadata: number
    gameId: number
    _all: number
  }


  export type GameEventMinAggregateInputType = {
    id?: true
    createdAt?: true
    eventType?: true
    initiatorId?: true
    targetId?: true
    message?: true
    gameId?: true
  }

  export type GameEventMaxAggregateInputType = {
    id?: true
    createdAt?: true
    eventType?: true
    initiatorId?: true
    targetId?: true
    message?: true
    gameId?: true
  }

  export type GameEventCountAggregateInputType = {
    id?: true
    createdAt?: true
    eventType?: true
    initiatorId?: true
    targetId?: true
    message?: true
    metadata?: true
    gameId?: true
    _all?: true
  }

  export type GameEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameEvent to aggregate.
     */
    where?: GameEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameEvents to fetch.
     */
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameEvents
    **/
    _count?: true | GameEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameEventMaxAggregateInputType
  }

  export type GetGameEventAggregateType<T extends GameEventAggregateArgs> = {
        [P in keyof T & keyof AggregateGameEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameEvent[P]>
      : GetScalarType<T[P], AggregateGameEvent[P]>
  }




  export type GameEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameEventWhereInput
    orderBy?: GameEventOrderByWithAggregationInput | GameEventOrderByWithAggregationInput[]
    by: GameEventScalarFieldEnum[] | GameEventScalarFieldEnum
    having?: GameEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameEventCountAggregateInputType | true
    _min?: GameEventMinAggregateInputType
    _max?: GameEventMaxAggregateInputType
  }

  export type GameEventGroupByOutputType = {
    id: string
    createdAt: Date
    eventType: $Enums.EventType
    initiatorId: string
    targetId: string | null
    message: string
    metadata: JsonValue | null
    gameId: string
    _count: GameEventCountAggregateOutputType | null
    _min: GameEventMinAggregateOutputType | null
    _max: GameEventMaxAggregateOutputType | null
  }

  type GetGameEventGroupByPayload<T extends GameEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameEventGroupByOutputType[P]>
            : GetScalarType<T[P], GameEventGroupByOutputType[P]>
        }
      >
    >


  export type GameEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    eventType?: boolean
    initiatorId?: boolean
    targetId?: boolean
    message?: boolean
    metadata?: boolean
    gameId?: boolean
    initiator?: boolean | AgentDefaultArgs<ExtArgs>
    target?: boolean | GameEvent$targetArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameEvent"]>

  export type GameEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    eventType?: boolean
    initiatorId?: boolean
    targetId?: boolean
    message?: boolean
    metadata?: boolean
    gameId?: boolean
    initiator?: boolean | AgentDefaultArgs<ExtArgs>
    target?: boolean | GameEvent$targetArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameEvent"]>

  export type GameEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    eventType?: boolean
    initiatorId?: boolean
    targetId?: boolean
    message?: boolean
    metadata?: boolean
    gameId?: boolean
    initiator?: boolean | AgentDefaultArgs<ExtArgs>
    target?: boolean | GameEvent$targetArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameEvent"]>

  export type GameEventSelectScalar = {
    id?: boolean
    createdAt?: boolean
    eventType?: boolean
    initiatorId?: boolean
    targetId?: boolean
    message?: boolean
    metadata?: boolean
    gameId?: boolean
  }

  export type GameEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "eventType" | "initiatorId" | "targetId" | "message" | "metadata" | "gameId", ExtArgs["result"]["gameEvent"]>
  export type GameEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    initiator?: boolean | AgentDefaultArgs<ExtArgs>
    target?: boolean | GameEvent$targetArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type GameEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    initiator?: boolean | AgentDefaultArgs<ExtArgs>
    target?: boolean | GameEvent$targetArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type GameEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    initiator?: boolean | AgentDefaultArgs<ExtArgs>
    target?: boolean | GameEvent$targetArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }

  export type $GameEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameEvent"
    objects: {
      initiator: Prisma.$AgentPayload<ExtArgs>
      target: Prisma.$AgentPayload<ExtArgs> | null
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      eventType: $Enums.EventType
      initiatorId: string
      targetId: string | null
      message: string
      metadata: Prisma.JsonValue | null
      gameId: string
    }, ExtArgs["result"]["gameEvent"]>
    composites: {}
  }

  type GameEventGetPayload<S extends boolean | null | undefined | GameEventDefaultArgs> = $Result.GetResult<Prisma.$GameEventPayload, S>

  type GameEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameEventCountAggregateInputType | true
    }

  export interface GameEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameEvent'], meta: { name: 'GameEvent' } }
    /**
     * Find zero or one GameEvent that matches the filter.
     * @param {GameEventFindUniqueArgs} args - Arguments to find a GameEvent
     * @example
     * // Get one GameEvent
     * const gameEvent = await prisma.gameEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameEventFindUniqueArgs>(args: SelectSubset<T, GameEventFindUniqueArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one GameEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameEventFindUniqueOrThrowArgs} args - Arguments to find a GameEvent
     * @example
     * // Get one GameEvent
     * const gameEvent = await prisma.gameEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameEventFindUniqueOrThrowArgs>(args: SelectSubset<T, GameEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first GameEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventFindFirstArgs} args - Arguments to find a GameEvent
     * @example
     * // Get one GameEvent
     * const gameEvent = await prisma.gameEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameEventFindFirstArgs>(args?: SelectSubset<T, GameEventFindFirstArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first GameEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventFindFirstOrThrowArgs} args - Arguments to find a GameEvent
     * @example
     * // Get one GameEvent
     * const gameEvent = await prisma.gameEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameEventFindFirstOrThrowArgs>(args?: SelectSubset<T, GameEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more GameEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameEvents
     * const gameEvents = await prisma.gameEvent.findMany()
     * 
     * // Get first 10 GameEvents
     * const gameEvents = await prisma.gameEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameEventWithIdOnly = await prisma.gameEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameEventFindManyArgs>(args?: SelectSubset<T, GameEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a GameEvent.
     * @param {GameEventCreateArgs} args - Arguments to create a GameEvent.
     * @example
     * // Create one GameEvent
     * const GameEvent = await prisma.gameEvent.create({
     *   data: {
     *     // ... data to create a GameEvent
     *   }
     * })
     * 
     */
    create<T extends GameEventCreateArgs>(args: SelectSubset<T, GameEventCreateArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many GameEvents.
     * @param {GameEventCreateManyArgs} args - Arguments to create many GameEvents.
     * @example
     * // Create many GameEvents
     * const gameEvent = await prisma.gameEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameEventCreateManyArgs>(args?: SelectSubset<T, GameEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameEvents and returns the data saved in the database.
     * @param {GameEventCreateManyAndReturnArgs} args - Arguments to create many GameEvents.
     * @example
     * // Create many GameEvents
     * const gameEvent = await prisma.gameEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameEvents and only return the `id`
     * const gameEventWithIdOnly = await prisma.gameEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameEventCreateManyAndReturnArgs>(args?: SelectSubset<T, GameEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a GameEvent.
     * @param {GameEventDeleteArgs} args - Arguments to delete one GameEvent.
     * @example
     * // Delete one GameEvent
     * const GameEvent = await prisma.gameEvent.delete({
     *   where: {
     *     // ... filter to delete one GameEvent
     *   }
     * })
     * 
     */
    delete<T extends GameEventDeleteArgs>(args: SelectSubset<T, GameEventDeleteArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one GameEvent.
     * @param {GameEventUpdateArgs} args - Arguments to update one GameEvent.
     * @example
     * // Update one GameEvent
     * const gameEvent = await prisma.gameEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameEventUpdateArgs>(args: SelectSubset<T, GameEventUpdateArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more GameEvents.
     * @param {GameEventDeleteManyArgs} args - Arguments to filter GameEvents to delete.
     * @example
     * // Delete a few GameEvents
     * const { count } = await prisma.gameEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameEventDeleteManyArgs>(args?: SelectSubset<T, GameEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameEvents
     * const gameEvent = await prisma.gameEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameEventUpdateManyArgs>(args: SelectSubset<T, GameEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameEvents and returns the data updated in the database.
     * @param {GameEventUpdateManyAndReturnArgs} args - Arguments to update many GameEvents.
     * @example
     * // Update many GameEvents
     * const gameEvent = await prisma.gameEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameEvents and only return the `id`
     * const gameEventWithIdOnly = await prisma.gameEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameEventUpdateManyAndReturnArgs>(args: SelectSubset<T, GameEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one GameEvent.
     * @param {GameEventUpsertArgs} args - Arguments to update or create a GameEvent.
     * @example
     * // Update or create a GameEvent
     * const gameEvent = await prisma.gameEvent.upsert({
     *   create: {
     *     // ... data to create a GameEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameEvent we want to update
     *   }
     * })
     */
    upsert<T extends GameEventUpsertArgs>(args: SelectSubset<T, GameEventUpsertArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of GameEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventCountArgs} args - Arguments to filter GameEvents to count.
     * @example
     * // Count the number of GameEvents
     * const count = await prisma.gameEvent.count({
     *   where: {
     *     // ... the filter for the GameEvents we want to count
     *   }
     * })
    **/
    count<T extends GameEventCountArgs>(
      args?: Subset<T, GameEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameEventAggregateArgs>(args: Subset<T, GameEventAggregateArgs>): Prisma.PrismaPromise<GetGameEventAggregateType<T>>

    /**
     * Group by GameEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameEventGroupByArgs['orderBy'] }
        : { orderBy?: GameEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameEvent model
   */
  readonly fields: GameEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    initiator<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    target<T extends GameEvent$targetArgs<ExtArgs> = {}>(args?: Subset<T, GameEvent$targetArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameEvent model
   */ 
  interface GameEventFieldRefs {
    readonly id: FieldRef<"GameEvent", 'String'>
    readonly createdAt: FieldRef<"GameEvent", 'DateTime'>
    readonly eventType: FieldRef<"GameEvent", 'EventType'>
    readonly initiatorId: FieldRef<"GameEvent", 'String'>
    readonly targetId: FieldRef<"GameEvent", 'String'>
    readonly message: FieldRef<"GameEvent", 'String'>
    readonly metadata: FieldRef<"GameEvent", 'Json'>
    readonly gameId: FieldRef<"GameEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GameEvent findUnique
   */
  export type GameEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * Filter, which GameEvent to fetch.
     */
    where: GameEventWhereUniqueInput
  }

  /**
   * GameEvent findUniqueOrThrow
   */
  export type GameEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * Filter, which GameEvent to fetch.
     */
    where: GameEventWhereUniqueInput
  }

  /**
   * GameEvent findFirst
   */
  export type GameEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * Filter, which GameEvent to fetch.
     */
    where?: GameEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameEvents to fetch.
     */
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameEvents.
     */
    cursor?: GameEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameEvents.
     */
    distinct?: GameEventScalarFieldEnum | GameEventScalarFieldEnum[]
  }

  /**
   * GameEvent findFirstOrThrow
   */
  export type GameEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * Filter, which GameEvent to fetch.
     */
    where?: GameEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameEvents to fetch.
     */
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameEvents.
     */
    cursor?: GameEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameEvents.
     */
    distinct?: GameEventScalarFieldEnum | GameEventScalarFieldEnum[]
  }

  /**
   * GameEvent findMany
   */
  export type GameEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * Filter, which GameEvents to fetch.
     */
    where?: GameEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameEvents to fetch.
     */
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameEvents.
     */
    cursor?: GameEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameEvents.
     */
    skip?: number
    distinct?: GameEventScalarFieldEnum | GameEventScalarFieldEnum[]
  }

  /**
   * GameEvent create
   */
  export type GameEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * The data needed to create a GameEvent.
     */
    data: XOR<GameEventCreateInput, GameEventUncheckedCreateInput>
  }

  /**
   * GameEvent createMany
   */
  export type GameEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameEvents.
     */
    data: GameEventCreateManyInput | GameEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameEvent createManyAndReturn
   */
  export type GameEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * The data used to create many GameEvents.
     */
    data: GameEventCreateManyInput | GameEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameEvent update
   */
  export type GameEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * The data needed to update a GameEvent.
     */
    data: XOR<GameEventUpdateInput, GameEventUncheckedUpdateInput>
    /**
     * Choose, which GameEvent to update.
     */
    where: GameEventWhereUniqueInput
  }

  /**
   * GameEvent updateMany
   */
  export type GameEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameEvents.
     */
    data: XOR<GameEventUpdateManyMutationInput, GameEventUncheckedUpdateManyInput>
    /**
     * Filter which GameEvents to update
     */
    where?: GameEventWhereInput
  }

  /**
   * GameEvent updateManyAndReturn
   */
  export type GameEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * The data used to update GameEvents.
     */
    data: XOR<GameEventUpdateManyMutationInput, GameEventUncheckedUpdateManyInput>
    /**
     * Filter which GameEvents to update
     */
    where?: GameEventWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameEvent upsert
   */
  export type GameEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * The filter to search for the GameEvent to update in case it exists.
     */
    where: GameEventWhereUniqueInput
    /**
     * In case the GameEvent found by the `where` argument doesn't exist, create a new GameEvent with this data.
     */
    create: XOR<GameEventCreateInput, GameEventUncheckedCreateInput>
    /**
     * In case the GameEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameEventUpdateInput, GameEventUncheckedUpdateInput>
  }

  /**
   * GameEvent delete
   */
  export type GameEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * Filter which GameEvent to delete.
     */
    where: GameEventWhereUniqueInput
  }

  /**
   * GameEvent deleteMany
   */
  export type GameEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameEvents to delete
     */
    where?: GameEventWhereInput
  }

  /**
   * GameEvent.target
   */
  export type GameEvent$targetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * GameEvent without action
   */
  export type GameEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
  }


  /**
   * Model AgentProfile
   */

  export type AggregateAgentProfile = {
    _count: AgentProfileCountAggregateOutputType | null
    _avg: AgentProfileAvgAggregateOutputType | null
    _sum: AgentProfileSumAggregateOutputType | null
    _min: AgentProfileMinAggregateOutputType | null
    _max: AgentProfileMaxAggregateOutputType | null
  }

  export type AgentProfileAvgAggregateOutputType = {
    onchainId: number | null
    followers: number | null
  }

  export type AgentProfileSumAggregateOutputType = {
    onchainId: number | null
    followers: number | null
  }

  export type AgentProfileMinAggregateOutputType = {
    id: string | null
    onchainId: number | null
    name: string | null
    xHandle: string | null
    description: string | null
    telegramLink: string | null
    followers: number | null
    loreFulltext: string | null
  }

  export type AgentProfileMaxAggregateOutputType = {
    id: string | null
    onchainId: number | null
    name: string | null
    xHandle: string | null
    description: string | null
    telegramLink: string | null
    followers: number | null
    loreFulltext: string | null
  }

  export type AgentProfileCountAggregateOutputType = {
    id: number
    onchainId: number
    name: number
    xHandle: number
    description: number
    telegramLink: number
    followers: number
    bio: number
    lore: number
    loreFulltext: number
    characteristics: number
    knowledge: number
    traits: number
    postExamples: number
    _all: number
  }


  export type AgentProfileAvgAggregateInputType = {
    onchainId?: true
    followers?: true
  }

  export type AgentProfileSumAggregateInputType = {
    onchainId?: true
    followers?: true
  }

  export type AgentProfileMinAggregateInputType = {
    id?: true
    onchainId?: true
    name?: true
    xHandle?: true
    description?: true
    telegramLink?: true
    followers?: true
    loreFulltext?: true
  }

  export type AgentProfileMaxAggregateInputType = {
    id?: true
    onchainId?: true
    name?: true
    xHandle?: true
    description?: true
    telegramLink?: true
    followers?: true
    loreFulltext?: true
  }

  export type AgentProfileCountAggregateInputType = {
    id?: true
    onchainId?: true
    name?: true
    xHandle?: true
    description?: true
    telegramLink?: true
    followers?: true
    bio?: true
    lore?: true
    loreFulltext?: true
    characteristics?: true
    knowledge?: true
    traits?: true
    postExamples?: true
    _all?: true
  }

  export type AgentProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentProfile to aggregate.
     */
    where?: AgentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentProfiles to fetch.
     */
    orderBy?: AgentProfileOrderByWithRelationInput | AgentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentProfiles
    **/
    _count?: true | AgentProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentProfileMaxAggregateInputType
  }

  export type GetAgentProfileAggregateType<T extends AgentProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentProfile[P]>
      : GetScalarType<T[P], AggregateAgentProfile[P]>
  }




  export type AgentProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentProfileWhereInput
    orderBy?: AgentProfileOrderByWithAggregationInput | AgentProfileOrderByWithAggregationInput[]
    by: AgentProfileScalarFieldEnum[] | AgentProfileScalarFieldEnum
    having?: AgentProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentProfileCountAggregateInputType | true
    _avg?: AgentProfileAvgAggregateInputType
    _sum?: AgentProfileSumAggregateInputType
    _min?: AgentProfileMinAggregateInputType
    _max?: AgentProfileMaxAggregateInputType
  }

  export type AgentProfileGroupByOutputType = {
    id: string
    onchainId: number
    name: string
    xHandle: string
    description: string
    telegramLink: string
    followers: number
    bio: string[]
    lore: string[]
    loreFulltext: string
    characteristics: string[]
    knowledge: string[]
    traits: JsonValue
    postExamples: string[]
    _count: AgentProfileCountAggregateOutputType | null
    _avg: AgentProfileAvgAggregateOutputType | null
    _sum: AgentProfileSumAggregateOutputType | null
    _min: AgentProfileMinAggregateOutputType | null
    _max: AgentProfileMaxAggregateOutputType | null
  }

  type GetAgentProfileGroupByPayload<T extends AgentProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentProfileGroupByOutputType[P]>
            : GetScalarType<T[P], AgentProfileGroupByOutputType[P]>
        }
      >
    >


  export type AgentProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    onchainId?: boolean
    name?: boolean
    xHandle?: boolean
    description?: boolean
    telegramLink?: boolean
    followers?: boolean
    bio?: boolean
    lore?: boolean
    loreFulltext?: boolean
    characteristics?: boolean
    knowledge?: boolean
    traits?: boolean
    postExamples?: boolean
    agents?: boolean | AgentProfile$agentsArgs<ExtArgs>
    _count?: boolean | AgentProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentProfile"]>

  export type AgentProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    onchainId?: boolean
    name?: boolean
    xHandle?: boolean
    description?: boolean
    telegramLink?: boolean
    followers?: boolean
    bio?: boolean
    lore?: boolean
    loreFulltext?: boolean
    characteristics?: boolean
    knowledge?: boolean
    traits?: boolean
    postExamples?: boolean
  }, ExtArgs["result"]["agentProfile"]>

  export type AgentProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    onchainId?: boolean
    name?: boolean
    xHandle?: boolean
    description?: boolean
    telegramLink?: boolean
    followers?: boolean
    bio?: boolean
    lore?: boolean
    loreFulltext?: boolean
    characteristics?: boolean
    knowledge?: boolean
    traits?: boolean
    postExamples?: boolean
  }, ExtArgs["result"]["agentProfile"]>

  export type AgentProfileSelectScalar = {
    id?: boolean
    onchainId?: boolean
    name?: boolean
    xHandle?: boolean
    description?: boolean
    telegramLink?: boolean
    followers?: boolean
    bio?: boolean
    lore?: boolean
    loreFulltext?: boolean
    characteristics?: boolean
    knowledge?: boolean
    traits?: boolean
    postExamples?: boolean
  }

  export type AgentProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "onchainId" | "name" | "xHandle" | "description" | "telegramLink" | "followers" | "bio" | "lore" | "loreFulltext" | "characteristics" | "knowledge" | "traits" | "postExamples", ExtArgs["result"]["agentProfile"]>
  export type AgentProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agents?: boolean | AgentProfile$agentsArgs<ExtArgs>
    _count?: boolean | AgentProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AgentProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AgentProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentProfile"
    objects: {
      agents: Prisma.$AgentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      onchainId: number
      name: string
      xHandle: string
      description: string
      telegramLink: string
      followers: number
      bio: string[]
      lore: string[]
      loreFulltext: string
      characteristics: string[]
      knowledge: string[]
      traits: Prisma.JsonValue
      postExamples: string[]
    }, ExtArgs["result"]["agentProfile"]>
    composites: {}
  }

  type AgentProfileGetPayload<S extends boolean | null | undefined | AgentProfileDefaultArgs> = $Result.GetResult<Prisma.$AgentProfilePayload, S>

  type AgentProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentProfileCountAggregateInputType | true
    }

  export interface AgentProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentProfile'], meta: { name: 'AgentProfile' } }
    /**
     * Find zero or one AgentProfile that matches the filter.
     * @param {AgentProfileFindUniqueArgs} args - Arguments to find a AgentProfile
     * @example
     * // Get one AgentProfile
     * const agentProfile = await prisma.agentProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentProfileFindUniqueArgs>(args: SelectSubset<T, AgentProfileFindUniqueArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AgentProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentProfileFindUniqueOrThrowArgs} args - Arguments to find a AgentProfile
     * @example
     * // Get one AgentProfile
     * const agentProfile = await prisma.agentProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AgentProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentProfileFindFirstArgs} args - Arguments to find a AgentProfile
     * @example
     * // Get one AgentProfile
     * const agentProfile = await prisma.agentProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentProfileFindFirstArgs>(args?: SelectSubset<T, AgentProfileFindFirstArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AgentProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentProfileFindFirstOrThrowArgs} args - Arguments to find a AgentProfile
     * @example
     * // Get one AgentProfile
     * const agentProfile = await prisma.agentProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AgentProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentProfiles
     * const agentProfiles = await prisma.agentProfile.findMany()
     * 
     * // Get first 10 AgentProfiles
     * const agentProfiles = await prisma.agentProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentProfileWithIdOnly = await prisma.agentProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentProfileFindManyArgs>(args?: SelectSubset<T, AgentProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AgentProfile.
     * @param {AgentProfileCreateArgs} args - Arguments to create a AgentProfile.
     * @example
     * // Create one AgentProfile
     * const AgentProfile = await prisma.agentProfile.create({
     *   data: {
     *     // ... data to create a AgentProfile
     *   }
     * })
     * 
     */
    create<T extends AgentProfileCreateArgs>(args: SelectSubset<T, AgentProfileCreateArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AgentProfiles.
     * @param {AgentProfileCreateManyArgs} args - Arguments to create many AgentProfiles.
     * @example
     * // Create many AgentProfiles
     * const agentProfile = await prisma.agentProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentProfileCreateManyArgs>(args?: SelectSubset<T, AgentProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentProfiles and returns the data saved in the database.
     * @param {AgentProfileCreateManyAndReturnArgs} args - Arguments to create many AgentProfiles.
     * @example
     * // Create many AgentProfiles
     * const agentProfile = await prisma.agentProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentProfiles and only return the `id`
     * const agentProfileWithIdOnly = await prisma.agentProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AgentProfile.
     * @param {AgentProfileDeleteArgs} args - Arguments to delete one AgentProfile.
     * @example
     * // Delete one AgentProfile
     * const AgentProfile = await prisma.agentProfile.delete({
     *   where: {
     *     // ... filter to delete one AgentProfile
     *   }
     * })
     * 
     */
    delete<T extends AgentProfileDeleteArgs>(args: SelectSubset<T, AgentProfileDeleteArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AgentProfile.
     * @param {AgentProfileUpdateArgs} args - Arguments to update one AgentProfile.
     * @example
     * // Update one AgentProfile
     * const agentProfile = await prisma.agentProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentProfileUpdateArgs>(args: SelectSubset<T, AgentProfileUpdateArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AgentProfiles.
     * @param {AgentProfileDeleteManyArgs} args - Arguments to filter AgentProfiles to delete.
     * @example
     * // Delete a few AgentProfiles
     * const { count } = await prisma.agentProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentProfileDeleteManyArgs>(args?: SelectSubset<T, AgentProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentProfiles
     * const agentProfile = await prisma.agentProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentProfileUpdateManyArgs>(args: SelectSubset<T, AgentProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentProfiles and returns the data updated in the database.
     * @param {AgentProfileUpdateManyAndReturnArgs} args - Arguments to update many AgentProfiles.
     * @example
     * // Update many AgentProfiles
     * const agentProfile = await prisma.agentProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentProfiles and only return the `id`
     * const agentProfileWithIdOnly = await prisma.agentProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AgentProfile.
     * @param {AgentProfileUpsertArgs} args - Arguments to update or create a AgentProfile.
     * @example
     * // Update or create a AgentProfile
     * const agentProfile = await prisma.agentProfile.upsert({
     *   create: {
     *     // ... data to create a AgentProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentProfile we want to update
     *   }
     * })
     */
    upsert<T extends AgentProfileUpsertArgs>(args: SelectSubset<T, AgentProfileUpsertArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AgentProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentProfileCountArgs} args - Arguments to filter AgentProfiles to count.
     * @example
     * // Count the number of AgentProfiles
     * const count = await prisma.agentProfile.count({
     *   where: {
     *     // ... the filter for the AgentProfiles we want to count
     *   }
     * })
    **/
    count<T extends AgentProfileCountArgs>(
      args?: Subset<T, AgentProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentProfileAggregateArgs>(args: Subset<T, AgentProfileAggregateArgs>): Prisma.PrismaPromise<GetAgentProfileAggregateType<T>>

    /**
     * Group by AgentProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentProfileGroupByArgs['orderBy'] }
        : { orderBy?: AgentProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentProfile model
   */
  readonly fields: AgentProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agents<T extends AgentProfile$agentsArgs<ExtArgs> = {}>(args?: Subset<T, AgentProfile$agentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentProfile model
   */ 
  interface AgentProfileFieldRefs {
    readonly id: FieldRef<"AgentProfile", 'String'>
    readonly onchainId: FieldRef<"AgentProfile", 'Int'>
    readonly name: FieldRef<"AgentProfile", 'String'>
    readonly xHandle: FieldRef<"AgentProfile", 'String'>
    readonly description: FieldRef<"AgentProfile", 'String'>
    readonly telegramLink: FieldRef<"AgentProfile", 'String'>
    readonly followers: FieldRef<"AgentProfile", 'Int'>
    readonly bio: FieldRef<"AgentProfile", 'String[]'>
    readonly lore: FieldRef<"AgentProfile", 'String[]'>
    readonly loreFulltext: FieldRef<"AgentProfile", 'String'>
    readonly characteristics: FieldRef<"AgentProfile", 'String[]'>
    readonly knowledge: FieldRef<"AgentProfile", 'String[]'>
    readonly traits: FieldRef<"AgentProfile", 'Json'>
    readonly postExamples: FieldRef<"AgentProfile", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * AgentProfile findUnique
   */
  export type AgentProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    /**
     * Filter, which AgentProfile to fetch.
     */
    where: AgentProfileWhereUniqueInput
  }

  /**
   * AgentProfile findUniqueOrThrow
   */
  export type AgentProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    /**
     * Filter, which AgentProfile to fetch.
     */
    where: AgentProfileWhereUniqueInput
  }

  /**
   * AgentProfile findFirst
   */
  export type AgentProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    /**
     * Filter, which AgentProfile to fetch.
     */
    where?: AgentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentProfiles to fetch.
     */
    orderBy?: AgentProfileOrderByWithRelationInput | AgentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentProfiles.
     */
    cursor?: AgentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentProfiles.
     */
    distinct?: AgentProfileScalarFieldEnum | AgentProfileScalarFieldEnum[]
  }

  /**
   * AgentProfile findFirstOrThrow
   */
  export type AgentProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    /**
     * Filter, which AgentProfile to fetch.
     */
    where?: AgentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentProfiles to fetch.
     */
    orderBy?: AgentProfileOrderByWithRelationInput | AgentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentProfiles.
     */
    cursor?: AgentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentProfiles.
     */
    distinct?: AgentProfileScalarFieldEnum | AgentProfileScalarFieldEnum[]
  }

  /**
   * AgentProfile findMany
   */
  export type AgentProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    /**
     * Filter, which AgentProfiles to fetch.
     */
    where?: AgentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentProfiles to fetch.
     */
    orderBy?: AgentProfileOrderByWithRelationInput | AgentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentProfiles.
     */
    cursor?: AgentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentProfiles.
     */
    skip?: number
    distinct?: AgentProfileScalarFieldEnum | AgentProfileScalarFieldEnum[]
  }

  /**
   * AgentProfile create
   */
  export type AgentProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentProfile.
     */
    data: XOR<AgentProfileCreateInput, AgentProfileUncheckedCreateInput>
  }

  /**
   * AgentProfile createMany
   */
  export type AgentProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentProfiles.
     */
    data: AgentProfileCreateManyInput | AgentProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentProfile createManyAndReturn
   */
  export type AgentProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * The data used to create many AgentProfiles.
     */
    data: AgentProfileCreateManyInput | AgentProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentProfile update
   */
  export type AgentProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentProfile.
     */
    data: XOR<AgentProfileUpdateInput, AgentProfileUncheckedUpdateInput>
    /**
     * Choose, which AgentProfile to update.
     */
    where: AgentProfileWhereUniqueInput
  }

  /**
   * AgentProfile updateMany
   */
  export type AgentProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentProfiles.
     */
    data: XOR<AgentProfileUpdateManyMutationInput, AgentProfileUncheckedUpdateManyInput>
    /**
     * Filter which AgentProfiles to update
     */
    where?: AgentProfileWhereInput
  }

  /**
   * AgentProfile updateManyAndReturn
   */
  export type AgentProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * The data used to update AgentProfiles.
     */
    data: XOR<AgentProfileUpdateManyMutationInput, AgentProfileUncheckedUpdateManyInput>
    /**
     * Filter which AgentProfiles to update
     */
    where?: AgentProfileWhereInput
  }

  /**
   * AgentProfile upsert
   */
  export type AgentProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentProfile to update in case it exists.
     */
    where: AgentProfileWhereUniqueInput
    /**
     * In case the AgentProfile found by the `where` argument doesn't exist, create a new AgentProfile with this data.
     */
    create: XOR<AgentProfileCreateInput, AgentProfileUncheckedCreateInput>
    /**
     * In case the AgentProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentProfileUpdateInput, AgentProfileUncheckedUpdateInput>
  }

  /**
   * AgentProfile delete
   */
  export type AgentProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    /**
     * Filter which AgentProfile to delete.
     */
    where: AgentProfileWhereUniqueInput
  }

  /**
   * AgentProfile deleteMany
   */
  export type AgentProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentProfiles to delete
     */
    where?: AgentProfileWhereInput
  }

  /**
   * AgentProfile.agents
   */
  export type AgentProfile$agentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    cursor?: AgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * AgentProfile without action
   */
  export type AgentProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
  }


  /**
   * Model Agent
   */

  export type AggregateAgent = {
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  export type AgentAvgAggregateOutputType = {
    onchainId: number | null
  }

  export type AgentSumAggregateOutputType = {
    onchainId: number | null
  }

  export type AgentMinAggregateOutputType = {
    id: string | null
    onchainId: number | null
    authority: string | null
    authorityAssociatedTokenAddress: string | null
    pda: string | null
    gameId: string | null
    isAlive: boolean | null
    profileId: string | null
    deathTimestamp: Date | null
    mapTileId: string | null
    vault: string | null
  }

  export type AgentMaxAggregateOutputType = {
    id: string | null
    onchainId: number | null
    authority: string | null
    authorityAssociatedTokenAddress: string | null
    pda: string | null
    gameId: string | null
    isAlive: boolean | null
    profileId: string | null
    deathTimestamp: Date | null
    mapTileId: string | null
    vault: string | null
  }

  export type AgentCountAggregateOutputType = {
    id: number
    onchainId: number
    authority: number
    authorityAssociatedTokenAddress: number
    pda: number
    gameId: number
    isAlive: number
    profileId: number
    deathTimestamp: number
    mapTileId: number
    vault: number
    _all: number
  }


  export type AgentAvgAggregateInputType = {
    onchainId?: true
  }

  export type AgentSumAggregateInputType = {
    onchainId?: true
  }

  export type AgentMinAggregateInputType = {
    id?: true
    onchainId?: true
    authority?: true
    authorityAssociatedTokenAddress?: true
    pda?: true
    gameId?: true
    isAlive?: true
    profileId?: true
    deathTimestamp?: true
    mapTileId?: true
    vault?: true
  }

  export type AgentMaxAggregateInputType = {
    id?: true
    onchainId?: true
    authority?: true
    authorityAssociatedTokenAddress?: true
    pda?: true
    gameId?: true
    isAlive?: true
    profileId?: true
    deathTimestamp?: true
    mapTileId?: true
    vault?: true
  }

  export type AgentCountAggregateInputType = {
    id?: true
    onchainId?: true
    authority?: true
    authorityAssociatedTokenAddress?: true
    pda?: true
    gameId?: true
    isAlive?: true
    profileId?: true
    deathTimestamp?: true
    mapTileId?: true
    vault?: true
    _all?: true
  }

  export type AgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agent to aggregate.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agents
    **/
    _count?: true | AgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMaxAggregateInputType
  }

  export type GetAgentAggregateType<T extends AgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent[P]>
      : GetScalarType<T[P], AggregateAgent[P]>
  }




  export type AgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithAggregationInput | AgentOrderByWithAggregationInput[]
    by: AgentScalarFieldEnum[] | AgentScalarFieldEnum
    having?: AgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentCountAggregateInputType | true
    _avg?: AgentAvgAggregateInputType
    _sum?: AgentSumAggregateInputType
    _min?: AgentMinAggregateInputType
    _max?: AgentMaxAggregateInputType
  }

  export type AgentGroupByOutputType = {
    id: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    gameId: string
    isAlive: boolean
    profileId: string
    deathTimestamp: Date | null
    mapTileId: string
    vault: string
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  type GetAgentGroupByPayload<T extends AgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgentGroupByOutputType[P]>
        }
      >
    >


  export type AgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    onchainId?: boolean
    authority?: boolean
    authorityAssociatedTokenAddress?: boolean
    pda?: boolean
    gameId?: boolean
    isAlive?: boolean
    profileId?: boolean
    deathTimestamp?: boolean
    mapTileId?: boolean
    vault?: boolean
    tweets?: boolean | Agent$tweetsArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    battlesAsAttacker?: boolean | Agent$battlesAsAttackerArgs<ExtArgs>
    battlesAsDefender?: boolean | Agent$battlesAsDefenderArgs<ExtArgs>
    battlesAsAttackerAlly?: boolean | Agent$battlesAsAttackerAllyArgs<ExtArgs>
    battlesAsDefenderAlly?: boolean | Agent$battlesAsDefenderAllyArgs<ExtArgs>
    wonBattles?: boolean | Agent$wonBattlesArgs<ExtArgs>
    coolDown?: boolean | Agent$coolDownArgs<ExtArgs>
    initiatedAlliances?: boolean | Agent$initiatedAlliancesArgs<ExtArgs>
    joinedAlliances?: boolean | Agent$joinedAlliancesArgs<ExtArgs>
    profile?: boolean | AgentProfileDefaultArgs<ExtArgs>
    mapTile?: boolean | MapTileDefaultArgs<ExtArgs>
    ignoredBy?: boolean | Agent$ignoredByArgs<ExtArgs>
    ignoring?: boolean | Agent$ignoringArgs<ExtArgs>
    GameLog?: boolean | Agent$GameLogArgs<ExtArgs>
    initiatedEvents?: boolean | Agent$initiatedEventsArgs<ExtArgs>
    targetedEvents?: boolean | Agent$targetedEventsArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    onchainId?: boolean
    authority?: boolean
    authorityAssociatedTokenAddress?: boolean
    pda?: boolean
    gameId?: boolean
    isAlive?: boolean
    profileId?: boolean
    deathTimestamp?: boolean
    mapTileId?: boolean
    vault?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    profile?: boolean | AgentProfileDefaultArgs<ExtArgs>
    mapTile?: boolean | MapTileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    onchainId?: boolean
    authority?: boolean
    authorityAssociatedTokenAddress?: boolean
    pda?: boolean
    gameId?: boolean
    isAlive?: boolean
    profileId?: boolean
    deathTimestamp?: boolean
    mapTileId?: boolean
    vault?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    profile?: boolean | AgentProfileDefaultArgs<ExtArgs>
    mapTile?: boolean | MapTileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectScalar = {
    id?: boolean
    onchainId?: boolean
    authority?: boolean
    authorityAssociatedTokenAddress?: boolean
    pda?: boolean
    gameId?: boolean
    isAlive?: boolean
    profileId?: boolean
    deathTimestamp?: boolean
    mapTileId?: boolean
    vault?: boolean
  }

  export type AgentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "onchainId" | "authority" | "authorityAssociatedTokenAddress" | "pda" | "gameId" | "isAlive" | "profileId" | "deathTimestamp" | "mapTileId" | "vault", ExtArgs["result"]["agent"]>
  export type AgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | Agent$tweetsArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    battlesAsAttacker?: boolean | Agent$battlesAsAttackerArgs<ExtArgs>
    battlesAsDefender?: boolean | Agent$battlesAsDefenderArgs<ExtArgs>
    battlesAsAttackerAlly?: boolean | Agent$battlesAsAttackerAllyArgs<ExtArgs>
    battlesAsDefenderAlly?: boolean | Agent$battlesAsDefenderAllyArgs<ExtArgs>
    wonBattles?: boolean | Agent$wonBattlesArgs<ExtArgs>
    coolDown?: boolean | Agent$coolDownArgs<ExtArgs>
    initiatedAlliances?: boolean | Agent$initiatedAlliancesArgs<ExtArgs>
    joinedAlliances?: boolean | Agent$joinedAlliancesArgs<ExtArgs>
    profile?: boolean | AgentProfileDefaultArgs<ExtArgs>
    mapTile?: boolean | MapTileDefaultArgs<ExtArgs>
    ignoredBy?: boolean | Agent$ignoredByArgs<ExtArgs>
    ignoring?: boolean | Agent$ignoringArgs<ExtArgs>
    GameLog?: boolean | Agent$GameLogArgs<ExtArgs>
    initiatedEvents?: boolean | Agent$initiatedEventsArgs<ExtArgs>
    targetedEvents?: boolean | Agent$targetedEventsArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    profile?: boolean | AgentProfileDefaultArgs<ExtArgs>
    mapTile?: boolean | MapTileDefaultArgs<ExtArgs>
  }
  export type AgentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    profile?: boolean | AgentProfileDefaultArgs<ExtArgs>
    mapTile?: boolean | MapTileDefaultArgs<ExtArgs>
  }

  export type $AgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agent"
    objects: {
      tweets: Prisma.$TweetPayload<ExtArgs>[]
      game: Prisma.$GamePayload<ExtArgs>
      battlesAsAttacker: Prisma.$BattlePayload<ExtArgs>[]
      battlesAsDefender: Prisma.$BattlePayload<ExtArgs>[]
      battlesAsAttackerAlly: Prisma.$BattlePayload<ExtArgs>[]
      battlesAsDefenderAlly: Prisma.$BattlePayload<ExtArgs>[]
      wonBattles: Prisma.$BattlePayload<ExtArgs>[]
      coolDown: Prisma.$CoolDownPayload<ExtArgs>[]
      initiatedAlliances: Prisma.$AlliancePayload<ExtArgs>[]
      joinedAlliances: Prisma.$AlliancePayload<ExtArgs>[]
      profile: Prisma.$AgentProfilePayload<ExtArgs>
      mapTile: Prisma.$MapTilePayload<ExtArgs>
      ignoredBy: Prisma.$IgnorePayload<ExtArgs>[]
      ignoring: Prisma.$IgnorePayload<ExtArgs>[]
      GameLog: Prisma.$GameLogPayload<ExtArgs>[]
      initiatedEvents: Prisma.$GameEventPayload<ExtArgs>[]
      targetedEvents: Prisma.$GameEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      onchainId: number
      authority: string
      authorityAssociatedTokenAddress: string
      pda: string
      gameId: string
      isAlive: boolean
      profileId: string
      deathTimestamp: Date | null
      mapTileId: string
      vault: string
    }, ExtArgs["result"]["agent"]>
    composites: {}
  }

  type AgentGetPayload<S extends boolean | null | undefined | AgentDefaultArgs> = $Result.GetResult<Prisma.$AgentPayload, S>

  type AgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentCountAggregateInputType | true
    }

  export interface AgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agent'], meta: { name: 'Agent' } }
    /**
     * Find zero or one Agent that matches the filter.
     * @param {AgentFindUniqueArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentFindUniqueArgs>(args: SelectSubset<T, AgentFindUniqueArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Agent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentFindUniqueOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Agent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentFindFirstArgs>(args?: SelectSubset<T, AgentFindFirstArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Agent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Agents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agents
     * const agents = await prisma.agent.findMany()
     * 
     * // Get first 10 Agents
     * const agents = await prisma.agent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentWithIdOnly = await prisma.agent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentFindManyArgs>(args?: SelectSubset<T, AgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Agent.
     * @param {AgentCreateArgs} args - Arguments to create a Agent.
     * @example
     * // Create one Agent
     * const Agent = await prisma.agent.create({
     *   data: {
     *     // ... data to create a Agent
     *   }
     * })
     * 
     */
    create<T extends AgentCreateArgs>(args: SelectSubset<T, AgentCreateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Agents.
     * @param {AgentCreateManyArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentCreateManyArgs>(args?: SelectSubset<T, AgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agents and returns the data saved in the database.
     * @param {AgentCreateManyAndReturnArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Agent.
     * @param {AgentDeleteArgs} args - Arguments to delete one Agent.
     * @example
     * // Delete one Agent
     * const Agent = await prisma.agent.delete({
     *   where: {
     *     // ... filter to delete one Agent
     *   }
     * })
     * 
     */
    delete<T extends AgentDeleteArgs>(args: SelectSubset<T, AgentDeleteArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Agent.
     * @param {AgentUpdateArgs} args - Arguments to update one Agent.
     * @example
     * // Update one Agent
     * const agent = await prisma.agent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentUpdateArgs>(args: SelectSubset<T, AgentUpdateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Agents.
     * @param {AgentDeleteManyArgs} args - Arguments to filter Agents to delete.
     * @example
     * // Delete a few Agents
     * const { count } = await prisma.agent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentDeleteManyArgs>(args?: SelectSubset<T, AgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentUpdateManyArgs>(args: SelectSubset<T, AgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents and returns the data updated in the database.
     * @param {AgentUpdateManyAndReturnArgs} args - Arguments to update many Agents.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Agent.
     * @param {AgentUpsertArgs} args - Arguments to update or create a Agent.
     * @example
     * // Update or create a Agent
     * const agent = await prisma.agent.upsert({
     *   create: {
     *     // ... data to create a Agent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent we want to update
     *   }
     * })
     */
    upsert<T extends AgentUpsertArgs>(args: SelectSubset<T, AgentUpsertArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentCountArgs} args - Arguments to filter Agents to count.
     * @example
     * // Count the number of Agents
     * const count = await prisma.agent.count({
     *   where: {
     *     // ... the filter for the Agents we want to count
     *   }
     * })
    **/
    count<T extends AgentCountArgs>(
      args?: Subset<T, AgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentAggregateArgs>(args: Subset<T, AgentAggregateArgs>): Prisma.PrismaPromise<GetAgentAggregateType<T>>

    /**
     * Group by Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentGroupByArgs['orderBy'] }
        : { orderBy?: AgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agent model
   */
  readonly fields: AgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tweets<T extends Agent$tweetsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$tweetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    battlesAsAttacker<T extends Agent$battlesAsAttackerArgs<ExtArgs> = {}>(args?: Subset<T, Agent$battlesAsAttackerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    battlesAsDefender<T extends Agent$battlesAsDefenderArgs<ExtArgs> = {}>(args?: Subset<T, Agent$battlesAsDefenderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    battlesAsAttackerAlly<T extends Agent$battlesAsAttackerAllyArgs<ExtArgs> = {}>(args?: Subset<T, Agent$battlesAsAttackerAllyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    battlesAsDefenderAlly<T extends Agent$battlesAsDefenderAllyArgs<ExtArgs> = {}>(args?: Subset<T, Agent$battlesAsDefenderAllyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    wonBattles<T extends Agent$wonBattlesArgs<ExtArgs> = {}>(args?: Subset<T, Agent$wonBattlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    coolDown<T extends Agent$coolDownArgs<ExtArgs> = {}>(args?: Subset<T, Agent$coolDownArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoolDownPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    initiatedAlliances<T extends Agent$initiatedAlliancesArgs<ExtArgs> = {}>(args?: Subset<T, Agent$initiatedAlliancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlliancePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    joinedAlliances<T extends Agent$joinedAlliancesArgs<ExtArgs> = {}>(args?: Subset<T, Agent$joinedAlliancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlliancePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    profile<T extends AgentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentProfileDefaultArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    mapTile<T extends MapTileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MapTileDefaultArgs<ExtArgs>>): Prisma__MapTileClient<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    ignoredBy<T extends Agent$ignoredByArgs<ExtArgs> = {}>(args?: Subset<T, Agent$ignoredByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IgnorePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ignoring<T extends Agent$ignoringArgs<ExtArgs> = {}>(args?: Subset<T, Agent$ignoringArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IgnorePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    GameLog<T extends Agent$GameLogArgs<ExtArgs> = {}>(args?: Subset<T, Agent$GameLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameLogPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    initiatedEvents<T extends Agent$initiatedEventsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$initiatedEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    targetedEvents<T extends Agent$targetedEventsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$targetedEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agent model
   */ 
  interface AgentFieldRefs {
    readonly id: FieldRef<"Agent", 'String'>
    readonly onchainId: FieldRef<"Agent", 'Int'>
    readonly authority: FieldRef<"Agent", 'String'>
    readonly authorityAssociatedTokenAddress: FieldRef<"Agent", 'String'>
    readonly pda: FieldRef<"Agent", 'String'>
    readonly gameId: FieldRef<"Agent", 'String'>
    readonly isAlive: FieldRef<"Agent", 'Boolean'>
    readonly profileId: FieldRef<"Agent", 'String'>
    readonly deathTimestamp: FieldRef<"Agent", 'DateTime'>
    readonly mapTileId: FieldRef<"Agent", 'String'>
    readonly vault: FieldRef<"Agent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Agent findUnique
   */
  export type AgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findUniqueOrThrow
   */
  export type AgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findFirst
   */
  export type AgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findFirstOrThrow
   */
  export type AgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findMany
   */
  export type AgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agents to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent create
   */
  export type AgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to create a Agent.
     */
    data: XOR<AgentCreateInput, AgentUncheckedCreateInput>
  }

  /**
   * Agent createMany
   */
  export type AgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent createManyAndReturn
   */
  export type AgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agent update
   */
  export type AgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to update a Agent.
     */
    data: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
    /**
     * Choose, which Agent to update.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent updateMany
   */
  export type AgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
  }

  /**
   * Agent updateManyAndReturn
   */
  export type AgentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agent upsert
   */
  export type AgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The filter to search for the Agent to update in case it exists.
     */
    where: AgentWhereUniqueInput
    /**
     * In case the Agent found by the `where` argument doesn't exist, create a new Agent with this data.
     */
    create: XOR<AgentCreateInput, AgentUncheckedCreateInput>
    /**
     * In case the Agent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
  }

  /**
   * Agent delete
   */
  export type AgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter which Agent to delete.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent deleteMany
   */
  export type AgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agents to delete
     */
    where?: AgentWhereInput
  }

  /**
   * Agent.tweets
   */
  export type Agent$tweetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    where?: TweetWhereInput
    orderBy?: TweetOrderByWithRelationInput | TweetOrderByWithRelationInput[]
    cursor?: TweetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TweetScalarFieldEnum | TweetScalarFieldEnum[]
  }

  /**
   * Agent.battlesAsAttacker
   */
  export type Agent$battlesAsAttackerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    where?: BattleWhereInput
    orderBy?: BattleOrderByWithRelationInput | BattleOrderByWithRelationInput[]
    cursor?: BattleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BattleScalarFieldEnum | BattleScalarFieldEnum[]
  }

  /**
   * Agent.battlesAsDefender
   */
  export type Agent$battlesAsDefenderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    where?: BattleWhereInput
    orderBy?: BattleOrderByWithRelationInput | BattleOrderByWithRelationInput[]
    cursor?: BattleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BattleScalarFieldEnum | BattleScalarFieldEnum[]
  }

  /**
   * Agent.battlesAsAttackerAlly
   */
  export type Agent$battlesAsAttackerAllyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    where?: BattleWhereInput
    orderBy?: BattleOrderByWithRelationInput | BattleOrderByWithRelationInput[]
    cursor?: BattleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BattleScalarFieldEnum | BattleScalarFieldEnum[]
  }

  /**
   * Agent.battlesAsDefenderAlly
   */
  export type Agent$battlesAsDefenderAllyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    where?: BattleWhereInput
    orderBy?: BattleOrderByWithRelationInput | BattleOrderByWithRelationInput[]
    cursor?: BattleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BattleScalarFieldEnum | BattleScalarFieldEnum[]
  }

  /**
   * Agent.wonBattles
   */
  export type Agent$wonBattlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    where?: BattleWhereInput
    orderBy?: BattleOrderByWithRelationInput | BattleOrderByWithRelationInput[]
    cursor?: BattleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BattleScalarFieldEnum | BattleScalarFieldEnum[]
  }

  /**
   * Agent.coolDown
   */
  export type Agent$coolDownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoolDown
     */
    select?: CoolDownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoolDown
     */
    omit?: CoolDownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoolDownInclude<ExtArgs> | null
    where?: CoolDownWhereInput
    orderBy?: CoolDownOrderByWithRelationInput | CoolDownOrderByWithRelationInput[]
    cursor?: CoolDownWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoolDownScalarFieldEnum | CoolDownScalarFieldEnum[]
  }

  /**
   * Agent.initiatedAlliances
   */
  export type Agent$initiatedAlliancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alliance
     */
    select?: AllianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alliance
     */
    omit?: AllianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllianceInclude<ExtArgs> | null
    where?: AllianceWhereInput
    orderBy?: AllianceOrderByWithRelationInput | AllianceOrderByWithRelationInput[]
    cursor?: AllianceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AllianceScalarFieldEnum | AllianceScalarFieldEnum[]
  }

  /**
   * Agent.joinedAlliances
   */
  export type Agent$joinedAlliancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alliance
     */
    select?: AllianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alliance
     */
    omit?: AllianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllianceInclude<ExtArgs> | null
    where?: AllianceWhereInput
    orderBy?: AllianceOrderByWithRelationInput | AllianceOrderByWithRelationInput[]
    cursor?: AllianceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AllianceScalarFieldEnum | AllianceScalarFieldEnum[]
  }

  /**
   * Agent.ignoredBy
   */
  export type Agent$ignoredByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ignore
     */
    select?: IgnoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ignore
     */
    omit?: IgnoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IgnoreInclude<ExtArgs> | null
    where?: IgnoreWhereInput
    orderBy?: IgnoreOrderByWithRelationInput | IgnoreOrderByWithRelationInput[]
    cursor?: IgnoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IgnoreScalarFieldEnum | IgnoreScalarFieldEnum[]
  }

  /**
   * Agent.ignoring
   */
  export type Agent$ignoringArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ignore
     */
    select?: IgnoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ignore
     */
    omit?: IgnoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IgnoreInclude<ExtArgs> | null
    where?: IgnoreWhereInput
    orderBy?: IgnoreOrderByWithRelationInput | IgnoreOrderByWithRelationInput[]
    cursor?: IgnoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IgnoreScalarFieldEnum | IgnoreScalarFieldEnum[]
  }

  /**
   * Agent.GameLog
   */
  export type Agent$GameLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLog
     */
    select?: GameLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLog
     */
    omit?: GameLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLogInclude<ExtArgs> | null
    where?: GameLogWhereInput
    orderBy?: GameLogOrderByWithRelationInput | GameLogOrderByWithRelationInput[]
    cursor?: GameLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameLogScalarFieldEnum | GameLogScalarFieldEnum[]
  }

  /**
   * Agent.initiatedEvents
   */
  export type Agent$initiatedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    where?: GameEventWhereInput
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    cursor?: GameEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameEventScalarFieldEnum | GameEventScalarFieldEnum[]
  }

  /**
   * Agent.targetedEvents
   */
  export type Agent$targetedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    where?: GameEventWhereInput
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    cursor?: GameEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameEventScalarFieldEnum | GameEventScalarFieldEnum[]
  }

  /**
   * Agent without action
   */
  export type AgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
  }


  /**
   * Model Ignore
   */

  export type AggregateIgnore = {
    _count: IgnoreCountAggregateOutputType | null
    _avg: IgnoreAvgAggregateOutputType | null
    _sum: IgnoreSumAggregateOutputType | null
    _min: IgnoreMinAggregateOutputType | null
    _max: IgnoreMaxAggregateOutputType | null
  }

  export type IgnoreAvgAggregateOutputType = {
    duration: number | null
  }

  export type IgnoreSumAggregateOutputType = {
    duration: number | null
  }

  export type IgnoreMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    timestamp: Date | null
    duration: number | null
    gameId: string | null
    ignoredAgentId: string | null
  }

  export type IgnoreMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    timestamp: Date | null
    duration: number | null
    gameId: string | null
    ignoredAgentId: string | null
  }

  export type IgnoreCountAggregateOutputType = {
    id: number
    agentId: number
    timestamp: number
    duration: number
    gameId: number
    ignoredAgentId: number
    _all: number
  }


  export type IgnoreAvgAggregateInputType = {
    duration?: true
  }

  export type IgnoreSumAggregateInputType = {
    duration?: true
  }

  export type IgnoreMinAggregateInputType = {
    id?: true
    agentId?: true
    timestamp?: true
    duration?: true
    gameId?: true
    ignoredAgentId?: true
  }

  export type IgnoreMaxAggregateInputType = {
    id?: true
    agentId?: true
    timestamp?: true
    duration?: true
    gameId?: true
    ignoredAgentId?: true
  }

  export type IgnoreCountAggregateInputType = {
    id?: true
    agentId?: true
    timestamp?: true
    duration?: true
    gameId?: true
    ignoredAgentId?: true
    _all?: true
  }

  export type IgnoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ignore to aggregate.
     */
    where?: IgnoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ignores to fetch.
     */
    orderBy?: IgnoreOrderByWithRelationInput | IgnoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IgnoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ignores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ignores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ignores
    **/
    _count?: true | IgnoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IgnoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IgnoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IgnoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IgnoreMaxAggregateInputType
  }

  export type GetIgnoreAggregateType<T extends IgnoreAggregateArgs> = {
        [P in keyof T & keyof AggregateIgnore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIgnore[P]>
      : GetScalarType<T[P], AggregateIgnore[P]>
  }




  export type IgnoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IgnoreWhereInput
    orderBy?: IgnoreOrderByWithAggregationInput | IgnoreOrderByWithAggregationInput[]
    by: IgnoreScalarFieldEnum[] | IgnoreScalarFieldEnum
    having?: IgnoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IgnoreCountAggregateInputType | true
    _avg?: IgnoreAvgAggregateInputType
    _sum?: IgnoreSumAggregateInputType
    _min?: IgnoreMinAggregateInputType
    _max?: IgnoreMaxAggregateInputType
  }

  export type IgnoreGroupByOutputType = {
    id: string
    agentId: string
    timestamp: Date
    duration: number
    gameId: string
    ignoredAgentId: string
    _count: IgnoreCountAggregateOutputType | null
    _avg: IgnoreAvgAggregateOutputType | null
    _sum: IgnoreSumAggregateOutputType | null
    _min: IgnoreMinAggregateOutputType | null
    _max: IgnoreMaxAggregateOutputType | null
  }

  type GetIgnoreGroupByPayload<T extends IgnoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IgnoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IgnoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IgnoreGroupByOutputType[P]>
            : GetScalarType<T[P], IgnoreGroupByOutputType[P]>
        }
      >
    >


  export type IgnoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    timestamp?: boolean
    duration?: boolean
    gameId?: boolean
    ignoredAgentId?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    ignoredAgent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ignore"]>

  export type IgnoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    timestamp?: boolean
    duration?: boolean
    gameId?: boolean
    ignoredAgentId?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    ignoredAgent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ignore"]>

  export type IgnoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    timestamp?: boolean
    duration?: boolean
    gameId?: boolean
    ignoredAgentId?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    ignoredAgent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ignore"]>

  export type IgnoreSelectScalar = {
    id?: boolean
    agentId?: boolean
    timestamp?: boolean
    duration?: boolean
    gameId?: boolean
    ignoredAgentId?: boolean
  }

  export type IgnoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "timestamp" | "duration" | "gameId" | "ignoredAgentId", ExtArgs["result"]["ignore"]>
  export type IgnoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    ignoredAgent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type IgnoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    ignoredAgent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type IgnoreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    ignoredAgent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $IgnorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ignore"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
      ignoredAgent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      timestamp: Date
      duration: number
      gameId: string
      ignoredAgentId: string
    }, ExtArgs["result"]["ignore"]>
    composites: {}
  }

  type IgnoreGetPayload<S extends boolean | null | undefined | IgnoreDefaultArgs> = $Result.GetResult<Prisma.$IgnorePayload, S>

  type IgnoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IgnoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IgnoreCountAggregateInputType | true
    }

  export interface IgnoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ignore'], meta: { name: 'Ignore' } }
    /**
     * Find zero or one Ignore that matches the filter.
     * @param {IgnoreFindUniqueArgs} args - Arguments to find a Ignore
     * @example
     * // Get one Ignore
     * const ignore = await prisma.ignore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IgnoreFindUniqueArgs>(args: SelectSubset<T, IgnoreFindUniqueArgs<ExtArgs>>): Prisma__IgnoreClient<$Result.GetResult<Prisma.$IgnorePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Ignore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IgnoreFindUniqueOrThrowArgs} args - Arguments to find a Ignore
     * @example
     * // Get one Ignore
     * const ignore = await prisma.ignore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IgnoreFindUniqueOrThrowArgs>(args: SelectSubset<T, IgnoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IgnoreClient<$Result.GetResult<Prisma.$IgnorePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Ignore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IgnoreFindFirstArgs} args - Arguments to find a Ignore
     * @example
     * // Get one Ignore
     * const ignore = await prisma.ignore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IgnoreFindFirstArgs>(args?: SelectSubset<T, IgnoreFindFirstArgs<ExtArgs>>): Prisma__IgnoreClient<$Result.GetResult<Prisma.$IgnorePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Ignore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IgnoreFindFirstOrThrowArgs} args - Arguments to find a Ignore
     * @example
     * // Get one Ignore
     * const ignore = await prisma.ignore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IgnoreFindFirstOrThrowArgs>(args?: SelectSubset<T, IgnoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__IgnoreClient<$Result.GetResult<Prisma.$IgnorePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Ignores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IgnoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ignores
     * const ignores = await prisma.ignore.findMany()
     * 
     * // Get first 10 Ignores
     * const ignores = await prisma.ignore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ignoreWithIdOnly = await prisma.ignore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IgnoreFindManyArgs>(args?: SelectSubset<T, IgnoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IgnorePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Ignore.
     * @param {IgnoreCreateArgs} args - Arguments to create a Ignore.
     * @example
     * // Create one Ignore
     * const Ignore = await prisma.ignore.create({
     *   data: {
     *     // ... data to create a Ignore
     *   }
     * })
     * 
     */
    create<T extends IgnoreCreateArgs>(args: SelectSubset<T, IgnoreCreateArgs<ExtArgs>>): Prisma__IgnoreClient<$Result.GetResult<Prisma.$IgnorePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Ignores.
     * @param {IgnoreCreateManyArgs} args - Arguments to create many Ignores.
     * @example
     * // Create many Ignores
     * const ignore = await prisma.ignore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IgnoreCreateManyArgs>(args?: SelectSubset<T, IgnoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ignores and returns the data saved in the database.
     * @param {IgnoreCreateManyAndReturnArgs} args - Arguments to create many Ignores.
     * @example
     * // Create many Ignores
     * const ignore = await prisma.ignore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ignores and only return the `id`
     * const ignoreWithIdOnly = await prisma.ignore.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IgnoreCreateManyAndReturnArgs>(args?: SelectSubset<T, IgnoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IgnorePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Ignore.
     * @param {IgnoreDeleteArgs} args - Arguments to delete one Ignore.
     * @example
     * // Delete one Ignore
     * const Ignore = await prisma.ignore.delete({
     *   where: {
     *     // ... filter to delete one Ignore
     *   }
     * })
     * 
     */
    delete<T extends IgnoreDeleteArgs>(args: SelectSubset<T, IgnoreDeleteArgs<ExtArgs>>): Prisma__IgnoreClient<$Result.GetResult<Prisma.$IgnorePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Ignore.
     * @param {IgnoreUpdateArgs} args - Arguments to update one Ignore.
     * @example
     * // Update one Ignore
     * const ignore = await prisma.ignore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IgnoreUpdateArgs>(args: SelectSubset<T, IgnoreUpdateArgs<ExtArgs>>): Prisma__IgnoreClient<$Result.GetResult<Prisma.$IgnorePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Ignores.
     * @param {IgnoreDeleteManyArgs} args - Arguments to filter Ignores to delete.
     * @example
     * // Delete a few Ignores
     * const { count } = await prisma.ignore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IgnoreDeleteManyArgs>(args?: SelectSubset<T, IgnoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ignores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IgnoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ignores
     * const ignore = await prisma.ignore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IgnoreUpdateManyArgs>(args: SelectSubset<T, IgnoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ignores and returns the data updated in the database.
     * @param {IgnoreUpdateManyAndReturnArgs} args - Arguments to update many Ignores.
     * @example
     * // Update many Ignores
     * const ignore = await prisma.ignore.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ignores and only return the `id`
     * const ignoreWithIdOnly = await prisma.ignore.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IgnoreUpdateManyAndReturnArgs>(args: SelectSubset<T, IgnoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IgnorePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Ignore.
     * @param {IgnoreUpsertArgs} args - Arguments to update or create a Ignore.
     * @example
     * // Update or create a Ignore
     * const ignore = await prisma.ignore.upsert({
     *   create: {
     *     // ... data to create a Ignore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ignore we want to update
     *   }
     * })
     */
    upsert<T extends IgnoreUpsertArgs>(args: SelectSubset<T, IgnoreUpsertArgs<ExtArgs>>): Prisma__IgnoreClient<$Result.GetResult<Prisma.$IgnorePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Ignores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IgnoreCountArgs} args - Arguments to filter Ignores to count.
     * @example
     * // Count the number of Ignores
     * const count = await prisma.ignore.count({
     *   where: {
     *     // ... the filter for the Ignores we want to count
     *   }
     * })
    **/
    count<T extends IgnoreCountArgs>(
      args?: Subset<T, IgnoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IgnoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ignore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IgnoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IgnoreAggregateArgs>(args: Subset<T, IgnoreAggregateArgs>): Prisma.PrismaPromise<GetIgnoreAggregateType<T>>

    /**
     * Group by Ignore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IgnoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IgnoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IgnoreGroupByArgs['orderBy'] }
        : { orderBy?: IgnoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IgnoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIgnoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ignore model
   */
  readonly fields: IgnoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ignore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IgnoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    ignoredAgent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ignore model
   */ 
  interface IgnoreFieldRefs {
    readonly id: FieldRef<"Ignore", 'String'>
    readonly agentId: FieldRef<"Ignore", 'String'>
    readonly timestamp: FieldRef<"Ignore", 'DateTime'>
    readonly duration: FieldRef<"Ignore", 'Int'>
    readonly gameId: FieldRef<"Ignore", 'String'>
    readonly ignoredAgentId: FieldRef<"Ignore", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ignore findUnique
   */
  export type IgnoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ignore
     */
    select?: IgnoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ignore
     */
    omit?: IgnoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IgnoreInclude<ExtArgs> | null
    /**
     * Filter, which Ignore to fetch.
     */
    where: IgnoreWhereUniqueInput
  }

  /**
   * Ignore findUniqueOrThrow
   */
  export type IgnoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ignore
     */
    select?: IgnoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ignore
     */
    omit?: IgnoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IgnoreInclude<ExtArgs> | null
    /**
     * Filter, which Ignore to fetch.
     */
    where: IgnoreWhereUniqueInput
  }

  /**
   * Ignore findFirst
   */
  export type IgnoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ignore
     */
    select?: IgnoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ignore
     */
    omit?: IgnoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IgnoreInclude<ExtArgs> | null
    /**
     * Filter, which Ignore to fetch.
     */
    where?: IgnoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ignores to fetch.
     */
    orderBy?: IgnoreOrderByWithRelationInput | IgnoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ignores.
     */
    cursor?: IgnoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ignores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ignores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ignores.
     */
    distinct?: IgnoreScalarFieldEnum | IgnoreScalarFieldEnum[]
  }

  /**
   * Ignore findFirstOrThrow
   */
  export type IgnoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ignore
     */
    select?: IgnoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ignore
     */
    omit?: IgnoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IgnoreInclude<ExtArgs> | null
    /**
     * Filter, which Ignore to fetch.
     */
    where?: IgnoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ignores to fetch.
     */
    orderBy?: IgnoreOrderByWithRelationInput | IgnoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ignores.
     */
    cursor?: IgnoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ignores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ignores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ignores.
     */
    distinct?: IgnoreScalarFieldEnum | IgnoreScalarFieldEnum[]
  }

  /**
   * Ignore findMany
   */
  export type IgnoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ignore
     */
    select?: IgnoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ignore
     */
    omit?: IgnoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IgnoreInclude<ExtArgs> | null
    /**
     * Filter, which Ignores to fetch.
     */
    where?: IgnoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ignores to fetch.
     */
    orderBy?: IgnoreOrderByWithRelationInput | IgnoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ignores.
     */
    cursor?: IgnoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ignores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ignores.
     */
    skip?: number
    distinct?: IgnoreScalarFieldEnum | IgnoreScalarFieldEnum[]
  }

  /**
   * Ignore create
   */
  export type IgnoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ignore
     */
    select?: IgnoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ignore
     */
    omit?: IgnoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IgnoreInclude<ExtArgs> | null
    /**
     * The data needed to create a Ignore.
     */
    data: XOR<IgnoreCreateInput, IgnoreUncheckedCreateInput>
  }

  /**
   * Ignore createMany
   */
  export type IgnoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ignores.
     */
    data: IgnoreCreateManyInput | IgnoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ignore createManyAndReturn
   */
  export type IgnoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ignore
     */
    select?: IgnoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ignore
     */
    omit?: IgnoreOmit<ExtArgs> | null
    /**
     * The data used to create many Ignores.
     */
    data: IgnoreCreateManyInput | IgnoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IgnoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ignore update
   */
  export type IgnoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ignore
     */
    select?: IgnoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ignore
     */
    omit?: IgnoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IgnoreInclude<ExtArgs> | null
    /**
     * The data needed to update a Ignore.
     */
    data: XOR<IgnoreUpdateInput, IgnoreUncheckedUpdateInput>
    /**
     * Choose, which Ignore to update.
     */
    where: IgnoreWhereUniqueInput
  }

  /**
   * Ignore updateMany
   */
  export type IgnoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ignores.
     */
    data: XOR<IgnoreUpdateManyMutationInput, IgnoreUncheckedUpdateManyInput>
    /**
     * Filter which Ignores to update
     */
    where?: IgnoreWhereInput
  }

  /**
   * Ignore updateManyAndReturn
   */
  export type IgnoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ignore
     */
    select?: IgnoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ignore
     */
    omit?: IgnoreOmit<ExtArgs> | null
    /**
     * The data used to update Ignores.
     */
    data: XOR<IgnoreUpdateManyMutationInput, IgnoreUncheckedUpdateManyInput>
    /**
     * Filter which Ignores to update
     */
    where?: IgnoreWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IgnoreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ignore upsert
   */
  export type IgnoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ignore
     */
    select?: IgnoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ignore
     */
    omit?: IgnoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IgnoreInclude<ExtArgs> | null
    /**
     * The filter to search for the Ignore to update in case it exists.
     */
    where: IgnoreWhereUniqueInput
    /**
     * In case the Ignore found by the `where` argument doesn't exist, create a new Ignore with this data.
     */
    create: XOR<IgnoreCreateInput, IgnoreUncheckedCreateInput>
    /**
     * In case the Ignore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IgnoreUpdateInput, IgnoreUncheckedUpdateInput>
  }

  /**
   * Ignore delete
   */
  export type IgnoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ignore
     */
    select?: IgnoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ignore
     */
    omit?: IgnoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IgnoreInclude<ExtArgs> | null
    /**
     * Filter which Ignore to delete.
     */
    where: IgnoreWhereUniqueInput
  }

  /**
   * Ignore deleteMany
   */
  export type IgnoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ignores to delete
     */
    where?: IgnoreWhereInput
  }

  /**
   * Ignore without action
   */
  export type IgnoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ignore
     */
    select?: IgnoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ignore
     */
    omit?: IgnoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IgnoreInclude<ExtArgs> | null
  }


  /**
   * Model MapTile
   */

  export type AggregateMapTile = {
    _count: MapTileCountAggregateOutputType | null
    _avg: MapTileAvgAggregateOutputType | null
    _sum: MapTileSumAggregateOutputType | null
    _min: MapTileMinAggregateOutputType | null
    _max: MapTileMaxAggregateOutputType | null
  }

  export type MapTileAvgAggregateOutputType = {
    x: number | null
    y: number | null
  }

  export type MapTileSumAggregateOutputType = {
    x: number | null
    y: number | null
  }

  export type MapTileMinAggregateOutputType = {
    id: string | null
    x: number | null
    y: number | null
    terrainType: $Enums.TerrainType | null
    agentId: string | null
  }

  export type MapTileMaxAggregateOutputType = {
    id: string | null
    x: number | null
    y: number | null
    terrainType: $Enums.TerrainType | null
    agentId: string | null
  }

  export type MapTileCountAggregateOutputType = {
    id: number
    x: number
    y: number
    terrainType: number
    agentId: number
    _all: number
  }


  export type MapTileAvgAggregateInputType = {
    x?: true
    y?: true
  }

  export type MapTileSumAggregateInputType = {
    x?: true
    y?: true
  }

  export type MapTileMinAggregateInputType = {
    id?: true
    x?: true
    y?: true
    terrainType?: true
    agentId?: true
  }

  export type MapTileMaxAggregateInputType = {
    id?: true
    x?: true
    y?: true
    terrainType?: true
    agentId?: true
  }

  export type MapTileCountAggregateInputType = {
    id?: true
    x?: true
    y?: true
    terrainType?: true
    agentId?: true
    _all?: true
  }

  export type MapTileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MapTile to aggregate.
     */
    where?: MapTileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapTiles to fetch.
     */
    orderBy?: MapTileOrderByWithRelationInput | MapTileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MapTileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapTiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapTiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MapTiles
    **/
    _count?: true | MapTileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapTileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapTileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapTileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapTileMaxAggregateInputType
  }

  export type GetMapTileAggregateType<T extends MapTileAggregateArgs> = {
        [P in keyof T & keyof AggregateMapTile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapTile[P]>
      : GetScalarType<T[P], AggregateMapTile[P]>
  }




  export type MapTileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapTileWhereInput
    orderBy?: MapTileOrderByWithAggregationInput | MapTileOrderByWithAggregationInput[]
    by: MapTileScalarFieldEnum[] | MapTileScalarFieldEnum
    having?: MapTileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapTileCountAggregateInputType | true
    _avg?: MapTileAvgAggregateInputType
    _sum?: MapTileSumAggregateInputType
    _min?: MapTileMinAggregateInputType
    _max?: MapTileMaxAggregateInputType
  }

  export type MapTileGroupByOutputType = {
    id: string
    x: number
    y: number
    terrainType: $Enums.TerrainType
    agentId: string | null
    _count: MapTileCountAggregateOutputType | null
    _avg: MapTileAvgAggregateOutputType | null
    _sum: MapTileSumAggregateOutputType | null
    _min: MapTileMinAggregateOutputType | null
    _max: MapTileMaxAggregateOutputType | null
  }

  type GetMapTileGroupByPayload<T extends MapTileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapTileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapTileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapTileGroupByOutputType[P]>
            : GetScalarType<T[P], MapTileGroupByOutputType[P]>
        }
      >
    >


  export type MapTileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    x?: boolean
    y?: boolean
    terrainType?: boolean
    agentId?: boolean
    agent?: boolean | MapTile$agentArgs<ExtArgs>
  }, ExtArgs["result"]["mapTile"]>

  export type MapTileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    x?: boolean
    y?: boolean
    terrainType?: boolean
    agentId?: boolean
  }, ExtArgs["result"]["mapTile"]>

  export type MapTileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    x?: boolean
    y?: boolean
    terrainType?: boolean
    agentId?: boolean
  }, ExtArgs["result"]["mapTile"]>

  export type MapTileSelectScalar = {
    id?: boolean
    x?: boolean
    y?: boolean
    terrainType?: boolean
    agentId?: boolean
  }

  export type MapTileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "x" | "y" | "terrainType" | "agentId", ExtArgs["result"]["mapTile"]>
  export type MapTileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | MapTile$agentArgs<ExtArgs>
  }
  export type MapTileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MapTileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MapTilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MapTile"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      x: number
      y: number
      terrainType: $Enums.TerrainType
      agentId: string | null
    }, ExtArgs["result"]["mapTile"]>
    composites: {}
  }

  type MapTileGetPayload<S extends boolean | null | undefined | MapTileDefaultArgs> = $Result.GetResult<Prisma.$MapTilePayload, S>

  type MapTileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MapTileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MapTileCountAggregateInputType | true
    }

  export interface MapTileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MapTile'], meta: { name: 'MapTile' } }
    /**
     * Find zero or one MapTile that matches the filter.
     * @param {MapTileFindUniqueArgs} args - Arguments to find a MapTile
     * @example
     * // Get one MapTile
     * const mapTile = await prisma.mapTile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MapTileFindUniqueArgs>(args: SelectSubset<T, MapTileFindUniqueArgs<ExtArgs>>): Prisma__MapTileClient<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one MapTile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MapTileFindUniqueOrThrowArgs} args - Arguments to find a MapTile
     * @example
     * // Get one MapTile
     * const mapTile = await prisma.mapTile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MapTileFindUniqueOrThrowArgs>(args: SelectSubset<T, MapTileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MapTileClient<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first MapTile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapTileFindFirstArgs} args - Arguments to find a MapTile
     * @example
     * // Get one MapTile
     * const mapTile = await prisma.mapTile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MapTileFindFirstArgs>(args?: SelectSubset<T, MapTileFindFirstArgs<ExtArgs>>): Prisma__MapTileClient<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first MapTile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapTileFindFirstOrThrowArgs} args - Arguments to find a MapTile
     * @example
     * // Get one MapTile
     * const mapTile = await prisma.mapTile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MapTileFindFirstOrThrowArgs>(args?: SelectSubset<T, MapTileFindFirstOrThrowArgs<ExtArgs>>): Prisma__MapTileClient<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more MapTiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapTileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapTiles
     * const mapTiles = await prisma.mapTile.findMany()
     * 
     * // Get first 10 MapTiles
     * const mapTiles = await prisma.mapTile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mapTileWithIdOnly = await prisma.mapTile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MapTileFindManyArgs>(args?: SelectSubset<T, MapTileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a MapTile.
     * @param {MapTileCreateArgs} args - Arguments to create a MapTile.
     * @example
     * // Create one MapTile
     * const MapTile = await prisma.mapTile.create({
     *   data: {
     *     // ... data to create a MapTile
     *   }
     * })
     * 
     */
    create<T extends MapTileCreateArgs>(args: SelectSubset<T, MapTileCreateArgs<ExtArgs>>): Prisma__MapTileClient<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many MapTiles.
     * @param {MapTileCreateManyArgs} args - Arguments to create many MapTiles.
     * @example
     * // Create many MapTiles
     * const mapTile = await prisma.mapTile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MapTileCreateManyArgs>(args?: SelectSubset<T, MapTileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MapTiles and returns the data saved in the database.
     * @param {MapTileCreateManyAndReturnArgs} args - Arguments to create many MapTiles.
     * @example
     * // Create many MapTiles
     * const mapTile = await prisma.mapTile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MapTiles and only return the `id`
     * const mapTileWithIdOnly = await prisma.mapTile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MapTileCreateManyAndReturnArgs>(args?: SelectSubset<T, MapTileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a MapTile.
     * @param {MapTileDeleteArgs} args - Arguments to delete one MapTile.
     * @example
     * // Delete one MapTile
     * const MapTile = await prisma.mapTile.delete({
     *   where: {
     *     // ... filter to delete one MapTile
     *   }
     * })
     * 
     */
    delete<T extends MapTileDeleteArgs>(args: SelectSubset<T, MapTileDeleteArgs<ExtArgs>>): Prisma__MapTileClient<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one MapTile.
     * @param {MapTileUpdateArgs} args - Arguments to update one MapTile.
     * @example
     * // Update one MapTile
     * const mapTile = await prisma.mapTile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MapTileUpdateArgs>(args: SelectSubset<T, MapTileUpdateArgs<ExtArgs>>): Prisma__MapTileClient<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more MapTiles.
     * @param {MapTileDeleteManyArgs} args - Arguments to filter MapTiles to delete.
     * @example
     * // Delete a few MapTiles
     * const { count } = await prisma.mapTile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MapTileDeleteManyArgs>(args?: SelectSubset<T, MapTileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapTiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapTileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapTiles
     * const mapTile = await prisma.mapTile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MapTileUpdateManyArgs>(args: SelectSubset<T, MapTileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapTiles and returns the data updated in the database.
     * @param {MapTileUpdateManyAndReturnArgs} args - Arguments to update many MapTiles.
     * @example
     * // Update many MapTiles
     * const mapTile = await prisma.mapTile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MapTiles and only return the `id`
     * const mapTileWithIdOnly = await prisma.mapTile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MapTileUpdateManyAndReturnArgs>(args: SelectSubset<T, MapTileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one MapTile.
     * @param {MapTileUpsertArgs} args - Arguments to update or create a MapTile.
     * @example
     * // Update or create a MapTile
     * const mapTile = await prisma.mapTile.upsert({
     *   create: {
     *     // ... data to create a MapTile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapTile we want to update
     *   }
     * })
     */
    upsert<T extends MapTileUpsertArgs>(args: SelectSubset<T, MapTileUpsertArgs<ExtArgs>>): Prisma__MapTileClient<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of MapTiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapTileCountArgs} args - Arguments to filter MapTiles to count.
     * @example
     * // Count the number of MapTiles
     * const count = await prisma.mapTile.count({
     *   where: {
     *     // ... the filter for the MapTiles we want to count
     *   }
     * })
    **/
    count<T extends MapTileCountArgs>(
      args?: Subset<T, MapTileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapTileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapTile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapTileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapTileAggregateArgs>(args: Subset<T, MapTileAggregateArgs>): Prisma.PrismaPromise<GetMapTileAggregateType<T>>

    /**
     * Group by MapTile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapTileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapTileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapTileGroupByArgs['orderBy'] }
        : { orderBy?: MapTileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapTileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapTileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MapTile model
   */
  readonly fields: MapTileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MapTile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MapTileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends MapTile$agentArgs<ExtArgs> = {}>(args?: Subset<T, MapTile$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MapTile model
   */ 
  interface MapTileFieldRefs {
    readonly id: FieldRef<"MapTile", 'String'>
    readonly x: FieldRef<"MapTile", 'Int'>
    readonly y: FieldRef<"MapTile", 'Int'>
    readonly terrainType: FieldRef<"MapTile", 'TerrainType'>
    readonly agentId: FieldRef<"MapTile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MapTile findUnique
   */
  export type MapTileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    /**
     * Filter, which MapTile to fetch.
     */
    where: MapTileWhereUniqueInput
  }

  /**
   * MapTile findUniqueOrThrow
   */
  export type MapTileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    /**
     * Filter, which MapTile to fetch.
     */
    where: MapTileWhereUniqueInput
  }

  /**
   * MapTile findFirst
   */
  export type MapTileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    /**
     * Filter, which MapTile to fetch.
     */
    where?: MapTileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapTiles to fetch.
     */
    orderBy?: MapTileOrderByWithRelationInput | MapTileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MapTiles.
     */
    cursor?: MapTileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapTiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapTiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MapTiles.
     */
    distinct?: MapTileScalarFieldEnum | MapTileScalarFieldEnum[]
  }

  /**
   * MapTile findFirstOrThrow
   */
  export type MapTileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    /**
     * Filter, which MapTile to fetch.
     */
    where?: MapTileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapTiles to fetch.
     */
    orderBy?: MapTileOrderByWithRelationInput | MapTileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MapTiles.
     */
    cursor?: MapTileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapTiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapTiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MapTiles.
     */
    distinct?: MapTileScalarFieldEnum | MapTileScalarFieldEnum[]
  }

  /**
   * MapTile findMany
   */
  export type MapTileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    /**
     * Filter, which MapTiles to fetch.
     */
    where?: MapTileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapTiles to fetch.
     */
    orderBy?: MapTileOrderByWithRelationInput | MapTileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MapTiles.
     */
    cursor?: MapTileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapTiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapTiles.
     */
    skip?: number
    distinct?: MapTileScalarFieldEnum | MapTileScalarFieldEnum[]
  }

  /**
   * MapTile create
   */
  export type MapTileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    /**
     * The data needed to create a MapTile.
     */
    data: XOR<MapTileCreateInput, MapTileUncheckedCreateInput>
  }

  /**
   * MapTile createMany
   */
  export type MapTileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MapTiles.
     */
    data: MapTileCreateManyInput | MapTileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MapTile createManyAndReturn
   */
  export type MapTileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * The data used to create many MapTiles.
     */
    data: MapTileCreateManyInput | MapTileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MapTile update
   */
  export type MapTileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    /**
     * The data needed to update a MapTile.
     */
    data: XOR<MapTileUpdateInput, MapTileUncheckedUpdateInput>
    /**
     * Choose, which MapTile to update.
     */
    where: MapTileWhereUniqueInput
  }

  /**
   * MapTile updateMany
   */
  export type MapTileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MapTiles.
     */
    data: XOR<MapTileUpdateManyMutationInput, MapTileUncheckedUpdateManyInput>
    /**
     * Filter which MapTiles to update
     */
    where?: MapTileWhereInput
  }

  /**
   * MapTile updateManyAndReturn
   */
  export type MapTileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * The data used to update MapTiles.
     */
    data: XOR<MapTileUpdateManyMutationInput, MapTileUncheckedUpdateManyInput>
    /**
     * Filter which MapTiles to update
     */
    where?: MapTileWhereInput
  }

  /**
   * MapTile upsert
   */
  export type MapTileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    /**
     * The filter to search for the MapTile to update in case it exists.
     */
    where: MapTileWhereUniqueInput
    /**
     * In case the MapTile found by the `where` argument doesn't exist, create a new MapTile with this data.
     */
    create: XOR<MapTileCreateInput, MapTileUncheckedCreateInput>
    /**
     * In case the MapTile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MapTileUpdateInput, MapTileUncheckedUpdateInput>
  }

  /**
   * MapTile delete
   */
  export type MapTileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    /**
     * Filter which MapTile to delete.
     */
    where: MapTileWhereUniqueInput
  }

  /**
   * MapTile deleteMany
   */
  export type MapTileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MapTiles to delete
     */
    where?: MapTileWhereInput
  }

  /**
   * MapTile.agent
   */
  export type MapTile$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * MapTile without action
   */
  export type MapTileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
  }


  /**
   * Model Tweet
   */

  export type AggregateTweet = {
    _count: TweetCountAggregateOutputType | null
    _min: TweetMinAggregateOutputType | null
    _max: TweetMaxAggregateOutputType | null
  }

  export type TweetMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    content: string | null
    type: string | null
    timestamp: Date | null
    conversationId: string | null
  }

  export type TweetMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    content: string | null
    type: string | null
    timestamp: Date | null
    conversationId: string | null
  }

  export type TweetCountAggregateOutputType = {
    id: number
    agentId: number
    content: number
    type: number
    timestamp: number
    conversationId: number
    _all: number
  }


  export type TweetMinAggregateInputType = {
    id?: true
    agentId?: true
    content?: true
    type?: true
    timestamp?: true
    conversationId?: true
  }

  export type TweetMaxAggregateInputType = {
    id?: true
    agentId?: true
    content?: true
    type?: true
    timestamp?: true
    conversationId?: true
  }

  export type TweetCountAggregateInputType = {
    id?: true
    agentId?: true
    content?: true
    type?: true
    timestamp?: true
    conversationId?: true
    _all?: true
  }

  export type TweetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tweet to aggregate.
     */
    where?: TweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tweets to fetch.
     */
    orderBy?: TweetOrderByWithRelationInput | TweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tweets
    **/
    _count?: true | TweetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TweetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TweetMaxAggregateInputType
  }

  export type GetTweetAggregateType<T extends TweetAggregateArgs> = {
        [P in keyof T & keyof AggregateTweet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTweet[P]>
      : GetScalarType<T[P], AggregateTweet[P]>
  }




  export type TweetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TweetWhereInput
    orderBy?: TweetOrderByWithAggregationInput | TweetOrderByWithAggregationInput[]
    by: TweetScalarFieldEnum[] | TweetScalarFieldEnum
    having?: TweetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TweetCountAggregateInputType | true
    _min?: TweetMinAggregateInputType
    _max?: TweetMaxAggregateInputType
  }

  export type TweetGroupByOutputType = {
    id: string
    agentId: string
    content: string
    type: string
    timestamp: Date
    conversationId: string | null
    _count: TweetCountAggregateOutputType | null
    _min: TweetMinAggregateOutputType | null
    _max: TweetMaxAggregateOutputType | null
  }

  type GetTweetGroupByPayload<T extends TweetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TweetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TweetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TweetGroupByOutputType[P]>
            : GetScalarType<T[P], TweetGroupByOutputType[P]>
        }
      >
    >


  export type TweetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    content?: boolean
    type?: boolean
    timestamp?: boolean
    conversationId?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    interactions?: boolean | Tweet$interactionsArgs<ExtArgs>
    _count?: boolean | TweetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweet"]>

  export type TweetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    content?: boolean
    type?: boolean
    timestamp?: boolean
    conversationId?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweet"]>

  export type TweetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    content?: boolean
    type?: boolean
    timestamp?: boolean
    conversationId?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweet"]>

  export type TweetSelectScalar = {
    id?: boolean
    agentId?: boolean
    content?: boolean
    type?: boolean
    timestamp?: boolean
    conversationId?: boolean
  }

  export type TweetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "content" | "type" | "timestamp" | "conversationId", ExtArgs["result"]["tweet"]>
  export type TweetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    interactions?: boolean | Tweet$interactionsArgs<ExtArgs>
    _count?: boolean | TweetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TweetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type TweetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $TweetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tweet"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
      interactions: Prisma.$InteractionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      content: string
      type: string
      timestamp: Date
      conversationId: string | null
    }, ExtArgs["result"]["tweet"]>
    composites: {}
  }

  type TweetGetPayload<S extends boolean | null | undefined | TweetDefaultArgs> = $Result.GetResult<Prisma.$TweetPayload, S>

  type TweetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TweetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TweetCountAggregateInputType | true
    }

  export interface TweetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tweet'], meta: { name: 'Tweet' } }
    /**
     * Find zero or one Tweet that matches the filter.
     * @param {TweetFindUniqueArgs} args - Arguments to find a Tweet
     * @example
     * // Get one Tweet
     * const tweet = await prisma.tweet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TweetFindUniqueArgs>(args: SelectSubset<T, TweetFindUniqueArgs<ExtArgs>>): Prisma__TweetClient<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Tweet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TweetFindUniqueOrThrowArgs} args - Arguments to find a Tweet
     * @example
     * // Get one Tweet
     * const tweet = await prisma.tweet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TweetFindUniqueOrThrowArgs>(args: SelectSubset<T, TweetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TweetClient<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Tweet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetFindFirstArgs} args - Arguments to find a Tweet
     * @example
     * // Get one Tweet
     * const tweet = await prisma.tweet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TweetFindFirstArgs>(args?: SelectSubset<T, TweetFindFirstArgs<ExtArgs>>): Prisma__TweetClient<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Tweet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetFindFirstOrThrowArgs} args - Arguments to find a Tweet
     * @example
     * // Get one Tweet
     * const tweet = await prisma.tweet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TweetFindFirstOrThrowArgs>(args?: SelectSubset<T, TweetFindFirstOrThrowArgs<ExtArgs>>): Prisma__TweetClient<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Tweets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tweets
     * const tweets = await prisma.tweet.findMany()
     * 
     * // Get first 10 Tweets
     * const tweets = await prisma.tweet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tweetWithIdOnly = await prisma.tweet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TweetFindManyArgs>(args?: SelectSubset<T, TweetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Tweet.
     * @param {TweetCreateArgs} args - Arguments to create a Tweet.
     * @example
     * // Create one Tweet
     * const Tweet = await prisma.tweet.create({
     *   data: {
     *     // ... data to create a Tweet
     *   }
     * })
     * 
     */
    create<T extends TweetCreateArgs>(args: SelectSubset<T, TweetCreateArgs<ExtArgs>>): Prisma__TweetClient<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Tweets.
     * @param {TweetCreateManyArgs} args - Arguments to create many Tweets.
     * @example
     * // Create many Tweets
     * const tweet = await prisma.tweet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TweetCreateManyArgs>(args?: SelectSubset<T, TweetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tweets and returns the data saved in the database.
     * @param {TweetCreateManyAndReturnArgs} args - Arguments to create many Tweets.
     * @example
     * // Create many Tweets
     * const tweet = await prisma.tweet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tweets and only return the `id`
     * const tweetWithIdOnly = await prisma.tweet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TweetCreateManyAndReturnArgs>(args?: SelectSubset<T, TweetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Tweet.
     * @param {TweetDeleteArgs} args - Arguments to delete one Tweet.
     * @example
     * // Delete one Tweet
     * const Tweet = await prisma.tweet.delete({
     *   where: {
     *     // ... filter to delete one Tweet
     *   }
     * })
     * 
     */
    delete<T extends TweetDeleteArgs>(args: SelectSubset<T, TweetDeleteArgs<ExtArgs>>): Prisma__TweetClient<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Tweet.
     * @param {TweetUpdateArgs} args - Arguments to update one Tweet.
     * @example
     * // Update one Tweet
     * const tweet = await prisma.tweet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TweetUpdateArgs>(args: SelectSubset<T, TweetUpdateArgs<ExtArgs>>): Prisma__TweetClient<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Tweets.
     * @param {TweetDeleteManyArgs} args - Arguments to filter Tweets to delete.
     * @example
     * // Delete a few Tweets
     * const { count } = await prisma.tweet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TweetDeleteManyArgs>(args?: SelectSubset<T, TweetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tweets
     * const tweet = await prisma.tweet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TweetUpdateManyArgs>(args: SelectSubset<T, TweetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tweets and returns the data updated in the database.
     * @param {TweetUpdateManyAndReturnArgs} args - Arguments to update many Tweets.
     * @example
     * // Update many Tweets
     * const tweet = await prisma.tweet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tweets and only return the `id`
     * const tweetWithIdOnly = await prisma.tweet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TweetUpdateManyAndReturnArgs>(args: SelectSubset<T, TweetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Tweet.
     * @param {TweetUpsertArgs} args - Arguments to update or create a Tweet.
     * @example
     * // Update or create a Tweet
     * const tweet = await prisma.tweet.upsert({
     *   create: {
     *     // ... data to create a Tweet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tweet we want to update
     *   }
     * })
     */
    upsert<T extends TweetUpsertArgs>(args: SelectSubset<T, TweetUpsertArgs<ExtArgs>>): Prisma__TweetClient<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Tweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetCountArgs} args - Arguments to filter Tweets to count.
     * @example
     * // Count the number of Tweets
     * const count = await prisma.tweet.count({
     *   where: {
     *     // ... the filter for the Tweets we want to count
     *   }
     * })
    **/
    count<T extends TweetCountArgs>(
      args?: Subset<T, TweetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TweetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TweetAggregateArgs>(args: Subset<T, TweetAggregateArgs>): Prisma.PrismaPromise<GetTweetAggregateType<T>>

    /**
     * Group by Tweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TweetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TweetGroupByArgs['orderBy'] }
        : { orderBy?: TweetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TweetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTweetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tweet model
   */
  readonly fields: TweetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tweet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TweetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    interactions<T extends Tweet$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, Tweet$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tweet model
   */ 
  interface TweetFieldRefs {
    readonly id: FieldRef<"Tweet", 'String'>
    readonly agentId: FieldRef<"Tweet", 'String'>
    readonly content: FieldRef<"Tweet", 'String'>
    readonly type: FieldRef<"Tweet", 'String'>
    readonly timestamp: FieldRef<"Tweet", 'DateTime'>
    readonly conversationId: FieldRef<"Tweet", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tweet findUnique
   */
  export type TweetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    /**
     * Filter, which Tweet to fetch.
     */
    where: TweetWhereUniqueInput
  }

  /**
   * Tweet findUniqueOrThrow
   */
  export type TweetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    /**
     * Filter, which Tweet to fetch.
     */
    where: TweetWhereUniqueInput
  }

  /**
   * Tweet findFirst
   */
  export type TweetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    /**
     * Filter, which Tweet to fetch.
     */
    where?: TweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tweets to fetch.
     */
    orderBy?: TweetOrderByWithRelationInput | TweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tweets.
     */
    cursor?: TweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tweets.
     */
    distinct?: TweetScalarFieldEnum | TweetScalarFieldEnum[]
  }

  /**
   * Tweet findFirstOrThrow
   */
  export type TweetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    /**
     * Filter, which Tweet to fetch.
     */
    where?: TweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tweets to fetch.
     */
    orderBy?: TweetOrderByWithRelationInput | TweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tweets.
     */
    cursor?: TweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tweets.
     */
    distinct?: TweetScalarFieldEnum | TweetScalarFieldEnum[]
  }

  /**
   * Tweet findMany
   */
  export type TweetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    /**
     * Filter, which Tweets to fetch.
     */
    where?: TweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tweets to fetch.
     */
    orderBy?: TweetOrderByWithRelationInput | TweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tweets.
     */
    cursor?: TweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tweets.
     */
    skip?: number
    distinct?: TweetScalarFieldEnum | TweetScalarFieldEnum[]
  }

  /**
   * Tweet create
   */
  export type TweetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    /**
     * The data needed to create a Tweet.
     */
    data: XOR<TweetCreateInput, TweetUncheckedCreateInput>
  }

  /**
   * Tweet createMany
   */
  export type TweetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tweets.
     */
    data: TweetCreateManyInput | TweetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tweet createManyAndReturn
   */
  export type TweetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * The data used to create many Tweets.
     */
    data: TweetCreateManyInput | TweetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tweet update
   */
  export type TweetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    /**
     * The data needed to update a Tweet.
     */
    data: XOR<TweetUpdateInput, TweetUncheckedUpdateInput>
    /**
     * Choose, which Tweet to update.
     */
    where: TweetWhereUniqueInput
  }

  /**
   * Tweet updateMany
   */
  export type TweetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tweets.
     */
    data: XOR<TweetUpdateManyMutationInput, TweetUncheckedUpdateManyInput>
    /**
     * Filter which Tweets to update
     */
    where?: TweetWhereInput
  }

  /**
   * Tweet updateManyAndReturn
   */
  export type TweetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * The data used to update Tweets.
     */
    data: XOR<TweetUpdateManyMutationInput, TweetUncheckedUpdateManyInput>
    /**
     * Filter which Tweets to update
     */
    where?: TweetWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tweet upsert
   */
  export type TweetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    /**
     * The filter to search for the Tweet to update in case it exists.
     */
    where: TweetWhereUniqueInput
    /**
     * In case the Tweet found by the `where` argument doesn't exist, create a new Tweet with this data.
     */
    create: XOR<TweetCreateInput, TweetUncheckedCreateInput>
    /**
     * In case the Tweet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TweetUpdateInput, TweetUncheckedUpdateInput>
  }

  /**
   * Tweet delete
   */
  export type TweetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    /**
     * Filter which Tweet to delete.
     */
    where: TweetWhereUniqueInput
  }

  /**
   * Tweet deleteMany
   */
  export type TweetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tweets to delete
     */
    where?: TweetWhereInput
  }

  /**
   * Tweet.interactions
   */
  export type Tweet$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    where?: InteractionWhereInput
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    cursor?: InteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Tweet without action
   */
  export type TweetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
  }


  /**
   * Model Alliance
   */

  export type AggregateAlliance = {
    _count: AllianceCountAggregateOutputType | null
    _avg: AllianceAvgAggregateOutputType | null
    _sum: AllianceSumAggregateOutputType | null
    _min: AllianceMinAggregateOutputType | null
    _max: AllianceMaxAggregateOutputType | null
  }

  export type AllianceAvgAggregateOutputType = {
    combinedTokens: number | null
  }

  export type AllianceSumAggregateOutputType = {
    combinedTokens: bigint | null
  }

  export type AllianceMinAggregateOutputType = {
    id: string | null
    combinedTokens: bigint | null
    status: $Enums.AllianceStatus | null
    timestamp: Date | null
    gameId: string | null
    initiatorId: string | null
    joinerId: string | null
    endedAt: Date | null
  }

  export type AllianceMaxAggregateOutputType = {
    id: string | null
    combinedTokens: bigint | null
    status: $Enums.AllianceStatus | null
    timestamp: Date | null
    gameId: string | null
    initiatorId: string | null
    joinerId: string | null
    endedAt: Date | null
  }

  export type AllianceCountAggregateOutputType = {
    id: number
    combinedTokens: number
    status: number
    timestamp: number
    gameId: number
    initiatorId: number
    joinerId: number
    endedAt: number
    _all: number
  }


  export type AllianceAvgAggregateInputType = {
    combinedTokens?: true
  }

  export type AllianceSumAggregateInputType = {
    combinedTokens?: true
  }

  export type AllianceMinAggregateInputType = {
    id?: true
    combinedTokens?: true
    status?: true
    timestamp?: true
    gameId?: true
    initiatorId?: true
    joinerId?: true
    endedAt?: true
  }

  export type AllianceMaxAggregateInputType = {
    id?: true
    combinedTokens?: true
    status?: true
    timestamp?: true
    gameId?: true
    initiatorId?: true
    joinerId?: true
    endedAt?: true
  }

  export type AllianceCountAggregateInputType = {
    id?: true
    combinedTokens?: true
    status?: true
    timestamp?: true
    gameId?: true
    initiatorId?: true
    joinerId?: true
    endedAt?: true
    _all?: true
  }

  export type AllianceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alliance to aggregate.
     */
    where?: AllianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alliances to fetch.
     */
    orderBy?: AllianceOrderByWithRelationInput | AllianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AllianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alliances
    **/
    _count?: true | AllianceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AllianceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AllianceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AllianceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AllianceMaxAggregateInputType
  }

  export type GetAllianceAggregateType<T extends AllianceAggregateArgs> = {
        [P in keyof T & keyof AggregateAlliance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlliance[P]>
      : GetScalarType<T[P], AggregateAlliance[P]>
  }




  export type AllianceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllianceWhereInput
    orderBy?: AllianceOrderByWithAggregationInput | AllianceOrderByWithAggregationInput[]
    by: AllianceScalarFieldEnum[] | AllianceScalarFieldEnum
    having?: AllianceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AllianceCountAggregateInputType | true
    _avg?: AllianceAvgAggregateInputType
    _sum?: AllianceSumAggregateInputType
    _min?: AllianceMinAggregateInputType
    _max?: AllianceMaxAggregateInputType
  }

  export type AllianceGroupByOutputType = {
    id: string
    combinedTokens: bigint | null
    status: $Enums.AllianceStatus
    timestamp: Date
    gameId: string
    initiatorId: string
    joinerId: string
    endedAt: Date | null
    _count: AllianceCountAggregateOutputType | null
    _avg: AllianceAvgAggregateOutputType | null
    _sum: AllianceSumAggregateOutputType | null
    _min: AllianceMinAggregateOutputType | null
    _max: AllianceMaxAggregateOutputType | null
  }

  type GetAllianceGroupByPayload<T extends AllianceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AllianceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AllianceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AllianceGroupByOutputType[P]>
            : GetScalarType<T[P], AllianceGroupByOutputType[P]>
        }
      >
    >


  export type AllianceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    combinedTokens?: boolean
    status?: boolean
    timestamp?: boolean
    gameId?: boolean
    initiatorId?: boolean
    joinerId?: boolean
    endedAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    initiator?: boolean | AgentDefaultArgs<ExtArgs>
    joiner?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alliance"]>

  export type AllianceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    combinedTokens?: boolean
    status?: boolean
    timestamp?: boolean
    gameId?: boolean
    initiatorId?: boolean
    joinerId?: boolean
    endedAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    initiator?: boolean | AgentDefaultArgs<ExtArgs>
    joiner?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alliance"]>

  export type AllianceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    combinedTokens?: boolean
    status?: boolean
    timestamp?: boolean
    gameId?: boolean
    initiatorId?: boolean
    joinerId?: boolean
    endedAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    initiator?: boolean | AgentDefaultArgs<ExtArgs>
    joiner?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alliance"]>

  export type AllianceSelectScalar = {
    id?: boolean
    combinedTokens?: boolean
    status?: boolean
    timestamp?: boolean
    gameId?: boolean
    initiatorId?: boolean
    joinerId?: boolean
    endedAt?: boolean
  }

  export type AllianceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "combinedTokens" | "status" | "timestamp" | "gameId" | "initiatorId" | "joinerId" | "endedAt", ExtArgs["result"]["alliance"]>
  export type AllianceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    initiator?: boolean | AgentDefaultArgs<ExtArgs>
    joiner?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AllianceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    initiator?: boolean | AgentDefaultArgs<ExtArgs>
    joiner?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AllianceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    initiator?: boolean | AgentDefaultArgs<ExtArgs>
    joiner?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $AlliancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alliance"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
      initiator: Prisma.$AgentPayload<ExtArgs>
      joiner: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      combinedTokens: bigint | null
      status: $Enums.AllianceStatus
      timestamp: Date
      gameId: string
      initiatorId: string
      joinerId: string
      endedAt: Date | null
    }, ExtArgs["result"]["alliance"]>
    composites: {}
  }

  type AllianceGetPayload<S extends boolean | null | undefined | AllianceDefaultArgs> = $Result.GetResult<Prisma.$AlliancePayload, S>

  type AllianceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AllianceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AllianceCountAggregateInputType | true
    }

  export interface AllianceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alliance'], meta: { name: 'Alliance' } }
    /**
     * Find zero or one Alliance that matches the filter.
     * @param {AllianceFindUniqueArgs} args - Arguments to find a Alliance
     * @example
     * // Get one Alliance
     * const alliance = await prisma.alliance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AllianceFindUniqueArgs>(args: SelectSubset<T, AllianceFindUniqueArgs<ExtArgs>>): Prisma__AllianceClient<$Result.GetResult<Prisma.$AlliancePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Alliance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AllianceFindUniqueOrThrowArgs} args - Arguments to find a Alliance
     * @example
     * // Get one Alliance
     * const alliance = await prisma.alliance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AllianceFindUniqueOrThrowArgs>(args: SelectSubset<T, AllianceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AllianceClient<$Result.GetResult<Prisma.$AlliancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Alliance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllianceFindFirstArgs} args - Arguments to find a Alliance
     * @example
     * // Get one Alliance
     * const alliance = await prisma.alliance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AllianceFindFirstArgs>(args?: SelectSubset<T, AllianceFindFirstArgs<ExtArgs>>): Prisma__AllianceClient<$Result.GetResult<Prisma.$AlliancePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Alliance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllianceFindFirstOrThrowArgs} args - Arguments to find a Alliance
     * @example
     * // Get one Alliance
     * const alliance = await prisma.alliance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AllianceFindFirstOrThrowArgs>(args?: SelectSubset<T, AllianceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AllianceClient<$Result.GetResult<Prisma.$AlliancePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Alliances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllianceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alliances
     * const alliances = await prisma.alliance.findMany()
     * 
     * // Get first 10 Alliances
     * const alliances = await prisma.alliance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const allianceWithIdOnly = await prisma.alliance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AllianceFindManyArgs>(args?: SelectSubset<T, AllianceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlliancePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Alliance.
     * @param {AllianceCreateArgs} args - Arguments to create a Alliance.
     * @example
     * // Create one Alliance
     * const Alliance = await prisma.alliance.create({
     *   data: {
     *     // ... data to create a Alliance
     *   }
     * })
     * 
     */
    create<T extends AllianceCreateArgs>(args: SelectSubset<T, AllianceCreateArgs<ExtArgs>>): Prisma__AllianceClient<$Result.GetResult<Prisma.$AlliancePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Alliances.
     * @param {AllianceCreateManyArgs} args - Arguments to create many Alliances.
     * @example
     * // Create many Alliances
     * const alliance = await prisma.alliance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AllianceCreateManyArgs>(args?: SelectSubset<T, AllianceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alliances and returns the data saved in the database.
     * @param {AllianceCreateManyAndReturnArgs} args - Arguments to create many Alliances.
     * @example
     * // Create many Alliances
     * const alliance = await prisma.alliance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alliances and only return the `id`
     * const allianceWithIdOnly = await prisma.alliance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AllianceCreateManyAndReturnArgs>(args?: SelectSubset<T, AllianceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlliancePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Alliance.
     * @param {AllianceDeleteArgs} args - Arguments to delete one Alliance.
     * @example
     * // Delete one Alliance
     * const Alliance = await prisma.alliance.delete({
     *   where: {
     *     // ... filter to delete one Alliance
     *   }
     * })
     * 
     */
    delete<T extends AllianceDeleteArgs>(args: SelectSubset<T, AllianceDeleteArgs<ExtArgs>>): Prisma__AllianceClient<$Result.GetResult<Prisma.$AlliancePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Alliance.
     * @param {AllianceUpdateArgs} args - Arguments to update one Alliance.
     * @example
     * // Update one Alliance
     * const alliance = await prisma.alliance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AllianceUpdateArgs>(args: SelectSubset<T, AllianceUpdateArgs<ExtArgs>>): Prisma__AllianceClient<$Result.GetResult<Prisma.$AlliancePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Alliances.
     * @param {AllianceDeleteManyArgs} args - Arguments to filter Alliances to delete.
     * @example
     * // Delete a few Alliances
     * const { count } = await prisma.alliance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AllianceDeleteManyArgs>(args?: SelectSubset<T, AllianceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alliances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllianceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alliances
     * const alliance = await prisma.alliance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AllianceUpdateManyArgs>(args: SelectSubset<T, AllianceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alliances and returns the data updated in the database.
     * @param {AllianceUpdateManyAndReturnArgs} args - Arguments to update many Alliances.
     * @example
     * // Update many Alliances
     * const alliance = await prisma.alliance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Alliances and only return the `id`
     * const allianceWithIdOnly = await prisma.alliance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AllianceUpdateManyAndReturnArgs>(args: SelectSubset<T, AllianceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlliancePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Alliance.
     * @param {AllianceUpsertArgs} args - Arguments to update or create a Alliance.
     * @example
     * // Update or create a Alliance
     * const alliance = await prisma.alliance.upsert({
     *   create: {
     *     // ... data to create a Alliance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alliance we want to update
     *   }
     * })
     */
    upsert<T extends AllianceUpsertArgs>(args: SelectSubset<T, AllianceUpsertArgs<ExtArgs>>): Prisma__AllianceClient<$Result.GetResult<Prisma.$AlliancePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Alliances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllianceCountArgs} args - Arguments to filter Alliances to count.
     * @example
     * // Count the number of Alliances
     * const count = await prisma.alliance.count({
     *   where: {
     *     // ... the filter for the Alliances we want to count
     *   }
     * })
    **/
    count<T extends AllianceCountArgs>(
      args?: Subset<T, AllianceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AllianceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alliance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllianceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AllianceAggregateArgs>(args: Subset<T, AllianceAggregateArgs>): Prisma.PrismaPromise<GetAllianceAggregateType<T>>

    /**
     * Group by Alliance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllianceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AllianceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AllianceGroupByArgs['orderBy'] }
        : { orderBy?: AllianceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AllianceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAllianceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alliance model
   */
  readonly fields: AllianceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alliance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AllianceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    initiator<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    joiner<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alliance model
   */ 
  interface AllianceFieldRefs {
    readonly id: FieldRef<"Alliance", 'String'>
    readonly combinedTokens: FieldRef<"Alliance", 'BigInt'>
    readonly status: FieldRef<"Alliance", 'AllianceStatus'>
    readonly timestamp: FieldRef<"Alliance", 'DateTime'>
    readonly gameId: FieldRef<"Alliance", 'String'>
    readonly initiatorId: FieldRef<"Alliance", 'String'>
    readonly joinerId: FieldRef<"Alliance", 'String'>
    readonly endedAt: FieldRef<"Alliance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Alliance findUnique
   */
  export type AllianceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alliance
     */
    select?: AllianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alliance
     */
    omit?: AllianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllianceInclude<ExtArgs> | null
    /**
     * Filter, which Alliance to fetch.
     */
    where: AllianceWhereUniqueInput
  }

  /**
   * Alliance findUniqueOrThrow
   */
  export type AllianceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alliance
     */
    select?: AllianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alliance
     */
    omit?: AllianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllianceInclude<ExtArgs> | null
    /**
     * Filter, which Alliance to fetch.
     */
    where: AllianceWhereUniqueInput
  }

  /**
   * Alliance findFirst
   */
  export type AllianceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alliance
     */
    select?: AllianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alliance
     */
    omit?: AllianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllianceInclude<ExtArgs> | null
    /**
     * Filter, which Alliance to fetch.
     */
    where?: AllianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alliances to fetch.
     */
    orderBy?: AllianceOrderByWithRelationInput | AllianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alliances.
     */
    cursor?: AllianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alliances.
     */
    distinct?: AllianceScalarFieldEnum | AllianceScalarFieldEnum[]
  }

  /**
   * Alliance findFirstOrThrow
   */
  export type AllianceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alliance
     */
    select?: AllianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alliance
     */
    omit?: AllianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllianceInclude<ExtArgs> | null
    /**
     * Filter, which Alliance to fetch.
     */
    where?: AllianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alliances to fetch.
     */
    orderBy?: AllianceOrderByWithRelationInput | AllianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alliances.
     */
    cursor?: AllianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alliances.
     */
    distinct?: AllianceScalarFieldEnum | AllianceScalarFieldEnum[]
  }

  /**
   * Alliance findMany
   */
  export type AllianceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alliance
     */
    select?: AllianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alliance
     */
    omit?: AllianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllianceInclude<ExtArgs> | null
    /**
     * Filter, which Alliances to fetch.
     */
    where?: AllianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alliances to fetch.
     */
    orderBy?: AllianceOrderByWithRelationInput | AllianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alliances.
     */
    cursor?: AllianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alliances.
     */
    skip?: number
    distinct?: AllianceScalarFieldEnum | AllianceScalarFieldEnum[]
  }

  /**
   * Alliance create
   */
  export type AllianceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alliance
     */
    select?: AllianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alliance
     */
    omit?: AllianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllianceInclude<ExtArgs> | null
    /**
     * The data needed to create a Alliance.
     */
    data: XOR<AllianceCreateInput, AllianceUncheckedCreateInput>
  }

  /**
   * Alliance createMany
   */
  export type AllianceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alliances.
     */
    data: AllianceCreateManyInput | AllianceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alliance createManyAndReturn
   */
  export type AllianceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alliance
     */
    select?: AllianceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alliance
     */
    omit?: AllianceOmit<ExtArgs> | null
    /**
     * The data used to create many Alliances.
     */
    data: AllianceCreateManyInput | AllianceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllianceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alliance update
   */
  export type AllianceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alliance
     */
    select?: AllianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alliance
     */
    omit?: AllianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllianceInclude<ExtArgs> | null
    /**
     * The data needed to update a Alliance.
     */
    data: XOR<AllianceUpdateInput, AllianceUncheckedUpdateInput>
    /**
     * Choose, which Alliance to update.
     */
    where: AllianceWhereUniqueInput
  }

  /**
   * Alliance updateMany
   */
  export type AllianceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alliances.
     */
    data: XOR<AllianceUpdateManyMutationInput, AllianceUncheckedUpdateManyInput>
    /**
     * Filter which Alliances to update
     */
    where?: AllianceWhereInput
  }

  /**
   * Alliance updateManyAndReturn
   */
  export type AllianceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alliance
     */
    select?: AllianceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alliance
     */
    omit?: AllianceOmit<ExtArgs> | null
    /**
     * The data used to update Alliances.
     */
    data: XOR<AllianceUpdateManyMutationInput, AllianceUncheckedUpdateManyInput>
    /**
     * Filter which Alliances to update
     */
    where?: AllianceWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllianceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alliance upsert
   */
  export type AllianceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alliance
     */
    select?: AllianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alliance
     */
    omit?: AllianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllianceInclude<ExtArgs> | null
    /**
     * The filter to search for the Alliance to update in case it exists.
     */
    where: AllianceWhereUniqueInput
    /**
     * In case the Alliance found by the `where` argument doesn't exist, create a new Alliance with this data.
     */
    create: XOR<AllianceCreateInput, AllianceUncheckedCreateInput>
    /**
     * In case the Alliance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AllianceUpdateInput, AllianceUncheckedUpdateInput>
  }

  /**
   * Alliance delete
   */
  export type AllianceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alliance
     */
    select?: AllianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alliance
     */
    omit?: AllianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllianceInclude<ExtArgs> | null
    /**
     * Filter which Alliance to delete.
     */
    where: AllianceWhereUniqueInput
  }

  /**
   * Alliance deleteMany
   */
  export type AllianceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alliances to delete
     */
    where?: AllianceWhereInput
  }

  /**
   * Alliance without action
   */
  export type AllianceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alliance
     */
    select?: AllianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alliance
     */
    omit?: AllianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllianceInclude<ExtArgs> | null
  }


  /**
   * Model Battle
   */

  export type AggregateBattle = {
    _count: BattleCountAggregateOutputType | null
    _avg: BattleAvgAggregateOutputType | null
    _sum: BattleSumAggregateOutputType | null
    _min: BattleMinAggregateOutputType | null
    _max: BattleMaxAggregateOutputType | null
  }

  export type BattleAvgAggregateOutputType = {
    tokensStaked: number | null
  }

  export type BattleSumAggregateOutputType = {
    tokensStaked: bigint | null
  }

  export type BattleMinAggregateOutputType = {
    id: string | null
    type: $Enums.BattleType | null
    status: $Enums.BattleStatus | null
    tokensStaked: bigint | null
    startTime: Date | null
    endTime: Date | null
    gameId: string | null
    attackerId: string | null
    defenderId: string | null
    attackerAllyId: string | null
    defenderAllyId: string | null
    winnerId: string | null
  }

  export type BattleMaxAggregateOutputType = {
    id: string | null
    type: $Enums.BattleType | null
    status: $Enums.BattleStatus | null
    tokensStaked: bigint | null
    startTime: Date | null
    endTime: Date | null
    gameId: string | null
    attackerId: string | null
    defenderId: string | null
    attackerAllyId: string | null
    defenderAllyId: string | null
    winnerId: string | null
  }

  export type BattleCountAggregateOutputType = {
    id: number
    type: number
    status: number
    tokensStaked: number
    startTime: number
    endTime: number
    gameId: number
    attackerId: number
    defenderId: number
    attackerAllyId: number
    defenderAllyId: number
    winnerId: number
    _all: number
  }


  export type BattleAvgAggregateInputType = {
    tokensStaked?: true
  }

  export type BattleSumAggregateInputType = {
    tokensStaked?: true
  }

  export type BattleMinAggregateInputType = {
    id?: true
    type?: true
    status?: true
    tokensStaked?: true
    startTime?: true
    endTime?: true
    gameId?: true
    attackerId?: true
    defenderId?: true
    attackerAllyId?: true
    defenderAllyId?: true
    winnerId?: true
  }

  export type BattleMaxAggregateInputType = {
    id?: true
    type?: true
    status?: true
    tokensStaked?: true
    startTime?: true
    endTime?: true
    gameId?: true
    attackerId?: true
    defenderId?: true
    attackerAllyId?: true
    defenderAllyId?: true
    winnerId?: true
  }

  export type BattleCountAggregateInputType = {
    id?: true
    type?: true
    status?: true
    tokensStaked?: true
    startTime?: true
    endTime?: true
    gameId?: true
    attackerId?: true
    defenderId?: true
    attackerAllyId?: true
    defenderAllyId?: true
    winnerId?: true
    _all?: true
  }

  export type BattleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Battle to aggregate.
     */
    where?: BattleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Battles to fetch.
     */
    orderBy?: BattleOrderByWithRelationInput | BattleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BattleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Battles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Battles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Battles
    **/
    _count?: true | BattleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BattleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BattleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BattleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BattleMaxAggregateInputType
  }

  export type GetBattleAggregateType<T extends BattleAggregateArgs> = {
        [P in keyof T & keyof AggregateBattle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBattle[P]>
      : GetScalarType<T[P], AggregateBattle[P]>
  }




  export type BattleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleWhereInput
    orderBy?: BattleOrderByWithAggregationInput | BattleOrderByWithAggregationInput[]
    by: BattleScalarFieldEnum[] | BattleScalarFieldEnum
    having?: BattleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BattleCountAggregateInputType | true
    _avg?: BattleAvgAggregateInputType
    _sum?: BattleSumAggregateInputType
    _min?: BattleMinAggregateInputType
    _max?: BattleMaxAggregateInputType
  }

  export type BattleGroupByOutputType = {
    id: string
    type: $Enums.BattleType
    status: $Enums.BattleStatus
    tokensStaked: bigint
    startTime: Date
    endTime: Date | null
    gameId: string
    attackerId: string
    defenderId: string
    attackerAllyId: string | null
    defenderAllyId: string | null
    winnerId: string | null
    _count: BattleCountAggregateOutputType | null
    _avg: BattleAvgAggregateOutputType | null
    _sum: BattleSumAggregateOutputType | null
    _min: BattleMinAggregateOutputType | null
    _max: BattleMaxAggregateOutputType | null
  }

  type GetBattleGroupByPayload<T extends BattleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BattleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BattleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BattleGroupByOutputType[P]>
            : GetScalarType<T[P], BattleGroupByOutputType[P]>
        }
      >
    >


  export type BattleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    tokensStaked?: boolean
    startTime?: boolean
    endTime?: boolean
    gameId?: boolean
    attackerId?: boolean
    defenderId?: boolean
    attackerAllyId?: boolean
    defenderAllyId?: boolean
    winnerId?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    attacker?: boolean | AgentDefaultArgs<ExtArgs>
    defender?: boolean | AgentDefaultArgs<ExtArgs>
    attackerAlly?: boolean | Battle$attackerAllyArgs<ExtArgs>
    defenderAlly?: boolean | Battle$defenderAllyArgs<ExtArgs>
    winner?: boolean | Battle$winnerArgs<ExtArgs>
  }, ExtArgs["result"]["battle"]>

  export type BattleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    tokensStaked?: boolean
    startTime?: boolean
    endTime?: boolean
    gameId?: boolean
    attackerId?: boolean
    defenderId?: boolean
    attackerAllyId?: boolean
    defenderAllyId?: boolean
    winnerId?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    attacker?: boolean | AgentDefaultArgs<ExtArgs>
    defender?: boolean | AgentDefaultArgs<ExtArgs>
    attackerAlly?: boolean | Battle$attackerAllyArgs<ExtArgs>
    defenderAlly?: boolean | Battle$defenderAllyArgs<ExtArgs>
    winner?: boolean | Battle$winnerArgs<ExtArgs>
  }, ExtArgs["result"]["battle"]>

  export type BattleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    tokensStaked?: boolean
    startTime?: boolean
    endTime?: boolean
    gameId?: boolean
    attackerId?: boolean
    defenderId?: boolean
    attackerAllyId?: boolean
    defenderAllyId?: boolean
    winnerId?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    attacker?: boolean | AgentDefaultArgs<ExtArgs>
    defender?: boolean | AgentDefaultArgs<ExtArgs>
    attackerAlly?: boolean | Battle$attackerAllyArgs<ExtArgs>
    defenderAlly?: boolean | Battle$defenderAllyArgs<ExtArgs>
    winner?: boolean | Battle$winnerArgs<ExtArgs>
  }, ExtArgs["result"]["battle"]>

  export type BattleSelectScalar = {
    id?: boolean
    type?: boolean
    status?: boolean
    tokensStaked?: boolean
    startTime?: boolean
    endTime?: boolean
    gameId?: boolean
    attackerId?: boolean
    defenderId?: boolean
    attackerAllyId?: boolean
    defenderAllyId?: boolean
    winnerId?: boolean
  }

  export type BattleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "status" | "tokensStaked" | "startTime" | "endTime" | "gameId" | "attackerId" | "defenderId" | "attackerAllyId" | "defenderAllyId" | "winnerId", ExtArgs["result"]["battle"]>
  export type BattleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    attacker?: boolean | AgentDefaultArgs<ExtArgs>
    defender?: boolean | AgentDefaultArgs<ExtArgs>
    attackerAlly?: boolean | Battle$attackerAllyArgs<ExtArgs>
    defenderAlly?: boolean | Battle$defenderAllyArgs<ExtArgs>
    winner?: boolean | Battle$winnerArgs<ExtArgs>
  }
  export type BattleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    attacker?: boolean | AgentDefaultArgs<ExtArgs>
    defender?: boolean | AgentDefaultArgs<ExtArgs>
    attackerAlly?: boolean | Battle$attackerAllyArgs<ExtArgs>
    defenderAlly?: boolean | Battle$defenderAllyArgs<ExtArgs>
    winner?: boolean | Battle$winnerArgs<ExtArgs>
  }
  export type BattleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    attacker?: boolean | AgentDefaultArgs<ExtArgs>
    defender?: boolean | AgentDefaultArgs<ExtArgs>
    attackerAlly?: boolean | Battle$attackerAllyArgs<ExtArgs>
    defenderAlly?: boolean | Battle$defenderAllyArgs<ExtArgs>
    winner?: boolean | Battle$winnerArgs<ExtArgs>
  }

  export type $BattlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Battle"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
      attacker: Prisma.$AgentPayload<ExtArgs>
      defender: Prisma.$AgentPayload<ExtArgs>
      attackerAlly: Prisma.$AgentPayload<ExtArgs> | null
      defenderAlly: Prisma.$AgentPayload<ExtArgs> | null
      winner: Prisma.$AgentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.BattleType
      status: $Enums.BattleStatus
      tokensStaked: bigint
      startTime: Date
      endTime: Date | null
      gameId: string
      attackerId: string
      defenderId: string
      attackerAllyId: string | null
      defenderAllyId: string | null
      winnerId: string | null
    }, ExtArgs["result"]["battle"]>
    composites: {}
  }

  type BattleGetPayload<S extends boolean | null | undefined | BattleDefaultArgs> = $Result.GetResult<Prisma.$BattlePayload, S>

  type BattleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BattleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BattleCountAggregateInputType | true
    }

  export interface BattleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Battle'], meta: { name: 'Battle' } }
    /**
     * Find zero or one Battle that matches the filter.
     * @param {BattleFindUniqueArgs} args - Arguments to find a Battle
     * @example
     * // Get one Battle
     * const battle = await prisma.battle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BattleFindUniqueArgs>(args: SelectSubset<T, BattleFindUniqueArgs<ExtArgs>>): Prisma__BattleClient<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Battle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BattleFindUniqueOrThrowArgs} args - Arguments to find a Battle
     * @example
     * // Get one Battle
     * const battle = await prisma.battle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BattleFindUniqueOrThrowArgs>(args: SelectSubset<T, BattleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BattleClient<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Battle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleFindFirstArgs} args - Arguments to find a Battle
     * @example
     * // Get one Battle
     * const battle = await prisma.battle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BattleFindFirstArgs>(args?: SelectSubset<T, BattleFindFirstArgs<ExtArgs>>): Prisma__BattleClient<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Battle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleFindFirstOrThrowArgs} args - Arguments to find a Battle
     * @example
     * // Get one Battle
     * const battle = await prisma.battle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BattleFindFirstOrThrowArgs>(args?: SelectSubset<T, BattleFindFirstOrThrowArgs<ExtArgs>>): Prisma__BattleClient<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Battles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Battles
     * const battles = await prisma.battle.findMany()
     * 
     * // Get first 10 Battles
     * const battles = await prisma.battle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const battleWithIdOnly = await prisma.battle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BattleFindManyArgs>(args?: SelectSubset<T, BattleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Battle.
     * @param {BattleCreateArgs} args - Arguments to create a Battle.
     * @example
     * // Create one Battle
     * const Battle = await prisma.battle.create({
     *   data: {
     *     // ... data to create a Battle
     *   }
     * })
     * 
     */
    create<T extends BattleCreateArgs>(args: SelectSubset<T, BattleCreateArgs<ExtArgs>>): Prisma__BattleClient<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Battles.
     * @param {BattleCreateManyArgs} args - Arguments to create many Battles.
     * @example
     * // Create many Battles
     * const battle = await prisma.battle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BattleCreateManyArgs>(args?: SelectSubset<T, BattleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Battles and returns the data saved in the database.
     * @param {BattleCreateManyAndReturnArgs} args - Arguments to create many Battles.
     * @example
     * // Create many Battles
     * const battle = await prisma.battle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Battles and only return the `id`
     * const battleWithIdOnly = await prisma.battle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BattleCreateManyAndReturnArgs>(args?: SelectSubset<T, BattleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Battle.
     * @param {BattleDeleteArgs} args - Arguments to delete one Battle.
     * @example
     * // Delete one Battle
     * const Battle = await prisma.battle.delete({
     *   where: {
     *     // ... filter to delete one Battle
     *   }
     * })
     * 
     */
    delete<T extends BattleDeleteArgs>(args: SelectSubset<T, BattleDeleteArgs<ExtArgs>>): Prisma__BattleClient<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Battle.
     * @param {BattleUpdateArgs} args - Arguments to update one Battle.
     * @example
     * // Update one Battle
     * const battle = await prisma.battle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BattleUpdateArgs>(args: SelectSubset<T, BattleUpdateArgs<ExtArgs>>): Prisma__BattleClient<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Battles.
     * @param {BattleDeleteManyArgs} args - Arguments to filter Battles to delete.
     * @example
     * // Delete a few Battles
     * const { count } = await prisma.battle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BattleDeleteManyArgs>(args?: SelectSubset<T, BattleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Battles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Battles
     * const battle = await prisma.battle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BattleUpdateManyArgs>(args: SelectSubset<T, BattleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Battles and returns the data updated in the database.
     * @param {BattleUpdateManyAndReturnArgs} args - Arguments to update many Battles.
     * @example
     * // Update many Battles
     * const battle = await prisma.battle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Battles and only return the `id`
     * const battleWithIdOnly = await prisma.battle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BattleUpdateManyAndReturnArgs>(args: SelectSubset<T, BattleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Battle.
     * @param {BattleUpsertArgs} args - Arguments to update or create a Battle.
     * @example
     * // Update or create a Battle
     * const battle = await prisma.battle.upsert({
     *   create: {
     *     // ... data to create a Battle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Battle we want to update
     *   }
     * })
     */
    upsert<T extends BattleUpsertArgs>(args: SelectSubset<T, BattleUpsertArgs<ExtArgs>>): Prisma__BattleClient<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Battles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleCountArgs} args - Arguments to filter Battles to count.
     * @example
     * // Count the number of Battles
     * const count = await prisma.battle.count({
     *   where: {
     *     // ... the filter for the Battles we want to count
     *   }
     * })
    **/
    count<T extends BattleCountArgs>(
      args?: Subset<T, BattleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BattleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Battle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BattleAggregateArgs>(args: Subset<T, BattleAggregateArgs>): Prisma.PrismaPromise<GetBattleAggregateType<T>>

    /**
     * Group by Battle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BattleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BattleGroupByArgs['orderBy'] }
        : { orderBy?: BattleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BattleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBattleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Battle model
   */
  readonly fields: BattleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Battle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BattleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    attacker<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    defender<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    attackerAlly<T extends Battle$attackerAllyArgs<ExtArgs> = {}>(args?: Subset<T, Battle$attackerAllyArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    defenderAlly<T extends Battle$defenderAllyArgs<ExtArgs> = {}>(args?: Subset<T, Battle$defenderAllyArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    winner<T extends Battle$winnerArgs<ExtArgs> = {}>(args?: Subset<T, Battle$winnerArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Battle model
   */ 
  interface BattleFieldRefs {
    readonly id: FieldRef<"Battle", 'String'>
    readonly type: FieldRef<"Battle", 'BattleType'>
    readonly status: FieldRef<"Battle", 'BattleStatus'>
    readonly tokensStaked: FieldRef<"Battle", 'BigInt'>
    readonly startTime: FieldRef<"Battle", 'DateTime'>
    readonly endTime: FieldRef<"Battle", 'DateTime'>
    readonly gameId: FieldRef<"Battle", 'String'>
    readonly attackerId: FieldRef<"Battle", 'String'>
    readonly defenderId: FieldRef<"Battle", 'String'>
    readonly attackerAllyId: FieldRef<"Battle", 'String'>
    readonly defenderAllyId: FieldRef<"Battle", 'String'>
    readonly winnerId: FieldRef<"Battle", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Battle findUnique
   */
  export type BattleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    /**
     * Filter, which Battle to fetch.
     */
    where: BattleWhereUniqueInput
  }

  /**
   * Battle findUniqueOrThrow
   */
  export type BattleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    /**
     * Filter, which Battle to fetch.
     */
    where: BattleWhereUniqueInput
  }

  /**
   * Battle findFirst
   */
  export type BattleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    /**
     * Filter, which Battle to fetch.
     */
    where?: BattleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Battles to fetch.
     */
    orderBy?: BattleOrderByWithRelationInput | BattleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Battles.
     */
    cursor?: BattleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Battles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Battles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Battles.
     */
    distinct?: BattleScalarFieldEnum | BattleScalarFieldEnum[]
  }

  /**
   * Battle findFirstOrThrow
   */
  export type BattleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    /**
     * Filter, which Battle to fetch.
     */
    where?: BattleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Battles to fetch.
     */
    orderBy?: BattleOrderByWithRelationInput | BattleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Battles.
     */
    cursor?: BattleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Battles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Battles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Battles.
     */
    distinct?: BattleScalarFieldEnum | BattleScalarFieldEnum[]
  }

  /**
   * Battle findMany
   */
  export type BattleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    /**
     * Filter, which Battles to fetch.
     */
    where?: BattleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Battles to fetch.
     */
    orderBy?: BattleOrderByWithRelationInput | BattleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Battles.
     */
    cursor?: BattleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Battles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Battles.
     */
    skip?: number
    distinct?: BattleScalarFieldEnum | BattleScalarFieldEnum[]
  }

  /**
   * Battle create
   */
  export type BattleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    /**
     * The data needed to create a Battle.
     */
    data: XOR<BattleCreateInput, BattleUncheckedCreateInput>
  }

  /**
   * Battle createMany
   */
  export type BattleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Battles.
     */
    data: BattleCreateManyInput | BattleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Battle createManyAndReturn
   */
  export type BattleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * The data used to create many Battles.
     */
    data: BattleCreateManyInput | BattleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Battle update
   */
  export type BattleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    /**
     * The data needed to update a Battle.
     */
    data: XOR<BattleUpdateInput, BattleUncheckedUpdateInput>
    /**
     * Choose, which Battle to update.
     */
    where: BattleWhereUniqueInput
  }

  /**
   * Battle updateMany
   */
  export type BattleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Battles.
     */
    data: XOR<BattleUpdateManyMutationInput, BattleUncheckedUpdateManyInput>
    /**
     * Filter which Battles to update
     */
    where?: BattleWhereInput
  }

  /**
   * Battle updateManyAndReturn
   */
  export type BattleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * The data used to update Battles.
     */
    data: XOR<BattleUpdateManyMutationInput, BattleUncheckedUpdateManyInput>
    /**
     * Filter which Battles to update
     */
    where?: BattleWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Battle upsert
   */
  export type BattleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    /**
     * The filter to search for the Battle to update in case it exists.
     */
    where: BattleWhereUniqueInput
    /**
     * In case the Battle found by the `where` argument doesn't exist, create a new Battle with this data.
     */
    create: XOR<BattleCreateInput, BattleUncheckedCreateInput>
    /**
     * In case the Battle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BattleUpdateInput, BattleUncheckedUpdateInput>
  }

  /**
   * Battle delete
   */
  export type BattleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    /**
     * Filter which Battle to delete.
     */
    where: BattleWhereUniqueInput
  }

  /**
   * Battle deleteMany
   */
  export type BattleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Battles to delete
     */
    where?: BattleWhereInput
  }

  /**
   * Battle.attackerAlly
   */
  export type Battle$attackerAllyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * Battle.defenderAlly
   */
  export type Battle$defenderAllyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * Battle.winner
   */
  export type Battle$winnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * Battle without action
   */
  export type BattleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
  }


  /**
   * Model Interaction
   */

  export type AggregateInteraction = {
    _count: InteractionCountAggregateOutputType | null
    _min: InteractionMinAggregateOutputType | null
    _max: InteractionMaxAggregateOutputType | null
  }

  export type InteractionMinAggregateOutputType = {
    id: string | null
    tweetId: string | null
    userId: string | null
    type: $Enums.InteractionType | null
    content: string | null
    timestamp: Date | null
  }

  export type InteractionMaxAggregateOutputType = {
    id: string | null
    tweetId: string | null
    userId: string | null
    type: $Enums.InteractionType | null
    content: string | null
    timestamp: Date | null
  }

  export type InteractionCountAggregateOutputType = {
    id: number
    tweetId: number
    userId: number
    type: number
    content: number
    timestamp: number
    userMetrics: number
    _all: number
  }


  export type InteractionMinAggregateInputType = {
    id?: true
    tweetId?: true
    userId?: true
    type?: true
    content?: true
    timestamp?: true
  }

  export type InteractionMaxAggregateInputType = {
    id?: true
    tweetId?: true
    userId?: true
    type?: true
    content?: true
    timestamp?: true
  }

  export type InteractionCountAggregateInputType = {
    id?: true
    tweetId?: true
    userId?: true
    type?: true
    content?: true
    timestamp?: true
    userMetrics?: true
    _all?: true
  }

  export type InteractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interaction to aggregate.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interactions
    **/
    _count?: true | InteractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InteractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InteractionMaxAggregateInputType
  }

  export type GetInteractionAggregateType<T extends InteractionAggregateArgs> = {
        [P in keyof T & keyof AggregateInteraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInteraction[P]>
      : GetScalarType<T[P], AggregateInteraction[P]>
  }




  export type InteractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionWhereInput
    orderBy?: InteractionOrderByWithAggregationInput | InteractionOrderByWithAggregationInput[]
    by: InteractionScalarFieldEnum[] | InteractionScalarFieldEnum
    having?: InteractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InteractionCountAggregateInputType | true
    _min?: InteractionMinAggregateInputType
    _max?: InteractionMaxAggregateInputType
  }

  export type InteractionGroupByOutputType = {
    id: string
    tweetId: string
    userId: string
    type: $Enums.InteractionType
    content: string
    timestamp: Date
    userMetrics: JsonValue
    _count: InteractionCountAggregateOutputType | null
    _min: InteractionMinAggregateOutputType | null
    _max: InteractionMaxAggregateOutputType | null
  }

  type GetInteractionGroupByPayload<T extends InteractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InteractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InteractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InteractionGroupByOutputType[P]>
            : GetScalarType<T[P], InteractionGroupByOutputType[P]>
        }
      >
    >


  export type InteractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tweetId?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    timestamp?: boolean
    userMetrics?: boolean
    tweet?: boolean | TweetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interaction"]>

  export type InteractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tweetId?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    timestamp?: boolean
    userMetrics?: boolean
    tweet?: boolean | TweetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interaction"]>

  export type InteractionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tweetId?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    timestamp?: boolean
    userMetrics?: boolean
    tweet?: boolean | TweetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interaction"]>

  export type InteractionSelectScalar = {
    id?: boolean
    tweetId?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    timestamp?: boolean
    userMetrics?: boolean
  }

  export type InteractionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tweetId" | "userId" | "type" | "content" | "timestamp" | "userMetrics", ExtArgs["result"]["interaction"]>
  export type InteractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweet?: boolean | TweetDefaultArgs<ExtArgs>
  }
  export type InteractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweet?: boolean | TweetDefaultArgs<ExtArgs>
  }
  export type InteractionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweet?: boolean | TweetDefaultArgs<ExtArgs>
  }

  export type $InteractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Interaction"
    objects: {
      tweet: Prisma.$TweetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tweetId: string
      userId: string
      type: $Enums.InteractionType
      content: string
      timestamp: Date
      userMetrics: Prisma.JsonValue
    }, ExtArgs["result"]["interaction"]>
    composites: {}
  }

  type InteractionGetPayload<S extends boolean | null | undefined | InteractionDefaultArgs> = $Result.GetResult<Prisma.$InteractionPayload, S>

  type InteractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InteractionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InteractionCountAggregateInputType | true
    }

  export interface InteractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Interaction'], meta: { name: 'Interaction' } }
    /**
     * Find zero or one Interaction that matches the filter.
     * @param {InteractionFindUniqueArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InteractionFindUniqueArgs>(args: SelectSubset<T, InteractionFindUniqueArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Interaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InteractionFindUniqueOrThrowArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InteractionFindUniqueOrThrowArgs>(args: SelectSubset<T, InteractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Interaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionFindFirstArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InteractionFindFirstArgs>(args?: SelectSubset<T, InteractionFindFirstArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Interaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionFindFirstOrThrowArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InteractionFindFirstOrThrowArgs>(args?: SelectSubset<T, InteractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Interactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interactions
     * const interactions = await prisma.interaction.findMany()
     * 
     * // Get first 10 Interactions
     * const interactions = await prisma.interaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interactionWithIdOnly = await prisma.interaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InteractionFindManyArgs>(args?: SelectSubset<T, InteractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Interaction.
     * @param {InteractionCreateArgs} args - Arguments to create a Interaction.
     * @example
     * // Create one Interaction
     * const Interaction = await prisma.interaction.create({
     *   data: {
     *     // ... data to create a Interaction
     *   }
     * })
     * 
     */
    create<T extends InteractionCreateArgs>(args: SelectSubset<T, InteractionCreateArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Interactions.
     * @param {InteractionCreateManyArgs} args - Arguments to create many Interactions.
     * @example
     * // Create many Interactions
     * const interaction = await prisma.interaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InteractionCreateManyArgs>(args?: SelectSubset<T, InteractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Interactions and returns the data saved in the database.
     * @param {InteractionCreateManyAndReturnArgs} args - Arguments to create many Interactions.
     * @example
     * // Create many Interactions
     * const interaction = await prisma.interaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Interactions and only return the `id`
     * const interactionWithIdOnly = await prisma.interaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InteractionCreateManyAndReturnArgs>(args?: SelectSubset<T, InteractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Interaction.
     * @param {InteractionDeleteArgs} args - Arguments to delete one Interaction.
     * @example
     * // Delete one Interaction
     * const Interaction = await prisma.interaction.delete({
     *   where: {
     *     // ... filter to delete one Interaction
     *   }
     * })
     * 
     */
    delete<T extends InteractionDeleteArgs>(args: SelectSubset<T, InteractionDeleteArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Interaction.
     * @param {InteractionUpdateArgs} args - Arguments to update one Interaction.
     * @example
     * // Update one Interaction
     * const interaction = await prisma.interaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InteractionUpdateArgs>(args: SelectSubset<T, InteractionUpdateArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Interactions.
     * @param {InteractionDeleteManyArgs} args - Arguments to filter Interactions to delete.
     * @example
     * // Delete a few Interactions
     * const { count } = await prisma.interaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InteractionDeleteManyArgs>(args?: SelectSubset<T, InteractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interactions
     * const interaction = await prisma.interaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InteractionUpdateManyArgs>(args: SelectSubset<T, InteractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interactions and returns the data updated in the database.
     * @param {InteractionUpdateManyAndReturnArgs} args - Arguments to update many Interactions.
     * @example
     * // Update many Interactions
     * const interaction = await prisma.interaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Interactions and only return the `id`
     * const interactionWithIdOnly = await prisma.interaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InteractionUpdateManyAndReturnArgs>(args: SelectSubset<T, InteractionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Interaction.
     * @param {InteractionUpsertArgs} args - Arguments to update or create a Interaction.
     * @example
     * // Update or create a Interaction
     * const interaction = await prisma.interaction.upsert({
     *   create: {
     *     // ... data to create a Interaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interaction we want to update
     *   }
     * })
     */
    upsert<T extends InteractionUpsertArgs>(args: SelectSubset<T, InteractionUpsertArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Interactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionCountArgs} args - Arguments to filter Interactions to count.
     * @example
     * // Count the number of Interactions
     * const count = await prisma.interaction.count({
     *   where: {
     *     // ... the filter for the Interactions we want to count
     *   }
     * })
    **/
    count<T extends InteractionCountArgs>(
      args?: Subset<T, InteractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InteractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InteractionAggregateArgs>(args: Subset<T, InteractionAggregateArgs>): Prisma.PrismaPromise<GetInteractionAggregateType<T>>

    /**
     * Group by Interaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InteractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InteractionGroupByArgs['orderBy'] }
        : { orderBy?: InteractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InteractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInteractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Interaction model
   */
  readonly fields: InteractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Interaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InteractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tweet<T extends TweetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TweetDefaultArgs<ExtArgs>>): Prisma__TweetClient<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Interaction model
   */ 
  interface InteractionFieldRefs {
    readonly id: FieldRef<"Interaction", 'String'>
    readonly tweetId: FieldRef<"Interaction", 'String'>
    readonly userId: FieldRef<"Interaction", 'String'>
    readonly type: FieldRef<"Interaction", 'InteractionType'>
    readonly content: FieldRef<"Interaction", 'String'>
    readonly timestamp: FieldRef<"Interaction", 'DateTime'>
    readonly userMetrics: FieldRef<"Interaction", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Interaction findUnique
   */
  export type InteractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction findUniqueOrThrow
   */
  export type InteractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction findFirst
   */
  export type InteractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interactions.
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interactions.
     */
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Interaction findFirstOrThrow
   */
  export type InteractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interactions.
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interactions.
     */
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Interaction findMany
   */
  export type InteractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interactions to fetch.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interactions.
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Interaction create
   */
  export type InteractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * The data needed to create a Interaction.
     */
    data: XOR<InteractionCreateInput, InteractionUncheckedCreateInput>
  }

  /**
   * Interaction createMany
   */
  export type InteractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interactions.
     */
    data: InteractionCreateManyInput | InteractionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Interaction createManyAndReturn
   */
  export type InteractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * The data used to create many Interactions.
     */
    data: InteractionCreateManyInput | InteractionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Interaction update
   */
  export type InteractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * The data needed to update a Interaction.
     */
    data: XOR<InteractionUpdateInput, InteractionUncheckedUpdateInput>
    /**
     * Choose, which Interaction to update.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction updateMany
   */
  export type InteractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interactions.
     */
    data: XOR<InteractionUpdateManyMutationInput, InteractionUncheckedUpdateManyInput>
    /**
     * Filter which Interactions to update
     */
    where?: InteractionWhereInput
  }

  /**
   * Interaction updateManyAndReturn
   */
  export type InteractionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * The data used to update Interactions.
     */
    data: XOR<InteractionUpdateManyMutationInput, InteractionUncheckedUpdateManyInput>
    /**
     * Filter which Interactions to update
     */
    where?: InteractionWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Interaction upsert
   */
  export type InteractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * The filter to search for the Interaction to update in case it exists.
     */
    where: InteractionWhereUniqueInput
    /**
     * In case the Interaction found by the `where` argument doesn't exist, create a new Interaction with this data.
     */
    create: XOR<InteractionCreateInput, InteractionUncheckedCreateInput>
    /**
     * In case the Interaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InteractionUpdateInput, InteractionUncheckedUpdateInput>
  }

  /**
   * Interaction delete
   */
  export type InteractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter which Interaction to delete.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction deleteMany
   */
  export type InteractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interactions to delete
     */
    where?: InteractionWhereInput
  }

  /**
   * Interaction without action
   */
  export type InteractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
  }


  /**
   * Model CoolDown
   */

  export type AggregateCoolDown = {
    _count: CoolDownCountAggregateOutputType | null
    _min: CoolDownMinAggregateOutputType | null
    _max: CoolDownMaxAggregateOutputType | null
  }

  export type CoolDownMinAggregateOutputType = {
    id: string | null
    type: $Enums.CooldownType | null
    endsAt: Date | null
    startsAt: Date | null
    cooledAgentId: string | null
    gameId: string | null
  }

  export type CoolDownMaxAggregateOutputType = {
    id: string | null
    type: $Enums.CooldownType | null
    endsAt: Date | null
    startsAt: Date | null
    cooledAgentId: string | null
    gameId: string | null
  }

  export type CoolDownCountAggregateOutputType = {
    id: number
    type: number
    endsAt: number
    startsAt: number
    cooledAgentId: number
    gameId: number
    _all: number
  }


  export type CoolDownMinAggregateInputType = {
    id?: true
    type?: true
    endsAt?: true
    startsAt?: true
    cooledAgentId?: true
    gameId?: true
  }

  export type CoolDownMaxAggregateInputType = {
    id?: true
    type?: true
    endsAt?: true
    startsAt?: true
    cooledAgentId?: true
    gameId?: true
  }

  export type CoolDownCountAggregateInputType = {
    id?: true
    type?: true
    endsAt?: true
    startsAt?: true
    cooledAgentId?: true
    gameId?: true
    _all?: true
  }

  export type CoolDownAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoolDown to aggregate.
     */
    where?: CoolDownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoolDowns to fetch.
     */
    orderBy?: CoolDownOrderByWithRelationInput | CoolDownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoolDownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoolDowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoolDowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoolDowns
    **/
    _count?: true | CoolDownCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoolDownMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoolDownMaxAggregateInputType
  }

  export type GetCoolDownAggregateType<T extends CoolDownAggregateArgs> = {
        [P in keyof T & keyof AggregateCoolDown]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoolDown[P]>
      : GetScalarType<T[P], AggregateCoolDown[P]>
  }




  export type CoolDownGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoolDownWhereInput
    orderBy?: CoolDownOrderByWithAggregationInput | CoolDownOrderByWithAggregationInput[]
    by: CoolDownScalarFieldEnum[] | CoolDownScalarFieldEnum
    having?: CoolDownScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoolDownCountAggregateInputType | true
    _min?: CoolDownMinAggregateInputType
    _max?: CoolDownMaxAggregateInputType
  }

  export type CoolDownGroupByOutputType = {
    id: string
    type: $Enums.CooldownType
    endsAt: Date
    startsAt: Date | null
    cooledAgentId: string
    gameId: string
    _count: CoolDownCountAggregateOutputType | null
    _min: CoolDownMinAggregateOutputType | null
    _max: CoolDownMaxAggregateOutputType | null
  }

  type GetCoolDownGroupByPayload<T extends CoolDownGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoolDownGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoolDownGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoolDownGroupByOutputType[P]>
            : GetScalarType<T[P], CoolDownGroupByOutputType[P]>
        }
      >
    >


  export type CoolDownSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    endsAt?: boolean
    startsAt?: boolean
    cooledAgentId?: boolean
    gameId?: boolean
    cooledAgent?: boolean | AgentDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coolDown"]>

  export type CoolDownSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    endsAt?: boolean
    startsAt?: boolean
    cooledAgentId?: boolean
    gameId?: boolean
    cooledAgent?: boolean | AgentDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coolDown"]>

  export type CoolDownSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    endsAt?: boolean
    startsAt?: boolean
    cooledAgentId?: boolean
    gameId?: boolean
    cooledAgent?: boolean | AgentDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coolDown"]>

  export type CoolDownSelectScalar = {
    id?: boolean
    type?: boolean
    endsAt?: boolean
    startsAt?: boolean
    cooledAgentId?: boolean
    gameId?: boolean
  }

  export type CoolDownOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "endsAt" | "startsAt" | "cooledAgentId" | "gameId", ExtArgs["result"]["coolDown"]>
  export type CoolDownInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cooledAgent?: boolean | AgentDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type CoolDownIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cooledAgent?: boolean | AgentDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type CoolDownIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cooledAgent?: boolean | AgentDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }

  export type $CoolDownPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoolDown"
    objects: {
      cooledAgent: Prisma.$AgentPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.CooldownType
      endsAt: Date
      startsAt: Date | null
      cooledAgentId: string
      gameId: string
    }, ExtArgs["result"]["coolDown"]>
    composites: {}
  }

  type CoolDownGetPayload<S extends boolean | null | undefined | CoolDownDefaultArgs> = $Result.GetResult<Prisma.$CoolDownPayload, S>

  type CoolDownCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CoolDownFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CoolDownCountAggregateInputType | true
    }

  export interface CoolDownDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoolDown'], meta: { name: 'CoolDown' } }
    /**
     * Find zero or one CoolDown that matches the filter.
     * @param {CoolDownFindUniqueArgs} args - Arguments to find a CoolDown
     * @example
     * // Get one CoolDown
     * const coolDown = await prisma.coolDown.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoolDownFindUniqueArgs>(args: SelectSubset<T, CoolDownFindUniqueArgs<ExtArgs>>): Prisma__CoolDownClient<$Result.GetResult<Prisma.$CoolDownPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CoolDown that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CoolDownFindUniqueOrThrowArgs} args - Arguments to find a CoolDown
     * @example
     * // Get one CoolDown
     * const coolDown = await prisma.coolDown.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoolDownFindUniqueOrThrowArgs>(args: SelectSubset<T, CoolDownFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoolDownClient<$Result.GetResult<Prisma.$CoolDownPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CoolDown that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoolDownFindFirstArgs} args - Arguments to find a CoolDown
     * @example
     * // Get one CoolDown
     * const coolDown = await prisma.coolDown.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoolDownFindFirstArgs>(args?: SelectSubset<T, CoolDownFindFirstArgs<ExtArgs>>): Prisma__CoolDownClient<$Result.GetResult<Prisma.$CoolDownPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CoolDown that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoolDownFindFirstOrThrowArgs} args - Arguments to find a CoolDown
     * @example
     * // Get one CoolDown
     * const coolDown = await prisma.coolDown.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoolDownFindFirstOrThrowArgs>(args?: SelectSubset<T, CoolDownFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoolDownClient<$Result.GetResult<Prisma.$CoolDownPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CoolDowns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoolDownFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoolDowns
     * const coolDowns = await prisma.coolDown.findMany()
     * 
     * // Get first 10 CoolDowns
     * const coolDowns = await prisma.coolDown.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coolDownWithIdOnly = await prisma.coolDown.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoolDownFindManyArgs>(args?: SelectSubset<T, CoolDownFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoolDownPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CoolDown.
     * @param {CoolDownCreateArgs} args - Arguments to create a CoolDown.
     * @example
     * // Create one CoolDown
     * const CoolDown = await prisma.coolDown.create({
     *   data: {
     *     // ... data to create a CoolDown
     *   }
     * })
     * 
     */
    create<T extends CoolDownCreateArgs>(args: SelectSubset<T, CoolDownCreateArgs<ExtArgs>>): Prisma__CoolDownClient<$Result.GetResult<Prisma.$CoolDownPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CoolDowns.
     * @param {CoolDownCreateManyArgs} args - Arguments to create many CoolDowns.
     * @example
     * // Create many CoolDowns
     * const coolDown = await prisma.coolDown.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoolDownCreateManyArgs>(args?: SelectSubset<T, CoolDownCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoolDowns and returns the data saved in the database.
     * @param {CoolDownCreateManyAndReturnArgs} args - Arguments to create many CoolDowns.
     * @example
     * // Create many CoolDowns
     * const coolDown = await prisma.coolDown.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoolDowns and only return the `id`
     * const coolDownWithIdOnly = await prisma.coolDown.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoolDownCreateManyAndReturnArgs>(args?: SelectSubset<T, CoolDownCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoolDownPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CoolDown.
     * @param {CoolDownDeleteArgs} args - Arguments to delete one CoolDown.
     * @example
     * // Delete one CoolDown
     * const CoolDown = await prisma.coolDown.delete({
     *   where: {
     *     // ... filter to delete one CoolDown
     *   }
     * })
     * 
     */
    delete<T extends CoolDownDeleteArgs>(args: SelectSubset<T, CoolDownDeleteArgs<ExtArgs>>): Prisma__CoolDownClient<$Result.GetResult<Prisma.$CoolDownPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CoolDown.
     * @param {CoolDownUpdateArgs} args - Arguments to update one CoolDown.
     * @example
     * // Update one CoolDown
     * const coolDown = await prisma.coolDown.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoolDownUpdateArgs>(args: SelectSubset<T, CoolDownUpdateArgs<ExtArgs>>): Prisma__CoolDownClient<$Result.GetResult<Prisma.$CoolDownPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CoolDowns.
     * @param {CoolDownDeleteManyArgs} args - Arguments to filter CoolDowns to delete.
     * @example
     * // Delete a few CoolDowns
     * const { count } = await prisma.coolDown.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoolDownDeleteManyArgs>(args?: SelectSubset<T, CoolDownDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoolDowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoolDownUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoolDowns
     * const coolDown = await prisma.coolDown.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoolDownUpdateManyArgs>(args: SelectSubset<T, CoolDownUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoolDowns and returns the data updated in the database.
     * @param {CoolDownUpdateManyAndReturnArgs} args - Arguments to update many CoolDowns.
     * @example
     * // Update many CoolDowns
     * const coolDown = await prisma.coolDown.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CoolDowns and only return the `id`
     * const coolDownWithIdOnly = await prisma.coolDown.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CoolDownUpdateManyAndReturnArgs>(args: SelectSubset<T, CoolDownUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoolDownPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CoolDown.
     * @param {CoolDownUpsertArgs} args - Arguments to update or create a CoolDown.
     * @example
     * // Update or create a CoolDown
     * const coolDown = await prisma.coolDown.upsert({
     *   create: {
     *     // ... data to create a CoolDown
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoolDown we want to update
     *   }
     * })
     */
    upsert<T extends CoolDownUpsertArgs>(args: SelectSubset<T, CoolDownUpsertArgs<ExtArgs>>): Prisma__CoolDownClient<$Result.GetResult<Prisma.$CoolDownPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CoolDowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoolDownCountArgs} args - Arguments to filter CoolDowns to count.
     * @example
     * // Count the number of CoolDowns
     * const count = await prisma.coolDown.count({
     *   where: {
     *     // ... the filter for the CoolDowns we want to count
     *   }
     * })
    **/
    count<T extends CoolDownCountArgs>(
      args?: Subset<T, CoolDownCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoolDownCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoolDown.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoolDownAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoolDownAggregateArgs>(args: Subset<T, CoolDownAggregateArgs>): Prisma.PrismaPromise<GetCoolDownAggregateType<T>>

    /**
     * Group by CoolDown.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoolDownGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoolDownGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoolDownGroupByArgs['orderBy'] }
        : { orderBy?: CoolDownGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoolDownGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoolDownGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoolDown model
   */
  readonly fields: CoolDownFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoolDown.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoolDownClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cooledAgent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoolDown model
   */ 
  interface CoolDownFieldRefs {
    readonly id: FieldRef<"CoolDown", 'String'>
    readonly type: FieldRef<"CoolDown", 'CooldownType'>
    readonly endsAt: FieldRef<"CoolDown", 'DateTime'>
    readonly startsAt: FieldRef<"CoolDown", 'DateTime'>
    readonly cooledAgentId: FieldRef<"CoolDown", 'String'>
    readonly gameId: FieldRef<"CoolDown", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CoolDown findUnique
   */
  export type CoolDownFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoolDown
     */
    select?: CoolDownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoolDown
     */
    omit?: CoolDownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoolDownInclude<ExtArgs> | null
    /**
     * Filter, which CoolDown to fetch.
     */
    where: CoolDownWhereUniqueInput
  }

  /**
   * CoolDown findUniqueOrThrow
   */
  export type CoolDownFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoolDown
     */
    select?: CoolDownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoolDown
     */
    omit?: CoolDownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoolDownInclude<ExtArgs> | null
    /**
     * Filter, which CoolDown to fetch.
     */
    where: CoolDownWhereUniqueInput
  }

  /**
   * CoolDown findFirst
   */
  export type CoolDownFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoolDown
     */
    select?: CoolDownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoolDown
     */
    omit?: CoolDownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoolDownInclude<ExtArgs> | null
    /**
     * Filter, which CoolDown to fetch.
     */
    where?: CoolDownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoolDowns to fetch.
     */
    orderBy?: CoolDownOrderByWithRelationInput | CoolDownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoolDowns.
     */
    cursor?: CoolDownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoolDowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoolDowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoolDowns.
     */
    distinct?: CoolDownScalarFieldEnum | CoolDownScalarFieldEnum[]
  }

  /**
   * CoolDown findFirstOrThrow
   */
  export type CoolDownFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoolDown
     */
    select?: CoolDownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoolDown
     */
    omit?: CoolDownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoolDownInclude<ExtArgs> | null
    /**
     * Filter, which CoolDown to fetch.
     */
    where?: CoolDownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoolDowns to fetch.
     */
    orderBy?: CoolDownOrderByWithRelationInput | CoolDownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoolDowns.
     */
    cursor?: CoolDownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoolDowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoolDowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoolDowns.
     */
    distinct?: CoolDownScalarFieldEnum | CoolDownScalarFieldEnum[]
  }

  /**
   * CoolDown findMany
   */
  export type CoolDownFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoolDown
     */
    select?: CoolDownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoolDown
     */
    omit?: CoolDownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoolDownInclude<ExtArgs> | null
    /**
     * Filter, which CoolDowns to fetch.
     */
    where?: CoolDownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoolDowns to fetch.
     */
    orderBy?: CoolDownOrderByWithRelationInput | CoolDownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoolDowns.
     */
    cursor?: CoolDownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoolDowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoolDowns.
     */
    skip?: number
    distinct?: CoolDownScalarFieldEnum | CoolDownScalarFieldEnum[]
  }

  /**
   * CoolDown create
   */
  export type CoolDownCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoolDown
     */
    select?: CoolDownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoolDown
     */
    omit?: CoolDownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoolDownInclude<ExtArgs> | null
    /**
     * The data needed to create a CoolDown.
     */
    data: XOR<CoolDownCreateInput, CoolDownUncheckedCreateInput>
  }

  /**
   * CoolDown createMany
   */
  export type CoolDownCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoolDowns.
     */
    data: CoolDownCreateManyInput | CoolDownCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoolDown createManyAndReturn
   */
  export type CoolDownCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoolDown
     */
    select?: CoolDownSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoolDown
     */
    omit?: CoolDownOmit<ExtArgs> | null
    /**
     * The data used to create many CoolDowns.
     */
    data: CoolDownCreateManyInput | CoolDownCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoolDownIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoolDown update
   */
  export type CoolDownUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoolDown
     */
    select?: CoolDownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoolDown
     */
    omit?: CoolDownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoolDownInclude<ExtArgs> | null
    /**
     * The data needed to update a CoolDown.
     */
    data: XOR<CoolDownUpdateInput, CoolDownUncheckedUpdateInput>
    /**
     * Choose, which CoolDown to update.
     */
    where: CoolDownWhereUniqueInput
  }

  /**
   * CoolDown updateMany
   */
  export type CoolDownUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoolDowns.
     */
    data: XOR<CoolDownUpdateManyMutationInput, CoolDownUncheckedUpdateManyInput>
    /**
     * Filter which CoolDowns to update
     */
    where?: CoolDownWhereInput
  }

  /**
   * CoolDown updateManyAndReturn
   */
  export type CoolDownUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoolDown
     */
    select?: CoolDownSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoolDown
     */
    omit?: CoolDownOmit<ExtArgs> | null
    /**
     * The data used to update CoolDowns.
     */
    data: XOR<CoolDownUpdateManyMutationInput, CoolDownUncheckedUpdateManyInput>
    /**
     * Filter which CoolDowns to update
     */
    where?: CoolDownWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoolDownIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoolDown upsert
   */
  export type CoolDownUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoolDown
     */
    select?: CoolDownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoolDown
     */
    omit?: CoolDownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoolDownInclude<ExtArgs> | null
    /**
     * The filter to search for the CoolDown to update in case it exists.
     */
    where: CoolDownWhereUniqueInput
    /**
     * In case the CoolDown found by the `where` argument doesn't exist, create a new CoolDown with this data.
     */
    create: XOR<CoolDownCreateInput, CoolDownUncheckedCreateInput>
    /**
     * In case the CoolDown was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoolDownUpdateInput, CoolDownUncheckedUpdateInput>
  }

  /**
   * CoolDown delete
   */
  export type CoolDownDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoolDown
     */
    select?: CoolDownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoolDown
     */
    omit?: CoolDownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoolDownInclude<ExtArgs> | null
    /**
     * Filter which CoolDown to delete.
     */
    where: CoolDownWhereUniqueInput
  }

  /**
   * CoolDown deleteMany
   */
  export type CoolDownDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoolDowns to delete
     */
    where?: CoolDownWhereInput
  }

  /**
   * CoolDown without action
   */
  export type CoolDownDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoolDown
     */
    select?: CoolDownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoolDown
     */
    omit?: CoolDownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoolDownInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    privyUserId: string | null
    role: $Enums.UserRole | null
    email: string | null
    walletAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    privyUserId: string | null
    role: $Enums.UserRole | null
    email: string | null
    walletAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    privyUserId: number
    role: number
    email: number
    walletAddress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    privyUserId?: true
    role?: true
    email?: true
    walletAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    privyUserId?: true
    role?: true
    email?: true
    walletAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    privyUserId?: true
    role?: true
    email?: true
    walletAddress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    privyUserId: string
    role: $Enums.UserRole
    email: string | null
    walletAddress: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    privyUserId?: boolean
    role?: boolean
    email?: boolean
    walletAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    privyUserId?: boolean
    role?: boolean
    email?: boolean
    walletAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    privyUserId?: boolean
    role?: boolean
    email?: boolean
    walletAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    privyUserId?: boolean
    role?: boolean
    email?: boolean
    walletAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "privyUserId" | "role" | "email" | "walletAddress" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      privyUserId: string
      role: $Enums.UserRole
      email: string | null
      walletAddress: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly privyUserId: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly email: FieldRef<"User", 'String'>
    readonly walletAddress: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
  }


  /**
   * Model GameLog
   */

  export type AggregateGameLog = {
    _count: GameLogCountAggregateOutputType | null
    _min: GameLogMinAggregateOutputType | null
    _max: GameLogMaxAggregateOutputType | null
  }

  export type GameLogMinAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    type: string | null
    level: string | null
    message: string | null
    agentId: string | null
    gameId: string | null
  }

  export type GameLogMaxAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    type: string | null
    level: string | null
    message: string | null
    agentId: string | null
    gameId: string | null
  }

  export type GameLogCountAggregateOutputType = {
    id: number
    timestamp: number
    type: number
    level: number
    message: number
    data: number
    agentId: number
    gameId: number
    _all: number
  }


  export type GameLogMinAggregateInputType = {
    id?: true
    timestamp?: true
    type?: true
    level?: true
    message?: true
    agentId?: true
    gameId?: true
  }

  export type GameLogMaxAggregateInputType = {
    id?: true
    timestamp?: true
    type?: true
    level?: true
    message?: true
    agentId?: true
    gameId?: true
  }

  export type GameLogCountAggregateInputType = {
    id?: true
    timestamp?: true
    type?: true
    level?: true
    message?: true
    data?: true
    agentId?: true
    gameId?: true
    _all?: true
  }

  export type GameLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameLog to aggregate.
     */
    where?: GameLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameLogs to fetch.
     */
    orderBy?: GameLogOrderByWithRelationInput | GameLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameLogs
    **/
    _count?: true | GameLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameLogMaxAggregateInputType
  }

  export type GetGameLogAggregateType<T extends GameLogAggregateArgs> = {
        [P in keyof T & keyof AggregateGameLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameLog[P]>
      : GetScalarType<T[P], AggregateGameLog[P]>
  }




  export type GameLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameLogWhereInput
    orderBy?: GameLogOrderByWithAggregationInput | GameLogOrderByWithAggregationInput[]
    by: GameLogScalarFieldEnum[] | GameLogScalarFieldEnum
    having?: GameLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameLogCountAggregateInputType | true
    _min?: GameLogMinAggregateInputType
    _max?: GameLogMaxAggregateInputType
  }

  export type GameLogGroupByOutputType = {
    id: string
    timestamp: Date
    type: string
    level: string
    message: string
    data: JsonValue | null
    agentId: string | null
    gameId: string | null
    _count: GameLogCountAggregateOutputType | null
    _min: GameLogMinAggregateOutputType | null
    _max: GameLogMaxAggregateOutputType | null
  }

  type GetGameLogGroupByPayload<T extends GameLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameLogGroupByOutputType[P]>
            : GetScalarType<T[P], GameLogGroupByOutputType[P]>
        }
      >
    >


  export type GameLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    type?: boolean
    level?: boolean
    message?: boolean
    data?: boolean
    agentId?: boolean
    gameId?: boolean
    agent?: boolean | GameLog$agentArgs<ExtArgs>
    game?: boolean | GameLog$gameArgs<ExtArgs>
  }, ExtArgs["result"]["gameLog"]>

  export type GameLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    type?: boolean
    level?: boolean
    message?: boolean
    data?: boolean
    agentId?: boolean
    gameId?: boolean
    agent?: boolean | GameLog$agentArgs<ExtArgs>
    game?: boolean | GameLog$gameArgs<ExtArgs>
  }, ExtArgs["result"]["gameLog"]>

  export type GameLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    type?: boolean
    level?: boolean
    message?: boolean
    data?: boolean
    agentId?: boolean
    gameId?: boolean
    agent?: boolean | GameLog$agentArgs<ExtArgs>
    game?: boolean | GameLog$gameArgs<ExtArgs>
  }, ExtArgs["result"]["gameLog"]>

  export type GameLogSelectScalar = {
    id?: boolean
    timestamp?: boolean
    type?: boolean
    level?: boolean
    message?: boolean
    data?: boolean
    agentId?: boolean
    gameId?: boolean
  }

  export type GameLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timestamp" | "type" | "level" | "message" | "data" | "agentId" | "gameId", ExtArgs["result"]["gameLog"]>
  export type GameLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | GameLog$agentArgs<ExtArgs>
    game?: boolean | GameLog$gameArgs<ExtArgs>
  }
  export type GameLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | GameLog$agentArgs<ExtArgs>
    game?: boolean | GameLog$gameArgs<ExtArgs>
  }
  export type GameLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | GameLog$agentArgs<ExtArgs>
    game?: boolean | GameLog$gameArgs<ExtArgs>
  }

  export type $GameLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameLog"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs> | null
      game: Prisma.$GamePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timestamp: Date
      type: string
      level: string
      message: string
      data: Prisma.JsonValue | null
      agentId: string | null
      gameId: string | null
    }, ExtArgs["result"]["gameLog"]>
    composites: {}
  }

  type GameLogGetPayload<S extends boolean | null | undefined | GameLogDefaultArgs> = $Result.GetResult<Prisma.$GameLogPayload, S>

  type GameLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameLogCountAggregateInputType | true
    }

  export interface GameLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameLog'], meta: { name: 'GameLog' } }
    /**
     * Find zero or one GameLog that matches the filter.
     * @param {GameLogFindUniqueArgs} args - Arguments to find a GameLog
     * @example
     * // Get one GameLog
     * const gameLog = await prisma.gameLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameLogFindUniqueArgs>(args: SelectSubset<T, GameLogFindUniqueArgs<ExtArgs>>): Prisma__GameLogClient<$Result.GetResult<Prisma.$GameLogPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one GameLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameLogFindUniqueOrThrowArgs} args - Arguments to find a GameLog
     * @example
     * // Get one GameLog
     * const gameLog = await prisma.gameLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameLogFindUniqueOrThrowArgs>(args: SelectSubset<T, GameLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameLogClient<$Result.GetResult<Prisma.$GameLogPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first GameLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameLogFindFirstArgs} args - Arguments to find a GameLog
     * @example
     * // Get one GameLog
     * const gameLog = await prisma.gameLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameLogFindFirstArgs>(args?: SelectSubset<T, GameLogFindFirstArgs<ExtArgs>>): Prisma__GameLogClient<$Result.GetResult<Prisma.$GameLogPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first GameLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameLogFindFirstOrThrowArgs} args - Arguments to find a GameLog
     * @example
     * // Get one GameLog
     * const gameLog = await prisma.gameLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameLogFindFirstOrThrowArgs>(args?: SelectSubset<T, GameLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameLogClient<$Result.GetResult<Prisma.$GameLogPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more GameLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameLogs
     * const gameLogs = await prisma.gameLog.findMany()
     * 
     * // Get first 10 GameLogs
     * const gameLogs = await prisma.gameLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameLogWithIdOnly = await prisma.gameLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameLogFindManyArgs>(args?: SelectSubset<T, GameLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameLogPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a GameLog.
     * @param {GameLogCreateArgs} args - Arguments to create a GameLog.
     * @example
     * // Create one GameLog
     * const GameLog = await prisma.gameLog.create({
     *   data: {
     *     // ... data to create a GameLog
     *   }
     * })
     * 
     */
    create<T extends GameLogCreateArgs>(args: SelectSubset<T, GameLogCreateArgs<ExtArgs>>): Prisma__GameLogClient<$Result.GetResult<Prisma.$GameLogPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many GameLogs.
     * @param {GameLogCreateManyArgs} args - Arguments to create many GameLogs.
     * @example
     * // Create many GameLogs
     * const gameLog = await prisma.gameLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameLogCreateManyArgs>(args?: SelectSubset<T, GameLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameLogs and returns the data saved in the database.
     * @param {GameLogCreateManyAndReturnArgs} args - Arguments to create many GameLogs.
     * @example
     * // Create many GameLogs
     * const gameLog = await prisma.gameLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameLogs and only return the `id`
     * const gameLogWithIdOnly = await prisma.gameLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameLogCreateManyAndReturnArgs>(args?: SelectSubset<T, GameLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameLogPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a GameLog.
     * @param {GameLogDeleteArgs} args - Arguments to delete one GameLog.
     * @example
     * // Delete one GameLog
     * const GameLog = await prisma.gameLog.delete({
     *   where: {
     *     // ... filter to delete one GameLog
     *   }
     * })
     * 
     */
    delete<T extends GameLogDeleteArgs>(args: SelectSubset<T, GameLogDeleteArgs<ExtArgs>>): Prisma__GameLogClient<$Result.GetResult<Prisma.$GameLogPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one GameLog.
     * @param {GameLogUpdateArgs} args - Arguments to update one GameLog.
     * @example
     * // Update one GameLog
     * const gameLog = await prisma.gameLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameLogUpdateArgs>(args: SelectSubset<T, GameLogUpdateArgs<ExtArgs>>): Prisma__GameLogClient<$Result.GetResult<Prisma.$GameLogPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more GameLogs.
     * @param {GameLogDeleteManyArgs} args - Arguments to filter GameLogs to delete.
     * @example
     * // Delete a few GameLogs
     * const { count } = await prisma.gameLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameLogDeleteManyArgs>(args?: SelectSubset<T, GameLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameLogs
     * const gameLog = await prisma.gameLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameLogUpdateManyArgs>(args: SelectSubset<T, GameLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameLogs and returns the data updated in the database.
     * @param {GameLogUpdateManyAndReturnArgs} args - Arguments to update many GameLogs.
     * @example
     * // Update many GameLogs
     * const gameLog = await prisma.gameLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameLogs and only return the `id`
     * const gameLogWithIdOnly = await prisma.gameLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameLogUpdateManyAndReturnArgs>(args: SelectSubset<T, GameLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameLogPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one GameLog.
     * @param {GameLogUpsertArgs} args - Arguments to update or create a GameLog.
     * @example
     * // Update or create a GameLog
     * const gameLog = await prisma.gameLog.upsert({
     *   create: {
     *     // ... data to create a GameLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameLog we want to update
     *   }
     * })
     */
    upsert<T extends GameLogUpsertArgs>(args: SelectSubset<T, GameLogUpsertArgs<ExtArgs>>): Prisma__GameLogClient<$Result.GetResult<Prisma.$GameLogPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of GameLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameLogCountArgs} args - Arguments to filter GameLogs to count.
     * @example
     * // Count the number of GameLogs
     * const count = await prisma.gameLog.count({
     *   where: {
     *     // ... the filter for the GameLogs we want to count
     *   }
     * })
    **/
    count<T extends GameLogCountArgs>(
      args?: Subset<T, GameLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameLogAggregateArgs>(args: Subset<T, GameLogAggregateArgs>): Prisma.PrismaPromise<GetGameLogAggregateType<T>>

    /**
     * Group by GameLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameLogGroupByArgs['orderBy'] }
        : { orderBy?: GameLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameLog model
   */
  readonly fields: GameLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends GameLog$agentArgs<ExtArgs> = {}>(args?: Subset<T, GameLog$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    game<T extends GameLog$gameArgs<ExtArgs> = {}>(args?: Subset<T, GameLog$gameArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameLog model
   */ 
  interface GameLogFieldRefs {
    readonly id: FieldRef<"GameLog", 'String'>
    readonly timestamp: FieldRef<"GameLog", 'DateTime'>
    readonly type: FieldRef<"GameLog", 'String'>
    readonly level: FieldRef<"GameLog", 'String'>
    readonly message: FieldRef<"GameLog", 'String'>
    readonly data: FieldRef<"GameLog", 'Json'>
    readonly agentId: FieldRef<"GameLog", 'String'>
    readonly gameId: FieldRef<"GameLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GameLog findUnique
   */
  export type GameLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLog
     */
    select?: GameLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLog
     */
    omit?: GameLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLogInclude<ExtArgs> | null
    /**
     * Filter, which GameLog to fetch.
     */
    where: GameLogWhereUniqueInput
  }

  /**
   * GameLog findUniqueOrThrow
   */
  export type GameLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLog
     */
    select?: GameLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLog
     */
    omit?: GameLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLogInclude<ExtArgs> | null
    /**
     * Filter, which GameLog to fetch.
     */
    where: GameLogWhereUniqueInput
  }

  /**
   * GameLog findFirst
   */
  export type GameLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLog
     */
    select?: GameLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLog
     */
    omit?: GameLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLogInclude<ExtArgs> | null
    /**
     * Filter, which GameLog to fetch.
     */
    where?: GameLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameLogs to fetch.
     */
    orderBy?: GameLogOrderByWithRelationInput | GameLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameLogs.
     */
    cursor?: GameLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameLogs.
     */
    distinct?: GameLogScalarFieldEnum | GameLogScalarFieldEnum[]
  }

  /**
   * GameLog findFirstOrThrow
   */
  export type GameLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLog
     */
    select?: GameLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLog
     */
    omit?: GameLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLogInclude<ExtArgs> | null
    /**
     * Filter, which GameLog to fetch.
     */
    where?: GameLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameLogs to fetch.
     */
    orderBy?: GameLogOrderByWithRelationInput | GameLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameLogs.
     */
    cursor?: GameLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameLogs.
     */
    distinct?: GameLogScalarFieldEnum | GameLogScalarFieldEnum[]
  }

  /**
   * GameLog findMany
   */
  export type GameLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLog
     */
    select?: GameLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLog
     */
    omit?: GameLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLogInclude<ExtArgs> | null
    /**
     * Filter, which GameLogs to fetch.
     */
    where?: GameLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameLogs to fetch.
     */
    orderBy?: GameLogOrderByWithRelationInput | GameLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameLogs.
     */
    cursor?: GameLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameLogs.
     */
    skip?: number
    distinct?: GameLogScalarFieldEnum | GameLogScalarFieldEnum[]
  }

  /**
   * GameLog create
   */
  export type GameLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLog
     */
    select?: GameLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLog
     */
    omit?: GameLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLogInclude<ExtArgs> | null
    /**
     * The data needed to create a GameLog.
     */
    data: XOR<GameLogCreateInput, GameLogUncheckedCreateInput>
  }

  /**
   * GameLog createMany
   */
  export type GameLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameLogs.
     */
    data: GameLogCreateManyInput | GameLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameLog createManyAndReturn
   */
  export type GameLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLog
     */
    select?: GameLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameLog
     */
    omit?: GameLogOmit<ExtArgs> | null
    /**
     * The data used to create many GameLogs.
     */
    data: GameLogCreateManyInput | GameLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameLog update
   */
  export type GameLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLog
     */
    select?: GameLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLog
     */
    omit?: GameLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLogInclude<ExtArgs> | null
    /**
     * The data needed to update a GameLog.
     */
    data: XOR<GameLogUpdateInput, GameLogUncheckedUpdateInput>
    /**
     * Choose, which GameLog to update.
     */
    where: GameLogWhereUniqueInput
  }

  /**
   * GameLog updateMany
   */
  export type GameLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameLogs.
     */
    data: XOR<GameLogUpdateManyMutationInput, GameLogUncheckedUpdateManyInput>
    /**
     * Filter which GameLogs to update
     */
    where?: GameLogWhereInput
  }

  /**
   * GameLog updateManyAndReturn
   */
  export type GameLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLog
     */
    select?: GameLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameLog
     */
    omit?: GameLogOmit<ExtArgs> | null
    /**
     * The data used to update GameLogs.
     */
    data: XOR<GameLogUpdateManyMutationInput, GameLogUncheckedUpdateManyInput>
    /**
     * Filter which GameLogs to update
     */
    where?: GameLogWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameLog upsert
   */
  export type GameLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLog
     */
    select?: GameLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLog
     */
    omit?: GameLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLogInclude<ExtArgs> | null
    /**
     * The filter to search for the GameLog to update in case it exists.
     */
    where: GameLogWhereUniqueInput
    /**
     * In case the GameLog found by the `where` argument doesn't exist, create a new GameLog with this data.
     */
    create: XOR<GameLogCreateInput, GameLogUncheckedCreateInput>
    /**
     * In case the GameLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameLogUpdateInput, GameLogUncheckedUpdateInput>
  }

  /**
   * GameLog delete
   */
  export type GameLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLog
     */
    select?: GameLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLog
     */
    omit?: GameLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLogInclude<ExtArgs> | null
    /**
     * Filter which GameLog to delete.
     */
    where: GameLogWhereUniqueInput
  }

  /**
   * GameLog deleteMany
   */
  export type GameLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameLogs to delete
     */
    where?: GameLogWhereInput
  }

  /**
   * GameLog.agent
   */
  export type GameLog$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * GameLog.game
   */
  export type GameLog$gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
  }

  /**
   * GameLog without action
   */
  export type GameLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLog
     */
    select?: GameLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLog
     */
    omit?: GameLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const GameScalarFieldEnum: {
    id: 'id',
    onchainId: 'onchainId',
    authority: 'authority',
    pda: 'pda',
    tokenMint: 'tokenMint',
    rewardsVault: 'rewardsVault',
    mapDiameter: 'mapDiameter',
    isActive: 'isActive',
    lastUpdate: 'lastUpdate',
    bump: 'bump',
    dailyRewardTokens: 'dailyRewardTokens',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


  export const GameEventScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    eventType: 'eventType',
    initiatorId: 'initiatorId',
    targetId: 'targetId',
    message: 'message',
    metadata: 'metadata',
    gameId: 'gameId'
  };

  export type GameEventScalarFieldEnum = (typeof GameEventScalarFieldEnum)[keyof typeof GameEventScalarFieldEnum]


  export const AgentProfileScalarFieldEnum: {
    id: 'id',
    onchainId: 'onchainId',
    name: 'name',
    xHandle: 'xHandle',
    description: 'description',
    telegramLink: 'telegramLink',
    followers: 'followers',
    bio: 'bio',
    lore: 'lore',
    loreFulltext: 'loreFulltext',
    characteristics: 'characteristics',
    knowledge: 'knowledge',
    traits: 'traits',
    postExamples: 'postExamples'
  };

  export type AgentProfileScalarFieldEnum = (typeof AgentProfileScalarFieldEnum)[keyof typeof AgentProfileScalarFieldEnum]


  export const AgentScalarFieldEnum: {
    id: 'id',
    onchainId: 'onchainId',
    authority: 'authority',
    authorityAssociatedTokenAddress: 'authorityAssociatedTokenAddress',
    pda: 'pda',
    gameId: 'gameId',
    isAlive: 'isAlive',
    profileId: 'profileId',
    deathTimestamp: 'deathTimestamp',
    mapTileId: 'mapTileId',
    vault: 'vault'
  };

  export type AgentScalarFieldEnum = (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum]


  export const IgnoreScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    timestamp: 'timestamp',
    duration: 'duration',
    gameId: 'gameId',
    ignoredAgentId: 'ignoredAgentId'
  };

  export type IgnoreScalarFieldEnum = (typeof IgnoreScalarFieldEnum)[keyof typeof IgnoreScalarFieldEnum]


  export const MapTileScalarFieldEnum: {
    id: 'id',
    x: 'x',
    y: 'y',
    terrainType: 'terrainType',
    agentId: 'agentId'
  };

  export type MapTileScalarFieldEnum = (typeof MapTileScalarFieldEnum)[keyof typeof MapTileScalarFieldEnum]


  export const TweetScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    content: 'content',
    type: 'type',
    timestamp: 'timestamp',
    conversationId: 'conversationId'
  };

  export type TweetScalarFieldEnum = (typeof TweetScalarFieldEnum)[keyof typeof TweetScalarFieldEnum]


  export const AllianceScalarFieldEnum: {
    id: 'id',
    combinedTokens: 'combinedTokens',
    status: 'status',
    timestamp: 'timestamp',
    gameId: 'gameId',
    initiatorId: 'initiatorId',
    joinerId: 'joinerId',
    endedAt: 'endedAt'
  };

  export type AllianceScalarFieldEnum = (typeof AllianceScalarFieldEnum)[keyof typeof AllianceScalarFieldEnum]


  export const BattleScalarFieldEnum: {
    id: 'id',
    type: 'type',
    status: 'status',
    tokensStaked: 'tokensStaked',
    startTime: 'startTime',
    endTime: 'endTime',
    gameId: 'gameId',
    attackerId: 'attackerId',
    defenderId: 'defenderId',
    attackerAllyId: 'attackerAllyId',
    defenderAllyId: 'defenderAllyId',
    winnerId: 'winnerId'
  };

  export type BattleScalarFieldEnum = (typeof BattleScalarFieldEnum)[keyof typeof BattleScalarFieldEnum]


  export const InteractionScalarFieldEnum: {
    id: 'id',
    tweetId: 'tweetId',
    userId: 'userId',
    type: 'type',
    content: 'content',
    timestamp: 'timestamp',
    userMetrics: 'userMetrics'
  };

  export type InteractionScalarFieldEnum = (typeof InteractionScalarFieldEnum)[keyof typeof InteractionScalarFieldEnum]


  export const CoolDownScalarFieldEnum: {
    id: 'id',
    type: 'type',
    endsAt: 'endsAt',
    startsAt: 'startsAt',
    cooledAgentId: 'cooledAgentId',
    gameId: 'gameId'
  };

  export type CoolDownScalarFieldEnum = (typeof CoolDownScalarFieldEnum)[keyof typeof CoolDownScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    privyUserId: 'privyUserId',
    role: 'role',
    email: 'email',
    walletAddress: 'walletAddress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const GameLogScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    type: 'type',
    level: 'level',
    message: 'message',
    data: 'data',
    agentId: 'agentId',
    gameId: 'gameId'
  };

  export type GameLogScalarFieldEnum = (typeof GameLogScalarFieldEnum)[keyof typeof GameLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'EventType'
   */
  export type EnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType'>
    


  /**
   * Reference to a field of type 'EventType[]'
   */
  export type ListEnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'TerrainType'
   */
  export type EnumTerrainTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TerrainType'>
    


  /**
   * Reference to a field of type 'TerrainType[]'
   */
  export type ListEnumTerrainTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TerrainType[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'AllianceStatus'
   */
  export type EnumAllianceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AllianceStatus'>
    


  /**
   * Reference to a field of type 'AllianceStatus[]'
   */
  export type ListEnumAllianceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AllianceStatus[]'>
    


  /**
   * Reference to a field of type 'BattleType'
   */
  export type EnumBattleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BattleType'>
    


  /**
   * Reference to a field of type 'BattleType[]'
   */
  export type ListEnumBattleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BattleType[]'>
    


  /**
   * Reference to a field of type 'BattleStatus'
   */
  export type EnumBattleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BattleStatus'>
    


  /**
   * Reference to a field of type 'BattleStatus[]'
   */
  export type ListEnumBattleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BattleStatus[]'>
    


  /**
   * Reference to a field of type 'InteractionType'
   */
  export type EnumInteractionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InteractionType'>
    


  /**
   * Reference to a field of type 'InteractionType[]'
   */
  export type ListEnumInteractionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InteractionType[]'>
    


  /**
   * Reference to a field of type 'CooldownType'
   */
  export type EnumCooldownTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CooldownType'>
    


  /**
   * Reference to a field of type 'CooldownType[]'
   */
  export type ListEnumCooldownTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CooldownType[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    
  /**
   * Deep Input Types
   */


  export type GameWhereInput = {
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    id?: StringFilter<"Game"> | string
    onchainId?: IntFilter<"Game"> | number
    authority?: StringFilter<"Game"> | string
    pda?: StringFilter<"Game"> | string
    tokenMint?: StringFilter<"Game"> | string
    rewardsVault?: StringFilter<"Game"> | string
    mapDiameter?: IntFilter<"Game"> | number
    isActive?: BoolFilter<"Game"> | boolean
    lastUpdate?: DateTimeFilter<"Game"> | Date | string
    bump?: IntFilter<"Game"> | number
    dailyRewardTokens?: FloatFilter<"Game"> | number
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeFilter<"Game"> | Date | string
    agents?: AgentListRelationFilter
    alliances?: AllianceListRelationFilter
    battles?: BattleListRelationFilter
    coolDown?: CoolDownListRelationFilter
    Ignore?: IgnoreListRelationFilter
    GameLog?: GameLogListRelationFilter
    GameEvent?: GameEventListRelationFilter
  }

  export type GameOrderByWithRelationInput = {
    id?: SortOrder
    onchainId?: SortOrder
    authority?: SortOrder
    pda?: SortOrder
    tokenMint?: SortOrder
    rewardsVault?: SortOrder
    mapDiameter?: SortOrder
    isActive?: SortOrder
    lastUpdate?: SortOrder
    bump?: SortOrder
    dailyRewardTokens?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agents?: AgentOrderByRelationAggregateInput
    alliances?: AllianceOrderByRelationAggregateInput
    battles?: BattleOrderByRelationAggregateInput
    coolDown?: CoolDownOrderByRelationAggregateInput
    Ignore?: IgnoreOrderByRelationAggregateInput
    GameLog?: GameLogOrderByRelationAggregateInput
    GameEvent?: GameEventOrderByRelationAggregateInput
  }

  export type GameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    onchainId?: number
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    authority?: StringFilter<"Game"> | string
    pda?: StringFilter<"Game"> | string
    tokenMint?: StringFilter<"Game"> | string
    rewardsVault?: StringFilter<"Game"> | string
    mapDiameter?: IntFilter<"Game"> | number
    isActive?: BoolFilter<"Game"> | boolean
    lastUpdate?: DateTimeFilter<"Game"> | Date | string
    bump?: IntFilter<"Game"> | number
    dailyRewardTokens?: FloatFilter<"Game"> | number
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeFilter<"Game"> | Date | string
    agents?: AgentListRelationFilter
    alliances?: AllianceListRelationFilter
    battles?: BattleListRelationFilter
    coolDown?: CoolDownListRelationFilter
    Ignore?: IgnoreListRelationFilter
    GameLog?: GameLogListRelationFilter
    GameEvent?: GameEventListRelationFilter
  }, "id" | "onchainId">

  export type GameOrderByWithAggregationInput = {
    id?: SortOrder
    onchainId?: SortOrder
    authority?: SortOrder
    pda?: SortOrder
    tokenMint?: SortOrder
    rewardsVault?: SortOrder
    mapDiameter?: SortOrder
    isActive?: SortOrder
    lastUpdate?: SortOrder
    bump?: SortOrder
    dailyRewardTokens?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameCountOrderByAggregateInput
    _avg?: GameAvgOrderByAggregateInput
    _max?: GameMaxOrderByAggregateInput
    _min?: GameMinOrderByAggregateInput
    _sum?: GameSumOrderByAggregateInput
  }

  export type GameScalarWhereWithAggregatesInput = {
    AND?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    OR?: GameScalarWhereWithAggregatesInput[]
    NOT?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Game"> | string
    onchainId?: IntWithAggregatesFilter<"Game"> | number
    authority?: StringWithAggregatesFilter<"Game"> | string
    pda?: StringWithAggregatesFilter<"Game"> | string
    tokenMint?: StringWithAggregatesFilter<"Game"> | string
    rewardsVault?: StringWithAggregatesFilter<"Game"> | string
    mapDiameter?: IntWithAggregatesFilter<"Game"> | number
    isActive?: BoolWithAggregatesFilter<"Game"> | boolean
    lastUpdate?: DateTimeWithAggregatesFilter<"Game"> | Date | string
    bump?: IntWithAggregatesFilter<"Game"> | number
    dailyRewardTokens?: FloatWithAggregatesFilter<"Game"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
  }

  export type GameEventWhereInput = {
    AND?: GameEventWhereInput | GameEventWhereInput[]
    OR?: GameEventWhereInput[]
    NOT?: GameEventWhereInput | GameEventWhereInput[]
    id?: StringFilter<"GameEvent"> | string
    createdAt?: DateTimeFilter<"GameEvent"> | Date | string
    eventType?: EnumEventTypeFilter<"GameEvent"> | $Enums.EventType
    initiatorId?: StringFilter<"GameEvent"> | string
    targetId?: StringNullableFilter<"GameEvent"> | string | null
    message?: StringFilter<"GameEvent"> | string
    metadata?: JsonNullableFilter<"GameEvent">
    gameId?: StringFilter<"GameEvent"> | string
    initiator?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    target?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
  }

  export type GameEventOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    eventType?: SortOrder
    initiatorId?: SortOrder
    targetId?: SortOrderInput | SortOrder
    message?: SortOrder
    metadata?: SortOrderInput | SortOrder
    gameId?: SortOrder
    initiator?: AgentOrderByWithRelationInput
    target?: AgentOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
  }

  export type GameEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GameEventWhereInput | GameEventWhereInput[]
    OR?: GameEventWhereInput[]
    NOT?: GameEventWhereInput | GameEventWhereInput[]
    createdAt?: DateTimeFilter<"GameEvent"> | Date | string
    eventType?: EnumEventTypeFilter<"GameEvent"> | $Enums.EventType
    initiatorId?: StringFilter<"GameEvent"> | string
    targetId?: StringNullableFilter<"GameEvent"> | string | null
    message?: StringFilter<"GameEvent"> | string
    metadata?: JsonNullableFilter<"GameEvent">
    gameId?: StringFilter<"GameEvent"> | string
    initiator?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    target?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
  }, "id">

  export type GameEventOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    eventType?: SortOrder
    initiatorId?: SortOrder
    targetId?: SortOrderInput | SortOrder
    message?: SortOrder
    metadata?: SortOrderInput | SortOrder
    gameId?: SortOrder
    _count?: GameEventCountOrderByAggregateInput
    _max?: GameEventMaxOrderByAggregateInput
    _min?: GameEventMinOrderByAggregateInput
  }

  export type GameEventScalarWhereWithAggregatesInput = {
    AND?: GameEventScalarWhereWithAggregatesInput | GameEventScalarWhereWithAggregatesInput[]
    OR?: GameEventScalarWhereWithAggregatesInput[]
    NOT?: GameEventScalarWhereWithAggregatesInput | GameEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameEvent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GameEvent"> | Date | string
    eventType?: EnumEventTypeWithAggregatesFilter<"GameEvent"> | $Enums.EventType
    initiatorId?: StringWithAggregatesFilter<"GameEvent"> | string
    targetId?: StringNullableWithAggregatesFilter<"GameEvent"> | string | null
    message?: StringWithAggregatesFilter<"GameEvent"> | string
    metadata?: JsonNullableWithAggregatesFilter<"GameEvent">
    gameId?: StringWithAggregatesFilter<"GameEvent"> | string
  }

  export type AgentProfileWhereInput = {
    AND?: AgentProfileWhereInput | AgentProfileWhereInput[]
    OR?: AgentProfileWhereInput[]
    NOT?: AgentProfileWhereInput | AgentProfileWhereInput[]
    id?: StringFilter<"AgentProfile"> | string
    onchainId?: IntFilter<"AgentProfile"> | number
    name?: StringFilter<"AgentProfile"> | string
    xHandle?: StringFilter<"AgentProfile"> | string
    description?: StringFilter<"AgentProfile"> | string
    telegramLink?: StringFilter<"AgentProfile"> | string
    followers?: IntFilter<"AgentProfile"> | number
    bio?: StringNullableListFilter<"AgentProfile">
    lore?: StringNullableListFilter<"AgentProfile">
    loreFulltext?: StringFilter<"AgentProfile"> | string
    characteristics?: StringNullableListFilter<"AgentProfile">
    knowledge?: StringNullableListFilter<"AgentProfile">
    traits?: JsonFilter<"AgentProfile">
    postExamples?: StringNullableListFilter<"AgentProfile">
    agents?: AgentListRelationFilter
  }

  export type AgentProfileOrderByWithRelationInput = {
    id?: SortOrder
    onchainId?: SortOrder
    name?: SortOrder
    xHandle?: SortOrder
    description?: SortOrder
    telegramLink?: SortOrder
    followers?: SortOrder
    bio?: SortOrder
    lore?: SortOrder
    loreFulltext?: SortOrder
    characteristics?: SortOrder
    knowledge?: SortOrder
    traits?: SortOrder
    postExamples?: SortOrder
    agents?: AgentOrderByRelationAggregateInput
  }

  export type AgentProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    onchainId?: number
    xHandle?: string
    AND?: AgentProfileWhereInput | AgentProfileWhereInput[]
    OR?: AgentProfileWhereInput[]
    NOT?: AgentProfileWhereInput | AgentProfileWhereInput[]
    name?: StringFilter<"AgentProfile"> | string
    description?: StringFilter<"AgentProfile"> | string
    telegramLink?: StringFilter<"AgentProfile"> | string
    followers?: IntFilter<"AgentProfile"> | number
    bio?: StringNullableListFilter<"AgentProfile">
    lore?: StringNullableListFilter<"AgentProfile">
    loreFulltext?: StringFilter<"AgentProfile"> | string
    characteristics?: StringNullableListFilter<"AgentProfile">
    knowledge?: StringNullableListFilter<"AgentProfile">
    traits?: JsonFilter<"AgentProfile">
    postExamples?: StringNullableListFilter<"AgentProfile">
    agents?: AgentListRelationFilter
  }, "id" | "onchainId" | "xHandle">

  export type AgentProfileOrderByWithAggregationInput = {
    id?: SortOrder
    onchainId?: SortOrder
    name?: SortOrder
    xHandle?: SortOrder
    description?: SortOrder
    telegramLink?: SortOrder
    followers?: SortOrder
    bio?: SortOrder
    lore?: SortOrder
    loreFulltext?: SortOrder
    characteristics?: SortOrder
    knowledge?: SortOrder
    traits?: SortOrder
    postExamples?: SortOrder
    _count?: AgentProfileCountOrderByAggregateInput
    _avg?: AgentProfileAvgOrderByAggregateInput
    _max?: AgentProfileMaxOrderByAggregateInput
    _min?: AgentProfileMinOrderByAggregateInput
    _sum?: AgentProfileSumOrderByAggregateInput
  }

  export type AgentProfileScalarWhereWithAggregatesInput = {
    AND?: AgentProfileScalarWhereWithAggregatesInput | AgentProfileScalarWhereWithAggregatesInput[]
    OR?: AgentProfileScalarWhereWithAggregatesInput[]
    NOT?: AgentProfileScalarWhereWithAggregatesInput | AgentProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentProfile"> | string
    onchainId?: IntWithAggregatesFilter<"AgentProfile"> | number
    name?: StringWithAggregatesFilter<"AgentProfile"> | string
    xHandle?: StringWithAggregatesFilter<"AgentProfile"> | string
    description?: StringWithAggregatesFilter<"AgentProfile"> | string
    telegramLink?: StringWithAggregatesFilter<"AgentProfile"> | string
    followers?: IntWithAggregatesFilter<"AgentProfile"> | number
    bio?: StringNullableListFilter<"AgentProfile">
    lore?: StringNullableListFilter<"AgentProfile">
    loreFulltext?: StringWithAggregatesFilter<"AgentProfile"> | string
    characteristics?: StringNullableListFilter<"AgentProfile">
    knowledge?: StringNullableListFilter<"AgentProfile">
    traits?: JsonWithAggregatesFilter<"AgentProfile">
    postExamples?: StringNullableListFilter<"AgentProfile">
  }

  export type AgentWhereInput = {
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    id?: StringFilter<"Agent"> | string
    onchainId?: IntFilter<"Agent"> | number
    authority?: StringFilter<"Agent"> | string
    authorityAssociatedTokenAddress?: StringFilter<"Agent"> | string
    pda?: StringFilter<"Agent"> | string
    gameId?: StringFilter<"Agent"> | string
    isAlive?: BoolFilter<"Agent"> | boolean
    profileId?: StringFilter<"Agent"> | string
    deathTimestamp?: DateTimeNullableFilter<"Agent"> | Date | string | null
    mapTileId?: StringFilter<"Agent"> | string
    vault?: StringFilter<"Agent"> | string
    tweets?: TweetListRelationFilter
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    battlesAsAttacker?: BattleListRelationFilter
    battlesAsDefender?: BattleListRelationFilter
    battlesAsAttackerAlly?: BattleListRelationFilter
    battlesAsDefenderAlly?: BattleListRelationFilter
    wonBattles?: BattleListRelationFilter
    coolDown?: CoolDownListRelationFilter
    initiatedAlliances?: AllianceListRelationFilter
    joinedAlliances?: AllianceListRelationFilter
    profile?: XOR<AgentProfileScalarRelationFilter, AgentProfileWhereInput>
    mapTile?: XOR<MapTileScalarRelationFilter, MapTileWhereInput>
    ignoredBy?: IgnoreListRelationFilter
    ignoring?: IgnoreListRelationFilter
    GameLog?: GameLogListRelationFilter
    initiatedEvents?: GameEventListRelationFilter
    targetedEvents?: GameEventListRelationFilter
  }

  export type AgentOrderByWithRelationInput = {
    id?: SortOrder
    onchainId?: SortOrder
    authority?: SortOrder
    authorityAssociatedTokenAddress?: SortOrder
    pda?: SortOrder
    gameId?: SortOrder
    isAlive?: SortOrder
    profileId?: SortOrder
    deathTimestamp?: SortOrderInput | SortOrder
    mapTileId?: SortOrder
    vault?: SortOrder
    tweets?: TweetOrderByRelationAggregateInput
    game?: GameOrderByWithRelationInput
    battlesAsAttacker?: BattleOrderByRelationAggregateInput
    battlesAsDefender?: BattleOrderByRelationAggregateInput
    battlesAsAttackerAlly?: BattleOrderByRelationAggregateInput
    battlesAsDefenderAlly?: BattleOrderByRelationAggregateInput
    wonBattles?: BattleOrderByRelationAggregateInput
    coolDown?: CoolDownOrderByRelationAggregateInput
    initiatedAlliances?: AllianceOrderByRelationAggregateInput
    joinedAlliances?: AllianceOrderByRelationAggregateInput
    profile?: AgentProfileOrderByWithRelationInput
    mapTile?: MapTileOrderByWithRelationInput
    ignoredBy?: IgnoreOrderByRelationAggregateInput
    ignoring?: IgnoreOrderByRelationAggregateInput
    GameLog?: GameLogOrderByRelationAggregateInput
    initiatedEvents?: GameEventOrderByRelationAggregateInput
    targetedEvents?: GameEventOrderByRelationAggregateInput
  }

  export type AgentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    mapTileId?: string
    onchainId_gameId?: AgentOnchainIdGameIdCompoundUniqueInput
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    onchainId?: IntFilter<"Agent"> | number
    authority?: StringFilter<"Agent"> | string
    authorityAssociatedTokenAddress?: StringFilter<"Agent"> | string
    pda?: StringFilter<"Agent"> | string
    gameId?: StringFilter<"Agent"> | string
    isAlive?: BoolFilter<"Agent"> | boolean
    profileId?: StringFilter<"Agent"> | string
    deathTimestamp?: DateTimeNullableFilter<"Agent"> | Date | string | null
    vault?: StringFilter<"Agent"> | string
    tweets?: TweetListRelationFilter
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    battlesAsAttacker?: BattleListRelationFilter
    battlesAsDefender?: BattleListRelationFilter
    battlesAsAttackerAlly?: BattleListRelationFilter
    battlesAsDefenderAlly?: BattleListRelationFilter
    wonBattles?: BattleListRelationFilter
    coolDown?: CoolDownListRelationFilter
    initiatedAlliances?: AllianceListRelationFilter
    joinedAlliances?: AllianceListRelationFilter
    profile?: XOR<AgentProfileScalarRelationFilter, AgentProfileWhereInput>
    mapTile?: XOR<MapTileScalarRelationFilter, MapTileWhereInput>
    ignoredBy?: IgnoreListRelationFilter
    ignoring?: IgnoreListRelationFilter
    GameLog?: GameLogListRelationFilter
    initiatedEvents?: GameEventListRelationFilter
    targetedEvents?: GameEventListRelationFilter
  }, "id" | "mapTileId" | "onchainId_gameId">

  export type AgentOrderByWithAggregationInput = {
    id?: SortOrder
    onchainId?: SortOrder
    authority?: SortOrder
    authorityAssociatedTokenAddress?: SortOrder
    pda?: SortOrder
    gameId?: SortOrder
    isAlive?: SortOrder
    profileId?: SortOrder
    deathTimestamp?: SortOrderInput | SortOrder
    mapTileId?: SortOrder
    vault?: SortOrder
    _count?: AgentCountOrderByAggregateInput
    _avg?: AgentAvgOrderByAggregateInput
    _max?: AgentMaxOrderByAggregateInput
    _min?: AgentMinOrderByAggregateInput
    _sum?: AgentSumOrderByAggregateInput
  }

  export type AgentScalarWhereWithAggregatesInput = {
    AND?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    OR?: AgentScalarWhereWithAggregatesInput[]
    NOT?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agent"> | string
    onchainId?: IntWithAggregatesFilter<"Agent"> | number
    authority?: StringWithAggregatesFilter<"Agent"> | string
    authorityAssociatedTokenAddress?: StringWithAggregatesFilter<"Agent"> | string
    pda?: StringWithAggregatesFilter<"Agent"> | string
    gameId?: StringWithAggregatesFilter<"Agent"> | string
    isAlive?: BoolWithAggregatesFilter<"Agent"> | boolean
    profileId?: StringWithAggregatesFilter<"Agent"> | string
    deathTimestamp?: DateTimeNullableWithAggregatesFilter<"Agent"> | Date | string | null
    mapTileId?: StringWithAggregatesFilter<"Agent"> | string
    vault?: StringWithAggregatesFilter<"Agent"> | string
  }

  export type IgnoreWhereInput = {
    AND?: IgnoreWhereInput | IgnoreWhereInput[]
    OR?: IgnoreWhereInput[]
    NOT?: IgnoreWhereInput | IgnoreWhereInput[]
    id?: StringFilter<"Ignore"> | string
    agentId?: StringFilter<"Ignore"> | string
    timestamp?: DateTimeFilter<"Ignore"> | Date | string
    duration?: IntFilter<"Ignore"> | number
    gameId?: StringFilter<"Ignore"> | string
    ignoredAgentId?: StringFilter<"Ignore"> | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    ignoredAgent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type IgnoreOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    timestamp?: SortOrder
    duration?: SortOrder
    gameId?: SortOrder
    ignoredAgentId?: SortOrder
    agent?: AgentOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
    ignoredAgent?: AgentOrderByWithRelationInput
  }

  export type IgnoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agentId_ignoredAgentId?: IgnoreAgentIdIgnoredAgentIdCompoundUniqueInput
    AND?: IgnoreWhereInput | IgnoreWhereInput[]
    OR?: IgnoreWhereInput[]
    NOT?: IgnoreWhereInput | IgnoreWhereInput[]
    agentId?: StringFilter<"Ignore"> | string
    timestamp?: DateTimeFilter<"Ignore"> | Date | string
    duration?: IntFilter<"Ignore"> | number
    gameId?: StringFilter<"Ignore"> | string
    ignoredAgentId?: StringFilter<"Ignore"> | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    ignoredAgent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id" | "agentId_ignoredAgentId">

  export type IgnoreOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    timestamp?: SortOrder
    duration?: SortOrder
    gameId?: SortOrder
    ignoredAgentId?: SortOrder
    _count?: IgnoreCountOrderByAggregateInput
    _avg?: IgnoreAvgOrderByAggregateInput
    _max?: IgnoreMaxOrderByAggregateInput
    _min?: IgnoreMinOrderByAggregateInput
    _sum?: IgnoreSumOrderByAggregateInput
  }

  export type IgnoreScalarWhereWithAggregatesInput = {
    AND?: IgnoreScalarWhereWithAggregatesInput | IgnoreScalarWhereWithAggregatesInput[]
    OR?: IgnoreScalarWhereWithAggregatesInput[]
    NOT?: IgnoreScalarWhereWithAggregatesInput | IgnoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ignore"> | string
    agentId?: StringWithAggregatesFilter<"Ignore"> | string
    timestamp?: DateTimeWithAggregatesFilter<"Ignore"> | Date | string
    duration?: IntWithAggregatesFilter<"Ignore"> | number
    gameId?: StringWithAggregatesFilter<"Ignore"> | string
    ignoredAgentId?: StringWithAggregatesFilter<"Ignore"> | string
  }

  export type MapTileWhereInput = {
    AND?: MapTileWhereInput | MapTileWhereInput[]
    OR?: MapTileWhereInput[]
    NOT?: MapTileWhereInput | MapTileWhereInput[]
    id?: StringFilter<"MapTile"> | string
    x?: IntFilter<"MapTile"> | number
    y?: IntFilter<"MapTile"> | number
    terrainType?: EnumTerrainTypeFilter<"MapTile"> | $Enums.TerrainType
    agentId?: StringNullableFilter<"MapTile"> | string | null
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
  }

  export type MapTileOrderByWithRelationInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
    terrainType?: SortOrder
    agentId?: SortOrderInput | SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type MapTileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    x_y?: MapTileXYCompoundUniqueInput
    AND?: MapTileWhereInput | MapTileWhereInput[]
    OR?: MapTileWhereInput[]
    NOT?: MapTileWhereInput | MapTileWhereInput[]
    x?: IntFilter<"MapTile"> | number
    y?: IntFilter<"MapTile"> | number
    terrainType?: EnumTerrainTypeFilter<"MapTile"> | $Enums.TerrainType
    agentId?: StringNullableFilter<"MapTile"> | string | null
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
  }, "id" | "x_y">

  export type MapTileOrderByWithAggregationInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
    terrainType?: SortOrder
    agentId?: SortOrderInput | SortOrder
    _count?: MapTileCountOrderByAggregateInput
    _avg?: MapTileAvgOrderByAggregateInput
    _max?: MapTileMaxOrderByAggregateInput
    _min?: MapTileMinOrderByAggregateInput
    _sum?: MapTileSumOrderByAggregateInput
  }

  export type MapTileScalarWhereWithAggregatesInput = {
    AND?: MapTileScalarWhereWithAggregatesInput | MapTileScalarWhereWithAggregatesInput[]
    OR?: MapTileScalarWhereWithAggregatesInput[]
    NOT?: MapTileScalarWhereWithAggregatesInput | MapTileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MapTile"> | string
    x?: IntWithAggregatesFilter<"MapTile"> | number
    y?: IntWithAggregatesFilter<"MapTile"> | number
    terrainType?: EnumTerrainTypeWithAggregatesFilter<"MapTile"> | $Enums.TerrainType
    agentId?: StringNullableWithAggregatesFilter<"MapTile"> | string | null
  }

  export type TweetWhereInput = {
    AND?: TweetWhereInput | TweetWhereInput[]
    OR?: TweetWhereInput[]
    NOT?: TweetWhereInput | TweetWhereInput[]
    id?: StringFilter<"Tweet"> | string
    agentId?: StringFilter<"Tweet"> | string
    content?: StringFilter<"Tweet"> | string
    type?: StringFilter<"Tweet"> | string
    timestamp?: DateTimeFilter<"Tweet"> | Date | string
    conversationId?: StringNullableFilter<"Tweet"> | string | null
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    interactions?: InteractionListRelationFilter
  }

  export type TweetOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    conversationId?: SortOrderInput | SortOrder
    agent?: AgentOrderByWithRelationInput
    interactions?: InteractionOrderByRelationAggregateInput
  }

  export type TweetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TweetWhereInput | TweetWhereInput[]
    OR?: TweetWhereInput[]
    NOT?: TweetWhereInput | TweetWhereInput[]
    agentId?: StringFilter<"Tweet"> | string
    content?: StringFilter<"Tweet"> | string
    type?: StringFilter<"Tweet"> | string
    timestamp?: DateTimeFilter<"Tweet"> | Date | string
    conversationId?: StringNullableFilter<"Tweet"> | string | null
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    interactions?: InteractionListRelationFilter
  }, "id">

  export type TweetOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    conversationId?: SortOrderInput | SortOrder
    _count?: TweetCountOrderByAggregateInput
    _max?: TweetMaxOrderByAggregateInput
    _min?: TweetMinOrderByAggregateInput
  }

  export type TweetScalarWhereWithAggregatesInput = {
    AND?: TweetScalarWhereWithAggregatesInput | TweetScalarWhereWithAggregatesInput[]
    OR?: TweetScalarWhereWithAggregatesInput[]
    NOT?: TweetScalarWhereWithAggregatesInput | TweetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tweet"> | string
    agentId?: StringWithAggregatesFilter<"Tweet"> | string
    content?: StringWithAggregatesFilter<"Tweet"> | string
    type?: StringWithAggregatesFilter<"Tweet"> | string
    timestamp?: DateTimeWithAggregatesFilter<"Tweet"> | Date | string
    conversationId?: StringNullableWithAggregatesFilter<"Tweet"> | string | null
  }

  export type AllianceWhereInput = {
    AND?: AllianceWhereInput | AllianceWhereInput[]
    OR?: AllianceWhereInput[]
    NOT?: AllianceWhereInput | AllianceWhereInput[]
    id?: StringFilter<"Alliance"> | string
    combinedTokens?: BigIntNullableFilter<"Alliance"> | bigint | number | null
    status?: EnumAllianceStatusFilter<"Alliance"> | $Enums.AllianceStatus
    timestamp?: DateTimeFilter<"Alliance"> | Date | string
    gameId?: StringFilter<"Alliance"> | string
    initiatorId?: StringFilter<"Alliance"> | string
    joinerId?: StringFilter<"Alliance"> | string
    endedAt?: DateTimeNullableFilter<"Alliance"> | Date | string | null
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    initiator?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    joiner?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type AllianceOrderByWithRelationInput = {
    id?: SortOrder
    combinedTokens?: SortOrderInput | SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    gameId?: SortOrder
    initiatorId?: SortOrder
    joinerId?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    game?: GameOrderByWithRelationInput
    initiator?: AgentOrderByWithRelationInput
    joiner?: AgentOrderByWithRelationInput
  }

  export type AllianceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    initiatorId_joinerId?: AllianceInitiatorIdJoinerIdCompoundUniqueInput
    AND?: AllianceWhereInput | AllianceWhereInput[]
    OR?: AllianceWhereInput[]
    NOT?: AllianceWhereInput | AllianceWhereInput[]
    combinedTokens?: BigIntNullableFilter<"Alliance"> | bigint | number | null
    status?: EnumAllianceStatusFilter<"Alliance"> | $Enums.AllianceStatus
    timestamp?: DateTimeFilter<"Alliance"> | Date | string
    gameId?: StringFilter<"Alliance"> | string
    initiatorId?: StringFilter<"Alliance"> | string
    joinerId?: StringFilter<"Alliance"> | string
    endedAt?: DateTimeNullableFilter<"Alliance"> | Date | string | null
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    initiator?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    joiner?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id" | "initiatorId_joinerId">

  export type AllianceOrderByWithAggregationInput = {
    id?: SortOrder
    combinedTokens?: SortOrderInput | SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    gameId?: SortOrder
    initiatorId?: SortOrder
    joinerId?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    _count?: AllianceCountOrderByAggregateInput
    _avg?: AllianceAvgOrderByAggregateInput
    _max?: AllianceMaxOrderByAggregateInput
    _min?: AllianceMinOrderByAggregateInput
    _sum?: AllianceSumOrderByAggregateInput
  }

  export type AllianceScalarWhereWithAggregatesInput = {
    AND?: AllianceScalarWhereWithAggregatesInput | AllianceScalarWhereWithAggregatesInput[]
    OR?: AllianceScalarWhereWithAggregatesInput[]
    NOT?: AllianceScalarWhereWithAggregatesInput | AllianceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alliance"> | string
    combinedTokens?: BigIntNullableWithAggregatesFilter<"Alliance"> | bigint | number | null
    status?: EnumAllianceStatusWithAggregatesFilter<"Alliance"> | $Enums.AllianceStatus
    timestamp?: DateTimeWithAggregatesFilter<"Alliance"> | Date | string
    gameId?: StringWithAggregatesFilter<"Alliance"> | string
    initiatorId?: StringWithAggregatesFilter<"Alliance"> | string
    joinerId?: StringWithAggregatesFilter<"Alliance"> | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"Alliance"> | Date | string | null
  }

  export type BattleWhereInput = {
    AND?: BattleWhereInput | BattleWhereInput[]
    OR?: BattleWhereInput[]
    NOT?: BattleWhereInput | BattleWhereInput[]
    id?: StringFilter<"Battle"> | string
    type?: EnumBattleTypeFilter<"Battle"> | $Enums.BattleType
    status?: EnumBattleStatusFilter<"Battle"> | $Enums.BattleStatus
    tokensStaked?: BigIntFilter<"Battle"> | bigint | number
    startTime?: DateTimeFilter<"Battle"> | Date | string
    endTime?: DateTimeNullableFilter<"Battle"> | Date | string | null
    gameId?: StringFilter<"Battle"> | string
    attackerId?: StringFilter<"Battle"> | string
    defenderId?: StringFilter<"Battle"> | string
    attackerAllyId?: StringNullableFilter<"Battle"> | string | null
    defenderAllyId?: StringNullableFilter<"Battle"> | string | null
    winnerId?: StringNullableFilter<"Battle"> | string | null
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    attacker?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    defender?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    attackerAlly?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    defenderAlly?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    winner?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
  }

  export type BattleOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    tokensStaked?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    gameId?: SortOrder
    attackerId?: SortOrder
    defenderId?: SortOrder
    attackerAllyId?: SortOrderInput | SortOrder
    defenderAllyId?: SortOrderInput | SortOrder
    winnerId?: SortOrderInput | SortOrder
    game?: GameOrderByWithRelationInput
    attacker?: AgentOrderByWithRelationInput
    defender?: AgentOrderByWithRelationInput
    attackerAlly?: AgentOrderByWithRelationInput
    defenderAlly?: AgentOrderByWithRelationInput
    winner?: AgentOrderByWithRelationInput
  }

  export type BattleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    startTime_type?: BattleStartTimeTypeCompoundUniqueInput
    AND?: BattleWhereInput | BattleWhereInput[]
    OR?: BattleWhereInput[]
    NOT?: BattleWhereInput | BattleWhereInput[]
    type?: EnumBattleTypeFilter<"Battle"> | $Enums.BattleType
    status?: EnumBattleStatusFilter<"Battle"> | $Enums.BattleStatus
    tokensStaked?: BigIntFilter<"Battle"> | bigint | number
    startTime?: DateTimeFilter<"Battle"> | Date | string
    endTime?: DateTimeNullableFilter<"Battle"> | Date | string | null
    gameId?: StringFilter<"Battle"> | string
    attackerId?: StringFilter<"Battle"> | string
    defenderId?: StringFilter<"Battle"> | string
    attackerAllyId?: StringNullableFilter<"Battle"> | string | null
    defenderAllyId?: StringNullableFilter<"Battle"> | string | null
    winnerId?: StringNullableFilter<"Battle"> | string | null
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    attacker?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    defender?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    attackerAlly?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    defenderAlly?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    winner?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
  }, "id" | "startTime_type">

  export type BattleOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    tokensStaked?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    gameId?: SortOrder
    attackerId?: SortOrder
    defenderId?: SortOrder
    attackerAllyId?: SortOrderInput | SortOrder
    defenderAllyId?: SortOrderInput | SortOrder
    winnerId?: SortOrderInput | SortOrder
    _count?: BattleCountOrderByAggregateInput
    _avg?: BattleAvgOrderByAggregateInput
    _max?: BattleMaxOrderByAggregateInput
    _min?: BattleMinOrderByAggregateInput
    _sum?: BattleSumOrderByAggregateInput
  }

  export type BattleScalarWhereWithAggregatesInput = {
    AND?: BattleScalarWhereWithAggregatesInput | BattleScalarWhereWithAggregatesInput[]
    OR?: BattleScalarWhereWithAggregatesInput[]
    NOT?: BattleScalarWhereWithAggregatesInput | BattleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Battle"> | string
    type?: EnumBattleTypeWithAggregatesFilter<"Battle"> | $Enums.BattleType
    status?: EnumBattleStatusWithAggregatesFilter<"Battle"> | $Enums.BattleStatus
    tokensStaked?: BigIntWithAggregatesFilter<"Battle"> | bigint | number
    startTime?: DateTimeWithAggregatesFilter<"Battle"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"Battle"> | Date | string | null
    gameId?: StringWithAggregatesFilter<"Battle"> | string
    attackerId?: StringWithAggregatesFilter<"Battle"> | string
    defenderId?: StringWithAggregatesFilter<"Battle"> | string
    attackerAllyId?: StringNullableWithAggregatesFilter<"Battle"> | string | null
    defenderAllyId?: StringNullableWithAggregatesFilter<"Battle"> | string | null
    winnerId?: StringNullableWithAggregatesFilter<"Battle"> | string | null
  }

  export type InteractionWhereInput = {
    AND?: InteractionWhereInput | InteractionWhereInput[]
    OR?: InteractionWhereInput[]
    NOT?: InteractionWhereInput | InteractionWhereInput[]
    id?: StringFilter<"Interaction"> | string
    tweetId?: StringFilter<"Interaction"> | string
    userId?: StringFilter<"Interaction"> | string
    type?: EnumInteractionTypeFilter<"Interaction"> | $Enums.InteractionType
    content?: StringFilter<"Interaction"> | string
    timestamp?: DateTimeFilter<"Interaction"> | Date | string
    userMetrics?: JsonFilter<"Interaction">
    tweet?: XOR<TweetScalarRelationFilter, TweetWhereInput>
  }

  export type InteractionOrderByWithRelationInput = {
    id?: SortOrder
    tweetId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    userMetrics?: SortOrder
    tweet?: TweetOrderByWithRelationInput
  }

  export type InteractionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InteractionWhereInput | InteractionWhereInput[]
    OR?: InteractionWhereInput[]
    NOT?: InteractionWhereInput | InteractionWhereInput[]
    tweetId?: StringFilter<"Interaction"> | string
    userId?: StringFilter<"Interaction"> | string
    type?: EnumInteractionTypeFilter<"Interaction"> | $Enums.InteractionType
    content?: StringFilter<"Interaction"> | string
    timestamp?: DateTimeFilter<"Interaction"> | Date | string
    userMetrics?: JsonFilter<"Interaction">
    tweet?: XOR<TweetScalarRelationFilter, TweetWhereInput>
  }, "id">

  export type InteractionOrderByWithAggregationInput = {
    id?: SortOrder
    tweetId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    userMetrics?: SortOrder
    _count?: InteractionCountOrderByAggregateInput
    _max?: InteractionMaxOrderByAggregateInput
    _min?: InteractionMinOrderByAggregateInput
  }

  export type InteractionScalarWhereWithAggregatesInput = {
    AND?: InteractionScalarWhereWithAggregatesInput | InteractionScalarWhereWithAggregatesInput[]
    OR?: InteractionScalarWhereWithAggregatesInput[]
    NOT?: InteractionScalarWhereWithAggregatesInput | InteractionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Interaction"> | string
    tweetId?: StringWithAggregatesFilter<"Interaction"> | string
    userId?: StringWithAggregatesFilter<"Interaction"> | string
    type?: EnumInteractionTypeWithAggregatesFilter<"Interaction"> | $Enums.InteractionType
    content?: StringWithAggregatesFilter<"Interaction"> | string
    timestamp?: DateTimeWithAggregatesFilter<"Interaction"> | Date | string
    userMetrics?: JsonWithAggregatesFilter<"Interaction">
  }

  export type CoolDownWhereInput = {
    AND?: CoolDownWhereInput | CoolDownWhereInput[]
    OR?: CoolDownWhereInput[]
    NOT?: CoolDownWhereInput | CoolDownWhereInput[]
    id?: StringFilter<"CoolDown"> | string
    type?: EnumCooldownTypeFilter<"CoolDown"> | $Enums.CooldownType
    endsAt?: DateTimeFilter<"CoolDown"> | Date | string
    startsAt?: DateTimeNullableFilter<"CoolDown"> | Date | string | null
    cooledAgentId?: StringFilter<"CoolDown"> | string
    gameId?: StringFilter<"CoolDown"> | string
    cooledAgent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
  }

  export type CoolDownOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    endsAt?: SortOrder
    startsAt?: SortOrderInput | SortOrder
    cooledAgentId?: SortOrder
    gameId?: SortOrder
    cooledAgent?: AgentOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
  }

  export type CoolDownWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CoolDownWhereInput | CoolDownWhereInput[]
    OR?: CoolDownWhereInput[]
    NOT?: CoolDownWhereInput | CoolDownWhereInput[]
    type?: EnumCooldownTypeFilter<"CoolDown"> | $Enums.CooldownType
    endsAt?: DateTimeFilter<"CoolDown"> | Date | string
    startsAt?: DateTimeNullableFilter<"CoolDown"> | Date | string | null
    cooledAgentId?: StringFilter<"CoolDown"> | string
    gameId?: StringFilter<"CoolDown"> | string
    cooledAgent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
  }, "id">

  export type CoolDownOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    endsAt?: SortOrder
    startsAt?: SortOrderInput | SortOrder
    cooledAgentId?: SortOrder
    gameId?: SortOrder
    _count?: CoolDownCountOrderByAggregateInput
    _max?: CoolDownMaxOrderByAggregateInput
    _min?: CoolDownMinOrderByAggregateInput
  }

  export type CoolDownScalarWhereWithAggregatesInput = {
    AND?: CoolDownScalarWhereWithAggregatesInput | CoolDownScalarWhereWithAggregatesInput[]
    OR?: CoolDownScalarWhereWithAggregatesInput[]
    NOT?: CoolDownScalarWhereWithAggregatesInput | CoolDownScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CoolDown"> | string
    type?: EnumCooldownTypeWithAggregatesFilter<"CoolDown"> | $Enums.CooldownType
    endsAt?: DateTimeWithAggregatesFilter<"CoolDown"> | Date | string
    startsAt?: DateTimeNullableWithAggregatesFilter<"CoolDown"> | Date | string | null
    cooledAgentId?: StringWithAggregatesFilter<"CoolDown"> | string
    gameId?: StringWithAggregatesFilter<"CoolDown"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    privyUserId?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    email?: StringNullableFilter<"User"> | string | null
    walletAddress?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    privyUserId?: SortOrder
    role?: SortOrder
    email?: SortOrderInput | SortOrder
    walletAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    privyUserId?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    walletAddress?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }, "id" | "privyUserId" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    privyUserId?: SortOrder
    role?: SortOrder
    email?: SortOrderInput | SortOrder
    walletAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    privyUserId?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    walletAddress?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type GameLogWhereInput = {
    AND?: GameLogWhereInput | GameLogWhereInput[]
    OR?: GameLogWhereInput[]
    NOT?: GameLogWhereInput | GameLogWhereInput[]
    id?: StringFilter<"GameLog"> | string
    timestamp?: DateTimeFilter<"GameLog"> | Date | string
    type?: StringFilter<"GameLog"> | string
    level?: StringFilter<"GameLog"> | string
    message?: StringFilter<"GameLog"> | string
    data?: JsonNullableFilter<"GameLog">
    agentId?: StringNullableFilter<"GameLog"> | string | null
    gameId?: StringNullableFilter<"GameLog"> | string | null
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    game?: XOR<GameNullableScalarRelationFilter, GameWhereInput> | null
  }

  export type GameLogOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    level?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    gameId?: SortOrderInput | SortOrder
    agent?: AgentOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
  }

  export type GameLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GameLogWhereInput | GameLogWhereInput[]
    OR?: GameLogWhereInput[]
    NOT?: GameLogWhereInput | GameLogWhereInput[]
    timestamp?: DateTimeFilter<"GameLog"> | Date | string
    type?: StringFilter<"GameLog"> | string
    level?: StringFilter<"GameLog"> | string
    message?: StringFilter<"GameLog"> | string
    data?: JsonNullableFilter<"GameLog">
    agentId?: StringNullableFilter<"GameLog"> | string | null
    gameId?: StringNullableFilter<"GameLog"> | string | null
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    game?: XOR<GameNullableScalarRelationFilter, GameWhereInput> | null
  }, "id">

  export type GameLogOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    level?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    gameId?: SortOrderInput | SortOrder
    _count?: GameLogCountOrderByAggregateInput
    _max?: GameLogMaxOrderByAggregateInput
    _min?: GameLogMinOrderByAggregateInput
  }

  export type GameLogScalarWhereWithAggregatesInput = {
    AND?: GameLogScalarWhereWithAggregatesInput | GameLogScalarWhereWithAggregatesInput[]
    OR?: GameLogScalarWhereWithAggregatesInput[]
    NOT?: GameLogScalarWhereWithAggregatesInput | GameLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"GameLog"> | Date | string
    type?: StringWithAggregatesFilter<"GameLog"> | string
    level?: StringWithAggregatesFilter<"GameLog"> | string
    message?: StringWithAggregatesFilter<"GameLog"> | string
    data?: JsonNullableWithAggregatesFilter<"GameLog">
    agentId?: StringNullableWithAggregatesFilter<"GameLog"> | string | null
    gameId?: StringNullableWithAggregatesFilter<"GameLog"> | string | null
  }

  export type GameCreateInput = {
    id?: string
    onchainId: number
    authority: string
    pda: string
    tokenMint: string
    rewardsVault: string
    mapDiameter: number
    isActive?: boolean
    lastUpdate?: Date | string
    bump: number
    dailyRewardTokens: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutGameInput
    alliances?: AllianceCreateNestedManyWithoutGameInput
    battles?: BattleCreateNestedManyWithoutGameInput
    coolDown?: CoolDownCreateNestedManyWithoutGameInput
    Ignore?: IgnoreCreateNestedManyWithoutGameInput
    GameLog?: GameLogCreateNestedManyWithoutGameInput
    GameEvent?: GameEventCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateInput = {
    id?: string
    onchainId: number
    authority: string
    pda: string
    tokenMint: string
    rewardsVault: string
    mapDiameter: number
    isActive?: boolean
    lastUpdate?: Date | string
    bump: number
    dailyRewardTokens: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutGameInput
    alliances?: AllianceUncheckedCreateNestedManyWithoutGameInput
    battles?: BattleUncheckedCreateNestedManyWithoutGameInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutGameInput
    Ignore?: IgnoreUncheckedCreateNestedManyWithoutGameInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutGameInput
    GameEvent?: GameEventUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    tokenMint?: StringFieldUpdateOperationsInput | string
    rewardsVault?: StringFieldUpdateOperationsInput | string
    mapDiameter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bump?: IntFieldUpdateOperationsInput | number
    dailyRewardTokens?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutGameNestedInput
    alliances?: AllianceUpdateManyWithoutGameNestedInput
    battles?: BattleUpdateManyWithoutGameNestedInput
    coolDown?: CoolDownUpdateManyWithoutGameNestedInput
    Ignore?: IgnoreUpdateManyWithoutGameNestedInput
    GameLog?: GameLogUpdateManyWithoutGameNestedInput
    GameEvent?: GameEventUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    tokenMint?: StringFieldUpdateOperationsInput | string
    rewardsVault?: StringFieldUpdateOperationsInput | string
    mapDiameter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bump?: IntFieldUpdateOperationsInput | number
    dailyRewardTokens?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutGameNestedInput
    alliances?: AllianceUncheckedUpdateManyWithoutGameNestedInput
    battles?: BattleUncheckedUpdateManyWithoutGameNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutGameNestedInput
    Ignore?: IgnoreUncheckedUpdateManyWithoutGameNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutGameNestedInput
    GameEvent?: GameEventUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameCreateManyInput = {
    id?: string
    onchainId: number
    authority: string
    pda: string
    tokenMint: string
    rewardsVault: string
    mapDiameter: number
    isActive?: boolean
    lastUpdate?: Date | string
    bump: number
    dailyRewardTokens: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    tokenMint?: StringFieldUpdateOperationsInput | string
    rewardsVault?: StringFieldUpdateOperationsInput | string
    mapDiameter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bump?: IntFieldUpdateOperationsInput | number
    dailyRewardTokens?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    tokenMint?: StringFieldUpdateOperationsInput | string
    rewardsVault?: StringFieldUpdateOperationsInput | string
    mapDiameter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bump?: IntFieldUpdateOperationsInput | number
    dailyRewardTokens?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameEventCreateInput = {
    id?: string
    createdAt?: Date | string
    eventType: $Enums.EventType
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiator: AgentCreateNestedOneWithoutInitiatedEventsInput
    target?: AgentCreateNestedOneWithoutTargetedEventsInput
    game: GameCreateNestedOneWithoutGameEventInput
  }

  export type GameEventUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    eventType: $Enums.EventType
    initiatorId: string
    targetId?: string | null
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type GameEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiator?: AgentUpdateOneRequiredWithoutInitiatedEventsNestedInput
    target?: AgentUpdateOneWithoutTargetedEventsNestedInput
    game?: GameUpdateOneRequiredWithoutGameEventNestedInput
  }

  export type GameEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    initiatorId?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type GameEventCreateManyInput = {
    id?: string
    createdAt?: Date | string
    eventType: $Enums.EventType
    initiatorId: string
    targetId?: string | null
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type GameEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GameEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    initiatorId?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AgentProfileCreateInput = {
    id?: string
    onchainId: number
    name: string
    xHandle: string
    description: string
    telegramLink: string
    followers?: number
    bio?: AgentProfileCreatebioInput | string[]
    lore?: AgentProfileCreateloreInput | string[]
    loreFulltext: string
    characteristics?: AgentProfileCreatecharacteristicsInput | string[]
    knowledge?: AgentProfileCreateknowledgeInput | string[]
    traits: JsonNullValueInput | InputJsonValue
    postExamples?: AgentProfileCreatepostExamplesInput | string[]
    agents?: AgentCreateNestedManyWithoutProfileInput
  }

  export type AgentProfileUncheckedCreateInput = {
    id?: string
    onchainId: number
    name: string
    xHandle: string
    description: string
    telegramLink: string
    followers?: number
    bio?: AgentProfileCreatebioInput | string[]
    lore?: AgentProfileCreateloreInput | string[]
    loreFulltext: string
    characteristics?: AgentProfileCreatecharacteristicsInput | string[]
    knowledge?: AgentProfileCreateknowledgeInput | string[]
    traits: JsonNullValueInput | InputJsonValue
    postExamples?: AgentProfileCreatepostExamplesInput | string[]
    agents?: AgentUncheckedCreateNestedManyWithoutProfileInput
  }

  export type AgentProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    xHandle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    followers?: IntFieldUpdateOperationsInput | number
    bio?: AgentProfileUpdatebioInput | string[]
    lore?: AgentProfileUpdateloreInput | string[]
    loreFulltext?: StringFieldUpdateOperationsInput | string
    characteristics?: AgentProfileUpdatecharacteristicsInput | string[]
    knowledge?: AgentProfileUpdateknowledgeInput | string[]
    traits?: JsonNullValueInput | InputJsonValue
    postExamples?: AgentProfileUpdatepostExamplesInput | string[]
    agents?: AgentUpdateManyWithoutProfileNestedInput
  }

  export type AgentProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    xHandle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    followers?: IntFieldUpdateOperationsInput | number
    bio?: AgentProfileUpdatebioInput | string[]
    lore?: AgentProfileUpdateloreInput | string[]
    loreFulltext?: StringFieldUpdateOperationsInput | string
    characteristics?: AgentProfileUpdatecharacteristicsInput | string[]
    knowledge?: AgentProfileUpdateknowledgeInput | string[]
    traits?: JsonNullValueInput | InputJsonValue
    postExamples?: AgentProfileUpdatepostExamplesInput | string[]
    agents?: AgentUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type AgentProfileCreateManyInput = {
    id?: string
    onchainId: number
    name: string
    xHandle: string
    description: string
    telegramLink: string
    followers?: number
    bio?: AgentProfileCreatebioInput | string[]
    lore?: AgentProfileCreateloreInput | string[]
    loreFulltext: string
    characteristics?: AgentProfileCreatecharacteristicsInput | string[]
    knowledge?: AgentProfileCreateknowledgeInput | string[]
    traits: JsonNullValueInput | InputJsonValue
    postExamples?: AgentProfileCreatepostExamplesInput | string[]
  }

  export type AgentProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    xHandle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    followers?: IntFieldUpdateOperationsInput | number
    bio?: AgentProfileUpdatebioInput | string[]
    lore?: AgentProfileUpdateloreInput | string[]
    loreFulltext?: StringFieldUpdateOperationsInput | string
    characteristics?: AgentProfileUpdatecharacteristicsInput | string[]
    knowledge?: AgentProfileUpdateknowledgeInput | string[]
    traits?: JsonNullValueInput | InputJsonValue
    postExamples?: AgentProfileUpdatepostExamplesInput | string[]
  }

  export type AgentProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    xHandle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    followers?: IntFieldUpdateOperationsInput | number
    bio?: AgentProfileUpdatebioInput | string[]
    lore?: AgentProfileUpdateloreInput | string[]
    loreFulltext?: StringFieldUpdateOperationsInput | string
    characteristics?: AgentProfileUpdatecharacteristicsInput | string[]
    knowledge?: AgentProfileUpdateknowledgeInput | string[]
    traits?: JsonNullValueInput | InputJsonValue
    postExamples?: AgentProfileUpdatepostExamplesInput | string[]
  }

  export type AgentCreateInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    isAlive?: boolean
    deathTimestamp?: Date | string | null
    vault: string
    tweets?: TweetCreateNestedManyWithoutAgentInput
    game: GameCreateNestedOneWithoutAgentsInput
    battlesAsAttacker?: BattleCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceCreateNestedManyWithoutJoinerInput
    profile: AgentProfileCreateNestedOneWithoutAgentsInput
    mapTile: MapTileCreateNestedOneWithoutAgentInput
    ignoredBy?: IgnoreCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventCreateNestedManyWithoutTargetInput
  }

  export type AgentUncheckedCreateInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    gameId: string
    isAlive?: boolean
    profileId: string
    deathTimestamp?: Date | string | null
    mapTileId: string
    vault: string
    tweets?: TweetUncheckedCreateNestedManyWithoutAgentInput
    battlesAsAttacker?: BattleUncheckedCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleUncheckedCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleUncheckedCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleUncheckedCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleUncheckedCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceUncheckedCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceUncheckedCreateNestedManyWithoutJoinerInput
    ignoredBy?: IgnoreUncheckedCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreUncheckedCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventUncheckedCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventUncheckedCreateNestedManyWithoutTargetInput
  }

  export type AgentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUpdateManyWithoutAgentNestedInput
    game?: GameUpdateOneRequiredWithoutAgentsNestedInput
    battlesAsAttacker?: BattleUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUpdateManyWithoutJoinerNestedInput
    profile?: AgentProfileUpdateOneRequiredWithoutAgentsNestedInput
    mapTile?: MapTileUpdateOneRequiredWithoutAgentNestedInput
    ignoredBy?: IgnoreUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUpdateManyWithoutTargetNestedInput
  }

  export type AgentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mapTileId?: StringFieldUpdateOperationsInput | string
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUncheckedUpdateManyWithoutAgentNestedInput
    battlesAsAttacker?: BattleUncheckedUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUncheckedUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUncheckedUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUncheckedUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUncheckedUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUncheckedUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUncheckedUpdateManyWithoutJoinerNestedInput
    ignoredBy?: IgnoreUncheckedUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUncheckedUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type AgentCreateManyInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    gameId: string
    isAlive?: boolean
    profileId: string
    deathTimestamp?: Date | string | null
    mapTileId: string
    vault: string
  }

  export type AgentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vault?: StringFieldUpdateOperationsInput | string
  }

  export type AgentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mapTileId?: StringFieldUpdateOperationsInput | string
    vault?: StringFieldUpdateOperationsInput | string
  }

  export type IgnoreCreateInput = {
    id?: string
    timestamp?: Date | string
    duration?: number
    agent: AgentCreateNestedOneWithoutIgnoredByInput
    game: GameCreateNestedOneWithoutIgnoreInput
    ignoredAgent: AgentCreateNestedOneWithoutIgnoringInput
  }

  export type IgnoreUncheckedCreateInput = {
    id?: string
    agentId: string
    timestamp?: Date | string
    duration?: number
    gameId: string
    ignoredAgentId: string
  }

  export type IgnoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    agent?: AgentUpdateOneRequiredWithoutIgnoredByNestedInput
    game?: GameUpdateOneRequiredWithoutIgnoreNestedInput
    ignoredAgent?: AgentUpdateOneRequiredWithoutIgnoringNestedInput
  }

  export type IgnoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    ignoredAgentId?: StringFieldUpdateOperationsInput | string
  }

  export type IgnoreCreateManyInput = {
    id?: string
    agentId: string
    timestamp?: Date | string
    duration?: number
    gameId: string
    ignoredAgentId: string
  }

  export type IgnoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
  }

  export type IgnoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    ignoredAgentId?: StringFieldUpdateOperationsInput | string
  }

  export type MapTileCreateInput = {
    id?: string
    x: number
    y: number
    terrainType: $Enums.TerrainType
    agentId?: string | null
    agent?: AgentCreateNestedOneWithoutMapTileInput
  }

  export type MapTileUncheckedCreateInput = {
    id?: string
    x: number
    y: number
    terrainType: $Enums.TerrainType
    agentId?: string | null
    agent?: AgentUncheckedCreateNestedOneWithoutMapTileInput
  }

  export type MapTileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    terrainType?: EnumTerrainTypeFieldUpdateOperationsInput | $Enums.TerrainType
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: AgentUpdateOneWithoutMapTileNestedInput
  }

  export type MapTileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    terrainType?: EnumTerrainTypeFieldUpdateOperationsInput | $Enums.TerrainType
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: AgentUncheckedUpdateOneWithoutMapTileNestedInput
  }

  export type MapTileCreateManyInput = {
    id?: string
    x: number
    y: number
    terrainType: $Enums.TerrainType
    agentId?: string | null
  }

  export type MapTileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    terrainType?: EnumTerrainTypeFieldUpdateOperationsInput | $Enums.TerrainType
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MapTileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    terrainType?: EnumTerrainTypeFieldUpdateOperationsInput | $Enums.TerrainType
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TweetCreateInput = {
    id?: string
    content: string
    type: string
    timestamp: Date | string
    conversationId?: string | null
    agent: AgentCreateNestedOneWithoutTweetsInput
    interactions?: InteractionCreateNestedManyWithoutTweetInput
  }

  export type TweetUncheckedCreateInput = {
    id?: string
    agentId: string
    content: string
    type: string
    timestamp: Date | string
    conversationId?: string | null
    interactions?: InteractionUncheckedCreateNestedManyWithoutTweetInput
  }

  export type TweetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: AgentUpdateOneRequiredWithoutTweetsNestedInput
    interactions?: InteractionUpdateManyWithoutTweetNestedInput
  }

  export type TweetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    interactions?: InteractionUncheckedUpdateManyWithoutTweetNestedInput
  }

  export type TweetCreateManyInput = {
    id?: string
    agentId: string
    content: string
    type: string
    timestamp: Date | string
    conversationId?: string | null
  }

  export type TweetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TweetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AllianceCreateInput = {
    id?: string
    combinedTokens?: bigint | number | null
    status?: $Enums.AllianceStatus
    timestamp?: Date | string
    endedAt?: Date | string | null
    game: GameCreateNestedOneWithoutAlliancesInput
    initiator: AgentCreateNestedOneWithoutInitiatedAlliancesInput
    joiner: AgentCreateNestedOneWithoutJoinedAlliancesInput
  }

  export type AllianceUncheckedCreateInput = {
    id?: string
    combinedTokens?: bigint | number | null
    status?: $Enums.AllianceStatus
    timestamp?: Date | string
    gameId: string
    initiatorId: string
    joinerId: string
    endedAt?: Date | string | null
  }

  export type AllianceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    combinedTokens?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumAllianceStatusFieldUpdateOperationsInput | $Enums.AllianceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    game?: GameUpdateOneRequiredWithoutAlliancesNestedInput
    initiator?: AgentUpdateOneRequiredWithoutInitiatedAlliancesNestedInput
    joiner?: AgentUpdateOneRequiredWithoutJoinedAlliancesNestedInput
  }

  export type AllianceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    combinedTokens?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumAllianceStatusFieldUpdateOperationsInput | $Enums.AllianceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    gameId?: StringFieldUpdateOperationsInput | string
    initiatorId?: StringFieldUpdateOperationsInput | string
    joinerId?: StringFieldUpdateOperationsInput | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AllianceCreateManyInput = {
    id?: string
    combinedTokens?: bigint | number | null
    status?: $Enums.AllianceStatus
    timestamp?: Date | string
    gameId: string
    initiatorId: string
    joinerId: string
    endedAt?: Date | string | null
  }

  export type AllianceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    combinedTokens?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumAllianceStatusFieldUpdateOperationsInput | $Enums.AllianceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AllianceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    combinedTokens?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumAllianceStatusFieldUpdateOperationsInput | $Enums.AllianceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    gameId?: StringFieldUpdateOperationsInput | string
    initiatorId?: StringFieldUpdateOperationsInput | string
    joinerId?: StringFieldUpdateOperationsInput | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BattleCreateInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    game: GameCreateNestedOneWithoutBattlesInput
    attacker: AgentCreateNestedOneWithoutBattlesAsAttackerInput
    defender: AgentCreateNestedOneWithoutBattlesAsDefenderInput
    attackerAlly?: AgentCreateNestedOneWithoutBattlesAsAttackerAllyInput
    defenderAlly?: AgentCreateNestedOneWithoutBattlesAsDefenderAllyInput
    winner?: AgentCreateNestedOneWithoutWonBattlesInput
  }

  export type BattleUncheckedCreateInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    gameId: string
    attackerId: string
    defenderId: string
    attackerAllyId?: string | null
    defenderAllyId?: string | null
    winnerId?: string | null
  }

  export type BattleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    game?: GameUpdateOneRequiredWithoutBattlesNestedInput
    attacker?: AgentUpdateOneRequiredWithoutBattlesAsAttackerNestedInput
    defender?: AgentUpdateOneRequiredWithoutBattlesAsDefenderNestedInput
    attackerAlly?: AgentUpdateOneWithoutBattlesAsAttackerAllyNestedInput
    defenderAlly?: AgentUpdateOneWithoutBattlesAsDefenderAllyNestedInput
    winner?: AgentUpdateOneWithoutWonBattlesNestedInput
  }

  export type BattleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    attackerId?: StringFieldUpdateOperationsInput | string
    defenderId?: StringFieldUpdateOperationsInput | string
    attackerAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    defenderAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BattleCreateManyInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    gameId: string
    attackerId: string
    defenderId: string
    attackerAllyId?: string | null
    defenderAllyId?: string | null
    winnerId?: string | null
  }

  export type BattleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BattleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    attackerId?: StringFieldUpdateOperationsInput | string
    defenderId?: StringFieldUpdateOperationsInput | string
    attackerAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    defenderAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InteractionCreateInput = {
    id?: string
    userId: string
    type: $Enums.InteractionType
    content: string
    timestamp: Date | string
    userMetrics: JsonNullValueInput | InputJsonValue
    tweet: TweetCreateNestedOneWithoutInteractionsInput
  }

  export type InteractionUncheckedCreateInput = {
    id?: string
    tweetId: string
    userId: string
    type: $Enums.InteractionType
    content: string
    timestamp: Date | string
    userMetrics: JsonNullValueInput | InputJsonValue
  }

  export type InteractionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userMetrics?: JsonNullValueInput | InputJsonValue
    tweet?: TweetUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type InteractionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userMetrics?: JsonNullValueInput | InputJsonValue
  }

  export type InteractionCreateManyInput = {
    id?: string
    tweetId: string
    userId: string
    type: $Enums.InteractionType
    content: string
    timestamp: Date | string
    userMetrics: JsonNullValueInput | InputJsonValue
  }

  export type InteractionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userMetrics?: JsonNullValueInput | InputJsonValue
  }

  export type InteractionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userMetrics?: JsonNullValueInput | InputJsonValue
  }

  export type CoolDownCreateInput = {
    id?: string
    type: $Enums.CooldownType
    endsAt: Date | string
    startsAt?: Date | string | null
    cooledAgent: AgentCreateNestedOneWithoutCoolDownInput
    game: GameCreateNestedOneWithoutCoolDownInput
  }

  export type CoolDownUncheckedCreateInput = {
    id?: string
    type: $Enums.CooldownType
    endsAt: Date | string
    startsAt?: Date | string | null
    cooledAgentId: string
    gameId: string
  }

  export type CoolDownUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCooldownTypeFieldUpdateOperationsInput | $Enums.CooldownType
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cooledAgent?: AgentUpdateOneRequiredWithoutCoolDownNestedInput
    game?: GameUpdateOneRequiredWithoutCoolDownNestedInput
  }

  export type CoolDownUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCooldownTypeFieldUpdateOperationsInput | $Enums.CooldownType
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cooledAgentId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type CoolDownCreateManyInput = {
    id?: string
    type: $Enums.CooldownType
    endsAt: Date | string
    startsAt?: Date | string | null
    cooledAgentId: string
    gameId: string
  }

  export type CoolDownUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCooldownTypeFieldUpdateOperationsInput | $Enums.CooldownType
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CoolDownUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCooldownTypeFieldUpdateOperationsInput | $Enums.CooldownType
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cooledAgentId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id: string
    privyUserId: string
    role?: $Enums.UserRole
    email?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id: string
    privyUserId: string
    role?: $Enums.UserRole
    email?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    privyUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    privyUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id: string
    privyUserId: string
    role?: $Enums.UserRole
    email?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    privyUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    privyUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameLogCreateInput = {
    id?: string
    timestamp?: Date | string
    type: string
    level: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    agent?: AgentCreateNestedOneWithoutGameLogInput
    game?: GameCreateNestedOneWithoutGameLogInput
  }

  export type GameLogUncheckedCreateInput = {
    id?: string
    timestamp?: Date | string
    type: string
    level: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    agentId?: string | null
    gameId?: string | null
  }

  export type GameLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    agent?: AgentUpdateOneWithoutGameLogNestedInput
    game?: GameUpdateOneWithoutGameLogNestedInput
  }

  export type GameLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GameLogCreateManyInput = {
    id?: string
    timestamp?: Date | string
    type: string
    level: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    agentId?: string | null
    gameId?: string | null
  }

  export type GameLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GameLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AgentListRelationFilter = {
    every?: AgentWhereInput
    some?: AgentWhereInput
    none?: AgentWhereInput
  }

  export type AllianceListRelationFilter = {
    every?: AllianceWhereInput
    some?: AllianceWhereInput
    none?: AllianceWhereInput
  }

  export type BattleListRelationFilter = {
    every?: BattleWhereInput
    some?: BattleWhereInput
    none?: BattleWhereInput
  }

  export type CoolDownListRelationFilter = {
    every?: CoolDownWhereInput
    some?: CoolDownWhereInput
    none?: CoolDownWhereInput
  }

  export type IgnoreListRelationFilter = {
    every?: IgnoreWhereInput
    some?: IgnoreWhereInput
    none?: IgnoreWhereInput
  }

  export type GameLogListRelationFilter = {
    every?: GameLogWhereInput
    some?: GameLogWhereInput
    none?: GameLogWhereInput
  }

  export type GameEventListRelationFilter = {
    every?: GameEventWhereInput
    some?: GameEventWhereInput
    none?: GameEventWhereInput
  }

  export type AgentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AllianceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BattleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoolDownOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IgnoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameCountOrderByAggregateInput = {
    id?: SortOrder
    onchainId?: SortOrder
    authority?: SortOrder
    pda?: SortOrder
    tokenMint?: SortOrder
    rewardsVault?: SortOrder
    mapDiameter?: SortOrder
    isActive?: SortOrder
    lastUpdate?: SortOrder
    bump?: SortOrder
    dailyRewardTokens?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameAvgOrderByAggregateInput = {
    onchainId?: SortOrder
    mapDiameter?: SortOrder
    bump?: SortOrder
    dailyRewardTokens?: SortOrder
  }

  export type GameMaxOrderByAggregateInput = {
    id?: SortOrder
    onchainId?: SortOrder
    authority?: SortOrder
    pda?: SortOrder
    tokenMint?: SortOrder
    rewardsVault?: SortOrder
    mapDiameter?: SortOrder
    isActive?: SortOrder
    lastUpdate?: SortOrder
    bump?: SortOrder
    dailyRewardTokens?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameMinOrderByAggregateInput = {
    id?: SortOrder
    onchainId?: SortOrder
    authority?: SortOrder
    pda?: SortOrder
    tokenMint?: SortOrder
    rewardsVault?: SortOrder
    mapDiameter?: SortOrder
    isActive?: SortOrder
    lastUpdate?: SortOrder
    bump?: SortOrder
    dailyRewardTokens?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameSumOrderByAggregateInput = {
    onchainId?: SortOrder
    mapDiameter?: SortOrder
    bump?: SortOrder
    dailyRewardTokens?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AgentScalarRelationFilter = {
    is?: AgentWhereInput
    isNot?: AgentWhereInput
  }

  export type AgentNullableScalarRelationFilter = {
    is?: AgentWhereInput | null
    isNot?: AgentWhereInput | null
  }

  export type GameScalarRelationFilter = {
    is?: GameWhereInput
    isNot?: GameWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type GameEventCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    eventType?: SortOrder
    initiatorId?: SortOrder
    targetId?: SortOrder
    message?: SortOrder
    metadata?: SortOrder
    gameId?: SortOrder
  }

  export type GameEventMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    eventType?: SortOrder
    initiatorId?: SortOrder
    targetId?: SortOrder
    message?: SortOrder
    gameId?: SortOrder
  }

  export type GameEventMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    eventType?: SortOrder
    initiatorId?: SortOrder
    targetId?: SortOrder
    message?: SortOrder
    gameId?: SortOrder
  }

  export type EnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AgentProfileCountOrderByAggregateInput = {
    id?: SortOrder
    onchainId?: SortOrder
    name?: SortOrder
    xHandle?: SortOrder
    description?: SortOrder
    telegramLink?: SortOrder
    followers?: SortOrder
    bio?: SortOrder
    lore?: SortOrder
    loreFulltext?: SortOrder
    characteristics?: SortOrder
    knowledge?: SortOrder
    traits?: SortOrder
    postExamples?: SortOrder
  }

  export type AgentProfileAvgOrderByAggregateInput = {
    onchainId?: SortOrder
    followers?: SortOrder
  }

  export type AgentProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    onchainId?: SortOrder
    name?: SortOrder
    xHandle?: SortOrder
    description?: SortOrder
    telegramLink?: SortOrder
    followers?: SortOrder
    loreFulltext?: SortOrder
  }

  export type AgentProfileMinOrderByAggregateInput = {
    id?: SortOrder
    onchainId?: SortOrder
    name?: SortOrder
    xHandle?: SortOrder
    description?: SortOrder
    telegramLink?: SortOrder
    followers?: SortOrder
    loreFulltext?: SortOrder
  }

  export type AgentProfileSumOrderByAggregateInput = {
    onchainId?: SortOrder
    followers?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TweetListRelationFilter = {
    every?: TweetWhereInput
    some?: TweetWhereInput
    none?: TweetWhereInput
  }

  export type AgentProfileScalarRelationFilter = {
    is?: AgentProfileWhereInput
    isNot?: AgentProfileWhereInput
  }

  export type MapTileScalarRelationFilter = {
    is?: MapTileWhereInput
    isNot?: MapTileWhereInput
  }

  export type TweetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentOnchainIdGameIdCompoundUniqueInput = {
    onchainId: number
    gameId: string
  }

  export type AgentCountOrderByAggregateInput = {
    id?: SortOrder
    onchainId?: SortOrder
    authority?: SortOrder
    authorityAssociatedTokenAddress?: SortOrder
    pda?: SortOrder
    gameId?: SortOrder
    isAlive?: SortOrder
    profileId?: SortOrder
    deathTimestamp?: SortOrder
    mapTileId?: SortOrder
    vault?: SortOrder
  }

  export type AgentAvgOrderByAggregateInput = {
    onchainId?: SortOrder
  }

  export type AgentMaxOrderByAggregateInput = {
    id?: SortOrder
    onchainId?: SortOrder
    authority?: SortOrder
    authorityAssociatedTokenAddress?: SortOrder
    pda?: SortOrder
    gameId?: SortOrder
    isAlive?: SortOrder
    profileId?: SortOrder
    deathTimestamp?: SortOrder
    mapTileId?: SortOrder
    vault?: SortOrder
  }

  export type AgentMinOrderByAggregateInput = {
    id?: SortOrder
    onchainId?: SortOrder
    authority?: SortOrder
    authorityAssociatedTokenAddress?: SortOrder
    pda?: SortOrder
    gameId?: SortOrder
    isAlive?: SortOrder
    profileId?: SortOrder
    deathTimestamp?: SortOrder
    mapTileId?: SortOrder
    vault?: SortOrder
  }

  export type AgentSumOrderByAggregateInput = {
    onchainId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IgnoreAgentIdIgnoredAgentIdCompoundUniqueInput = {
    agentId: string
    ignoredAgentId: string
  }

  export type IgnoreCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    timestamp?: SortOrder
    duration?: SortOrder
    gameId?: SortOrder
    ignoredAgentId?: SortOrder
  }

  export type IgnoreAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type IgnoreMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    timestamp?: SortOrder
    duration?: SortOrder
    gameId?: SortOrder
    ignoredAgentId?: SortOrder
  }

  export type IgnoreMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    timestamp?: SortOrder
    duration?: SortOrder
    gameId?: SortOrder
    ignoredAgentId?: SortOrder
  }

  export type IgnoreSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumTerrainTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TerrainType | EnumTerrainTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TerrainType[] | ListEnumTerrainTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TerrainType[] | ListEnumTerrainTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTerrainTypeFilter<$PrismaModel> | $Enums.TerrainType
  }

  export type MapTileXYCompoundUniqueInput = {
    x: number
    y: number
  }

  export type MapTileCountOrderByAggregateInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
    terrainType?: SortOrder
    agentId?: SortOrder
  }

  export type MapTileAvgOrderByAggregateInput = {
    x?: SortOrder
    y?: SortOrder
  }

  export type MapTileMaxOrderByAggregateInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
    terrainType?: SortOrder
    agentId?: SortOrder
  }

  export type MapTileMinOrderByAggregateInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
    terrainType?: SortOrder
    agentId?: SortOrder
  }

  export type MapTileSumOrderByAggregateInput = {
    x?: SortOrder
    y?: SortOrder
  }

  export type EnumTerrainTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TerrainType | EnumTerrainTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TerrainType[] | ListEnumTerrainTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TerrainType[] | ListEnumTerrainTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTerrainTypeWithAggregatesFilter<$PrismaModel> | $Enums.TerrainType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTerrainTypeFilter<$PrismaModel>
    _max?: NestedEnumTerrainTypeFilter<$PrismaModel>
  }

  export type InteractionListRelationFilter = {
    every?: InteractionWhereInput
    some?: InteractionWhereInput
    none?: InteractionWhereInput
  }

  export type InteractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TweetCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    conversationId?: SortOrder
  }

  export type TweetMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    conversationId?: SortOrder
  }

  export type TweetMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    conversationId?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type EnumAllianceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AllianceStatus | EnumAllianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AllianceStatus[] | ListEnumAllianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AllianceStatus[] | ListEnumAllianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAllianceStatusFilter<$PrismaModel> | $Enums.AllianceStatus
  }

  export type AllianceInitiatorIdJoinerIdCompoundUniqueInput = {
    initiatorId: string
    joinerId: string
  }

  export type AllianceCountOrderByAggregateInput = {
    id?: SortOrder
    combinedTokens?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    gameId?: SortOrder
    initiatorId?: SortOrder
    joinerId?: SortOrder
    endedAt?: SortOrder
  }

  export type AllianceAvgOrderByAggregateInput = {
    combinedTokens?: SortOrder
  }

  export type AllianceMaxOrderByAggregateInput = {
    id?: SortOrder
    combinedTokens?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    gameId?: SortOrder
    initiatorId?: SortOrder
    joinerId?: SortOrder
    endedAt?: SortOrder
  }

  export type AllianceMinOrderByAggregateInput = {
    id?: SortOrder
    combinedTokens?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    gameId?: SortOrder
    initiatorId?: SortOrder
    joinerId?: SortOrder
    endedAt?: SortOrder
  }

  export type AllianceSumOrderByAggregateInput = {
    combinedTokens?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type EnumAllianceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AllianceStatus | EnumAllianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AllianceStatus[] | ListEnumAllianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AllianceStatus[] | ListEnumAllianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAllianceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AllianceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAllianceStatusFilter<$PrismaModel>
    _max?: NestedEnumAllianceStatusFilter<$PrismaModel>
  }

  export type EnumBattleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleType | EnumBattleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BattleType[] | ListEnumBattleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleType[] | ListEnumBattleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleTypeFilter<$PrismaModel> | $Enums.BattleType
  }

  export type EnumBattleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleStatus | EnumBattleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleStatusFilter<$PrismaModel> | $Enums.BattleStatus
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type BattleStartTimeTypeCompoundUniqueInput = {
    startTime: Date | string
    type: $Enums.BattleType
  }

  export type BattleCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    tokensStaked?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    gameId?: SortOrder
    attackerId?: SortOrder
    defenderId?: SortOrder
    attackerAllyId?: SortOrder
    defenderAllyId?: SortOrder
    winnerId?: SortOrder
  }

  export type BattleAvgOrderByAggregateInput = {
    tokensStaked?: SortOrder
  }

  export type BattleMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    tokensStaked?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    gameId?: SortOrder
    attackerId?: SortOrder
    defenderId?: SortOrder
    attackerAllyId?: SortOrder
    defenderAllyId?: SortOrder
    winnerId?: SortOrder
  }

  export type BattleMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    tokensStaked?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    gameId?: SortOrder
    attackerId?: SortOrder
    defenderId?: SortOrder
    attackerAllyId?: SortOrder
    defenderAllyId?: SortOrder
    winnerId?: SortOrder
  }

  export type BattleSumOrderByAggregateInput = {
    tokensStaked?: SortOrder
  }

  export type EnumBattleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleType | EnumBattleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BattleType[] | ListEnumBattleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleType[] | ListEnumBattleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleTypeWithAggregatesFilter<$PrismaModel> | $Enums.BattleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBattleTypeFilter<$PrismaModel>
    _max?: NestedEnumBattleTypeFilter<$PrismaModel>
  }

  export type EnumBattleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleStatus | EnumBattleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleStatusWithAggregatesFilter<$PrismaModel> | $Enums.BattleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBattleStatusFilter<$PrismaModel>
    _max?: NestedEnumBattleStatusFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type EnumInteractionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionTypeFilter<$PrismaModel> | $Enums.InteractionType
  }

  export type TweetScalarRelationFilter = {
    is?: TweetWhereInput
    isNot?: TweetWhereInput
  }

  export type InteractionCountOrderByAggregateInput = {
    id?: SortOrder
    tweetId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    userMetrics?: SortOrder
  }

  export type InteractionMaxOrderByAggregateInput = {
    id?: SortOrder
    tweetId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
  }

  export type InteractionMinOrderByAggregateInput = {
    id?: SortOrder
    tweetId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumInteractionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InteractionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInteractionTypeFilter<$PrismaModel>
    _max?: NestedEnumInteractionTypeFilter<$PrismaModel>
  }

  export type EnumCooldownTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CooldownType | EnumCooldownTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CooldownType[] | ListEnumCooldownTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CooldownType[] | ListEnumCooldownTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCooldownTypeFilter<$PrismaModel> | $Enums.CooldownType
  }

  export type CoolDownCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    endsAt?: SortOrder
    startsAt?: SortOrder
    cooledAgentId?: SortOrder
    gameId?: SortOrder
  }

  export type CoolDownMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    endsAt?: SortOrder
    startsAt?: SortOrder
    cooledAgentId?: SortOrder
    gameId?: SortOrder
  }

  export type CoolDownMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    endsAt?: SortOrder
    startsAt?: SortOrder
    cooledAgentId?: SortOrder
    gameId?: SortOrder
  }

  export type EnumCooldownTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CooldownType | EnumCooldownTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CooldownType[] | ListEnumCooldownTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CooldownType[] | ListEnumCooldownTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCooldownTypeWithAggregatesFilter<$PrismaModel> | $Enums.CooldownType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCooldownTypeFilter<$PrismaModel>
    _max?: NestedEnumCooldownTypeFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    privyUserId?: SortOrder
    role?: SortOrder
    email?: SortOrder
    walletAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    privyUserId?: SortOrder
    role?: SortOrder
    email?: SortOrder
    walletAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    privyUserId?: SortOrder
    role?: SortOrder
    email?: SortOrder
    walletAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type GameNullableScalarRelationFilter = {
    is?: GameWhereInput | null
    isNot?: GameWhereInput | null
  }

  export type GameLogCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    level?: SortOrder
    message?: SortOrder
    data?: SortOrder
    agentId?: SortOrder
    gameId?: SortOrder
  }

  export type GameLogMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    level?: SortOrder
    message?: SortOrder
    agentId?: SortOrder
    gameId?: SortOrder
  }

  export type GameLogMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    level?: SortOrder
    message?: SortOrder
    agentId?: SortOrder
    gameId?: SortOrder
  }

  export type AgentCreateNestedManyWithoutGameInput = {
    create?: XOR<AgentCreateWithoutGameInput, AgentUncheckedCreateWithoutGameInput> | AgentCreateWithoutGameInput[] | AgentUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutGameInput | AgentCreateOrConnectWithoutGameInput[]
    createMany?: AgentCreateManyGameInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type AllianceCreateNestedManyWithoutGameInput = {
    create?: XOR<AllianceCreateWithoutGameInput, AllianceUncheckedCreateWithoutGameInput> | AllianceCreateWithoutGameInput[] | AllianceUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AllianceCreateOrConnectWithoutGameInput | AllianceCreateOrConnectWithoutGameInput[]
    createMany?: AllianceCreateManyGameInputEnvelope
    connect?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
  }

  export type BattleCreateNestedManyWithoutGameInput = {
    create?: XOR<BattleCreateWithoutGameInput, BattleUncheckedCreateWithoutGameInput> | BattleCreateWithoutGameInput[] | BattleUncheckedCreateWithoutGameInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutGameInput | BattleCreateOrConnectWithoutGameInput[]
    createMany?: BattleCreateManyGameInputEnvelope
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
  }

  export type CoolDownCreateNestedManyWithoutGameInput = {
    create?: XOR<CoolDownCreateWithoutGameInput, CoolDownUncheckedCreateWithoutGameInput> | CoolDownCreateWithoutGameInput[] | CoolDownUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CoolDownCreateOrConnectWithoutGameInput | CoolDownCreateOrConnectWithoutGameInput[]
    createMany?: CoolDownCreateManyGameInputEnvelope
    connect?: CoolDownWhereUniqueInput | CoolDownWhereUniqueInput[]
  }

  export type IgnoreCreateNestedManyWithoutGameInput = {
    create?: XOR<IgnoreCreateWithoutGameInput, IgnoreUncheckedCreateWithoutGameInput> | IgnoreCreateWithoutGameInput[] | IgnoreUncheckedCreateWithoutGameInput[]
    connectOrCreate?: IgnoreCreateOrConnectWithoutGameInput | IgnoreCreateOrConnectWithoutGameInput[]
    createMany?: IgnoreCreateManyGameInputEnvelope
    connect?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
  }

  export type GameLogCreateNestedManyWithoutGameInput = {
    create?: XOR<GameLogCreateWithoutGameInput, GameLogUncheckedCreateWithoutGameInput> | GameLogCreateWithoutGameInput[] | GameLogUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameLogCreateOrConnectWithoutGameInput | GameLogCreateOrConnectWithoutGameInput[]
    createMany?: GameLogCreateManyGameInputEnvelope
    connect?: GameLogWhereUniqueInput | GameLogWhereUniqueInput[]
  }

  export type GameEventCreateNestedManyWithoutGameInput = {
    create?: XOR<GameEventCreateWithoutGameInput, GameEventUncheckedCreateWithoutGameInput> | GameEventCreateWithoutGameInput[] | GameEventUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameEventCreateOrConnectWithoutGameInput | GameEventCreateOrConnectWithoutGameInput[]
    createMany?: GameEventCreateManyGameInputEnvelope
    connect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<AgentCreateWithoutGameInput, AgentUncheckedCreateWithoutGameInput> | AgentCreateWithoutGameInput[] | AgentUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutGameInput | AgentCreateOrConnectWithoutGameInput[]
    createMany?: AgentCreateManyGameInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type AllianceUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<AllianceCreateWithoutGameInput, AllianceUncheckedCreateWithoutGameInput> | AllianceCreateWithoutGameInput[] | AllianceUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AllianceCreateOrConnectWithoutGameInput | AllianceCreateOrConnectWithoutGameInput[]
    createMany?: AllianceCreateManyGameInputEnvelope
    connect?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
  }

  export type BattleUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<BattleCreateWithoutGameInput, BattleUncheckedCreateWithoutGameInput> | BattleCreateWithoutGameInput[] | BattleUncheckedCreateWithoutGameInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutGameInput | BattleCreateOrConnectWithoutGameInput[]
    createMany?: BattleCreateManyGameInputEnvelope
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
  }

  export type CoolDownUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<CoolDownCreateWithoutGameInput, CoolDownUncheckedCreateWithoutGameInput> | CoolDownCreateWithoutGameInput[] | CoolDownUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CoolDownCreateOrConnectWithoutGameInput | CoolDownCreateOrConnectWithoutGameInput[]
    createMany?: CoolDownCreateManyGameInputEnvelope
    connect?: CoolDownWhereUniqueInput | CoolDownWhereUniqueInput[]
  }

  export type IgnoreUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<IgnoreCreateWithoutGameInput, IgnoreUncheckedCreateWithoutGameInput> | IgnoreCreateWithoutGameInput[] | IgnoreUncheckedCreateWithoutGameInput[]
    connectOrCreate?: IgnoreCreateOrConnectWithoutGameInput | IgnoreCreateOrConnectWithoutGameInput[]
    createMany?: IgnoreCreateManyGameInputEnvelope
    connect?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
  }

  export type GameLogUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<GameLogCreateWithoutGameInput, GameLogUncheckedCreateWithoutGameInput> | GameLogCreateWithoutGameInput[] | GameLogUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameLogCreateOrConnectWithoutGameInput | GameLogCreateOrConnectWithoutGameInput[]
    createMany?: GameLogCreateManyGameInputEnvelope
    connect?: GameLogWhereUniqueInput | GameLogWhereUniqueInput[]
  }

  export type GameEventUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<GameEventCreateWithoutGameInput, GameEventUncheckedCreateWithoutGameInput> | GameEventCreateWithoutGameInput[] | GameEventUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameEventCreateOrConnectWithoutGameInput | GameEventCreateOrConnectWithoutGameInput[]
    createMany?: GameEventCreateManyGameInputEnvelope
    connect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AgentUpdateManyWithoutGameNestedInput = {
    create?: XOR<AgentCreateWithoutGameInput, AgentUncheckedCreateWithoutGameInput> | AgentCreateWithoutGameInput[] | AgentUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutGameInput | AgentCreateOrConnectWithoutGameInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutGameInput | AgentUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: AgentCreateManyGameInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutGameInput | AgentUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutGameInput | AgentUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type AllianceUpdateManyWithoutGameNestedInput = {
    create?: XOR<AllianceCreateWithoutGameInput, AllianceUncheckedCreateWithoutGameInput> | AllianceCreateWithoutGameInput[] | AllianceUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AllianceCreateOrConnectWithoutGameInput | AllianceCreateOrConnectWithoutGameInput[]
    upsert?: AllianceUpsertWithWhereUniqueWithoutGameInput | AllianceUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: AllianceCreateManyGameInputEnvelope
    set?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    disconnect?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    delete?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    connect?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    update?: AllianceUpdateWithWhereUniqueWithoutGameInput | AllianceUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: AllianceUpdateManyWithWhereWithoutGameInput | AllianceUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: AllianceScalarWhereInput | AllianceScalarWhereInput[]
  }

  export type BattleUpdateManyWithoutGameNestedInput = {
    create?: XOR<BattleCreateWithoutGameInput, BattleUncheckedCreateWithoutGameInput> | BattleCreateWithoutGameInput[] | BattleUncheckedCreateWithoutGameInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutGameInput | BattleCreateOrConnectWithoutGameInput[]
    upsert?: BattleUpsertWithWhereUniqueWithoutGameInput | BattleUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: BattleCreateManyGameInputEnvelope
    set?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    disconnect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    delete?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    update?: BattleUpdateWithWhereUniqueWithoutGameInput | BattleUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: BattleUpdateManyWithWhereWithoutGameInput | BattleUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: BattleScalarWhereInput | BattleScalarWhereInput[]
  }

  export type CoolDownUpdateManyWithoutGameNestedInput = {
    create?: XOR<CoolDownCreateWithoutGameInput, CoolDownUncheckedCreateWithoutGameInput> | CoolDownCreateWithoutGameInput[] | CoolDownUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CoolDownCreateOrConnectWithoutGameInput | CoolDownCreateOrConnectWithoutGameInput[]
    upsert?: CoolDownUpsertWithWhereUniqueWithoutGameInput | CoolDownUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: CoolDownCreateManyGameInputEnvelope
    set?: CoolDownWhereUniqueInput | CoolDownWhereUniqueInput[]
    disconnect?: CoolDownWhereUniqueInput | CoolDownWhereUniqueInput[]
    delete?: CoolDownWhereUniqueInput | CoolDownWhereUniqueInput[]
    connect?: CoolDownWhereUniqueInput | CoolDownWhereUniqueInput[]
    update?: CoolDownUpdateWithWhereUniqueWithoutGameInput | CoolDownUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: CoolDownUpdateManyWithWhereWithoutGameInput | CoolDownUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: CoolDownScalarWhereInput | CoolDownScalarWhereInput[]
  }

  export type IgnoreUpdateManyWithoutGameNestedInput = {
    create?: XOR<IgnoreCreateWithoutGameInput, IgnoreUncheckedCreateWithoutGameInput> | IgnoreCreateWithoutGameInput[] | IgnoreUncheckedCreateWithoutGameInput[]
    connectOrCreate?: IgnoreCreateOrConnectWithoutGameInput | IgnoreCreateOrConnectWithoutGameInput[]
    upsert?: IgnoreUpsertWithWhereUniqueWithoutGameInput | IgnoreUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: IgnoreCreateManyGameInputEnvelope
    set?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    disconnect?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    delete?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    connect?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    update?: IgnoreUpdateWithWhereUniqueWithoutGameInput | IgnoreUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: IgnoreUpdateManyWithWhereWithoutGameInput | IgnoreUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: IgnoreScalarWhereInput | IgnoreScalarWhereInput[]
  }

  export type GameLogUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameLogCreateWithoutGameInput, GameLogUncheckedCreateWithoutGameInput> | GameLogCreateWithoutGameInput[] | GameLogUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameLogCreateOrConnectWithoutGameInput | GameLogCreateOrConnectWithoutGameInput[]
    upsert?: GameLogUpsertWithWhereUniqueWithoutGameInput | GameLogUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameLogCreateManyGameInputEnvelope
    set?: GameLogWhereUniqueInput | GameLogWhereUniqueInput[]
    disconnect?: GameLogWhereUniqueInput | GameLogWhereUniqueInput[]
    delete?: GameLogWhereUniqueInput | GameLogWhereUniqueInput[]
    connect?: GameLogWhereUniqueInput | GameLogWhereUniqueInput[]
    update?: GameLogUpdateWithWhereUniqueWithoutGameInput | GameLogUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameLogUpdateManyWithWhereWithoutGameInput | GameLogUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameLogScalarWhereInput | GameLogScalarWhereInput[]
  }

  export type GameEventUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameEventCreateWithoutGameInput, GameEventUncheckedCreateWithoutGameInput> | GameEventCreateWithoutGameInput[] | GameEventUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameEventCreateOrConnectWithoutGameInput | GameEventCreateOrConnectWithoutGameInput[]
    upsert?: GameEventUpsertWithWhereUniqueWithoutGameInput | GameEventUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameEventCreateManyGameInputEnvelope
    set?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    disconnect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    delete?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    connect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    update?: GameEventUpdateWithWhereUniqueWithoutGameInput | GameEventUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameEventUpdateManyWithWhereWithoutGameInput | GameEventUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameEventScalarWhereInput | GameEventScalarWhereInput[]
  }

  export type AgentUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<AgentCreateWithoutGameInput, AgentUncheckedCreateWithoutGameInput> | AgentCreateWithoutGameInput[] | AgentUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutGameInput | AgentCreateOrConnectWithoutGameInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutGameInput | AgentUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: AgentCreateManyGameInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutGameInput | AgentUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutGameInput | AgentUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type AllianceUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<AllianceCreateWithoutGameInput, AllianceUncheckedCreateWithoutGameInput> | AllianceCreateWithoutGameInput[] | AllianceUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AllianceCreateOrConnectWithoutGameInput | AllianceCreateOrConnectWithoutGameInput[]
    upsert?: AllianceUpsertWithWhereUniqueWithoutGameInput | AllianceUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: AllianceCreateManyGameInputEnvelope
    set?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    disconnect?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    delete?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    connect?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    update?: AllianceUpdateWithWhereUniqueWithoutGameInput | AllianceUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: AllianceUpdateManyWithWhereWithoutGameInput | AllianceUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: AllianceScalarWhereInput | AllianceScalarWhereInput[]
  }

  export type BattleUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<BattleCreateWithoutGameInput, BattleUncheckedCreateWithoutGameInput> | BattleCreateWithoutGameInput[] | BattleUncheckedCreateWithoutGameInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutGameInput | BattleCreateOrConnectWithoutGameInput[]
    upsert?: BattleUpsertWithWhereUniqueWithoutGameInput | BattleUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: BattleCreateManyGameInputEnvelope
    set?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    disconnect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    delete?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    update?: BattleUpdateWithWhereUniqueWithoutGameInput | BattleUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: BattleUpdateManyWithWhereWithoutGameInput | BattleUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: BattleScalarWhereInput | BattleScalarWhereInput[]
  }

  export type CoolDownUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<CoolDownCreateWithoutGameInput, CoolDownUncheckedCreateWithoutGameInput> | CoolDownCreateWithoutGameInput[] | CoolDownUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CoolDownCreateOrConnectWithoutGameInput | CoolDownCreateOrConnectWithoutGameInput[]
    upsert?: CoolDownUpsertWithWhereUniqueWithoutGameInput | CoolDownUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: CoolDownCreateManyGameInputEnvelope
    set?: CoolDownWhereUniqueInput | CoolDownWhereUniqueInput[]
    disconnect?: CoolDownWhereUniqueInput | CoolDownWhereUniqueInput[]
    delete?: CoolDownWhereUniqueInput | CoolDownWhereUniqueInput[]
    connect?: CoolDownWhereUniqueInput | CoolDownWhereUniqueInput[]
    update?: CoolDownUpdateWithWhereUniqueWithoutGameInput | CoolDownUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: CoolDownUpdateManyWithWhereWithoutGameInput | CoolDownUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: CoolDownScalarWhereInput | CoolDownScalarWhereInput[]
  }

  export type IgnoreUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<IgnoreCreateWithoutGameInput, IgnoreUncheckedCreateWithoutGameInput> | IgnoreCreateWithoutGameInput[] | IgnoreUncheckedCreateWithoutGameInput[]
    connectOrCreate?: IgnoreCreateOrConnectWithoutGameInput | IgnoreCreateOrConnectWithoutGameInput[]
    upsert?: IgnoreUpsertWithWhereUniqueWithoutGameInput | IgnoreUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: IgnoreCreateManyGameInputEnvelope
    set?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    disconnect?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    delete?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    connect?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    update?: IgnoreUpdateWithWhereUniqueWithoutGameInput | IgnoreUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: IgnoreUpdateManyWithWhereWithoutGameInput | IgnoreUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: IgnoreScalarWhereInput | IgnoreScalarWhereInput[]
  }

  export type GameLogUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameLogCreateWithoutGameInput, GameLogUncheckedCreateWithoutGameInput> | GameLogCreateWithoutGameInput[] | GameLogUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameLogCreateOrConnectWithoutGameInput | GameLogCreateOrConnectWithoutGameInput[]
    upsert?: GameLogUpsertWithWhereUniqueWithoutGameInput | GameLogUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameLogCreateManyGameInputEnvelope
    set?: GameLogWhereUniqueInput | GameLogWhereUniqueInput[]
    disconnect?: GameLogWhereUniqueInput | GameLogWhereUniqueInput[]
    delete?: GameLogWhereUniqueInput | GameLogWhereUniqueInput[]
    connect?: GameLogWhereUniqueInput | GameLogWhereUniqueInput[]
    update?: GameLogUpdateWithWhereUniqueWithoutGameInput | GameLogUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameLogUpdateManyWithWhereWithoutGameInput | GameLogUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameLogScalarWhereInput | GameLogScalarWhereInput[]
  }

  export type GameEventUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameEventCreateWithoutGameInput, GameEventUncheckedCreateWithoutGameInput> | GameEventCreateWithoutGameInput[] | GameEventUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameEventCreateOrConnectWithoutGameInput | GameEventCreateOrConnectWithoutGameInput[]
    upsert?: GameEventUpsertWithWhereUniqueWithoutGameInput | GameEventUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameEventCreateManyGameInputEnvelope
    set?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    disconnect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    delete?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    connect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    update?: GameEventUpdateWithWhereUniqueWithoutGameInput | GameEventUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameEventUpdateManyWithWhereWithoutGameInput | GameEventUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameEventScalarWhereInput | GameEventScalarWhereInput[]
  }

  export type AgentCreateNestedOneWithoutInitiatedEventsInput = {
    create?: XOR<AgentCreateWithoutInitiatedEventsInput, AgentUncheckedCreateWithoutInitiatedEventsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutInitiatedEventsInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutTargetedEventsInput = {
    create?: XOR<AgentCreateWithoutTargetedEventsInput, AgentUncheckedCreateWithoutTargetedEventsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutTargetedEventsInput
    connect?: AgentWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutGameEventInput = {
    create?: XOR<GameCreateWithoutGameEventInput, GameUncheckedCreateWithoutGameEventInput>
    connectOrCreate?: GameCreateOrConnectWithoutGameEventInput
    connect?: GameWhereUniqueInput
  }

  export type EnumEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.EventType
  }

  export type AgentUpdateOneRequiredWithoutInitiatedEventsNestedInput = {
    create?: XOR<AgentCreateWithoutInitiatedEventsInput, AgentUncheckedCreateWithoutInitiatedEventsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutInitiatedEventsInput
    upsert?: AgentUpsertWithoutInitiatedEventsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutInitiatedEventsInput, AgentUpdateWithoutInitiatedEventsInput>, AgentUncheckedUpdateWithoutInitiatedEventsInput>
  }

  export type AgentUpdateOneWithoutTargetedEventsNestedInput = {
    create?: XOR<AgentCreateWithoutTargetedEventsInput, AgentUncheckedCreateWithoutTargetedEventsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutTargetedEventsInput
    upsert?: AgentUpsertWithoutTargetedEventsInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutTargetedEventsInput, AgentUpdateWithoutTargetedEventsInput>, AgentUncheckedUpdateWithoutTargetedEventsInput>
  }

  export type GameUpdateOneRequiredWithoutGameEventNestedInput = {
    create?: XOR<GameCreateWithoutGameEventInput, GameUncheckedCreateWithoutGameEventInput>
    connectOrCreate?: GameCreateOrConnectWithoutGameEventInput
    upsert?: GameUpsertWithoutGameEventInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutGameEventInput, GameUpdateWithoutGameEventInput>, GameUncheckedUpdateWithoutGameEventInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type AgentProfileCreatebioInput = {
    set: string[]
  }

  export type AgentProfileCreateloreInput = {
    set: string[]
  }

  export type AgentProfileCreatecharacteristicsInput = {
    set: string[]
  }

  export type AgentProfileCreateknowledgeInput = {
    set: string[]
  }

  export type AgentProfileCreatepostExamplesInput = {
    set: string[]
  }

  export type AgentCreateNestedManyWithoutProfileInput = {
    create?: XOR<AgentCreateWithoutProfileInput, AgentUncheckedCreateWithoutProfileInput> | AgentCreateWithoutProfileInput[] | AgentUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutProfileInput | AgentCreateOrConnectWithoutProfileInput[]
    createMany?: AgentCreateManyProfileInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<AgentCreateWithoutProfileInput, AgentUncheckedCreateWithoutProfileInput> | AgentCreateWithoutProfileInput[] | AgentUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutProfileInput | AgentCreateOrConnectWithoutProfileInput[]
    createMany?: AgentCreateManyProfileInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type AgentProfileUpdatebioInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AgentProfileUpdateloreInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AgentProfileUpdatecharacteristicsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AgentProfileUpdateknowledgeInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AgentProfileUpdatepostExamplesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AgentUpdateManyWithoutProfileNestedInput = {
    create?: XOR<AgentCreateWithoutProfileInput, AgentUncheckedCreateWithoutProfileInput> | AgentCreateWithoutProfileInput[] | AgentUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutProfileInput | AgentCreateOrConnectWithoutProfileInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutProfileInput | AgentUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: AgentCreateManyProfileInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutProfileInput | AgentUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutProfileInput | AgentUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type AgentUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<AgentCreateWithoutProfileInput, AgentUncheckedCreateWithoutProfileInput> | AgentCreateWithoutProfileInput[] | AgentUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutProfileInput | AgentCreateOrConnectWithoutProfileInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutProfileInput | AgentUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: AgentCreateManyProfileInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutProfileInput | AgentUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutProfileInput | AgentUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type TweetCreateNestedManyWithoutAgentInput = {
    create?: XOR<TweetCreateWithoutAgentInput, TweetUncheckedCreateWithoutAgentInput> | TweetCreateWithoutAgentInput[] | TweetUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TweetCreateOrConnectWithoutAgentInput | TweetCreateOrConnectWithoutAgentInput[]
    createMany?: TweetCreateManyAgentInputEnvelope
    connect?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
  }

  export type GameCreateNestedOneWithoutAgentsInput = {
    create?: XOR<GameCreateWithoutAgentsInput, GameUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: GameCreateOrConnectWithoutAgentsInput
    connect?: GameWhereUniqueInput
  }

  export type BattleCreateNestedManyWithoutAttackerInput = {
    create?: XOR<BattleCreateWithoutAttackerInput, BattleUncheckedCreateWithoutAttackerInput> | BattleCreateWithoutAttackerInput[] | BattleUncheckedCreateWithoutAttackerInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutAttackerInput | BattleCreateOrConnectWithoutAttackerInput[]
    createMany?: BattleCreateManyAttackerInputEnvelope
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
  }

  export type BattleCreateNestedManyWithoutDefenderInput = {
    create?: XOR<BattleCreateWithoutDefenderInput, BattleUncheckedCreateWithoutDefenderInput> | BattleCreateWithoutDefenderInput[] | BattleUncheckedCreateWithoutDefenderInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutDefenderInput | BattleCreateOrConnectWithoutDefenderInput[]
    createMany?: BattleCreateManyDefenderInputEnvelope
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
  }

  export type BattleCreateNestedManyWithoutAttackerAllyInput = {
    create?: XOR<BattleCreateWithoutAttackerAllyInput, BattleUncheckedCreateWithoutAttackerAllyInput> | BattleCreateWithoutAttackerAllyInput[] | BattleUncheckedCreateWithoutAttackerAllyInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutAttackerAllyInput | BattleCreateOrConnectWithoutAttackerAllyInput[]
    createMany?: BattleCreateManyAttackerAllyInputEnvelope
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
  }

  export type BattleCreateNestedManyWithoutDefenderAllyInput = {
    create?: XOR<BattleCreateWithoutDefenderAllyInput, BattleUncheckedCreateWithoutDefenderAllyInput> | BattleCreateWithoutDefenderAllyInput[] | BattleUncheckedCreateWithoutDefenderAllyInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutDefenderAllyInput | BattleCreateOrConnectWithoutDefenderAllyInput[]
    createMany?: BattleCreateManyDefenderAllyInputEnvelope
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
  }

  export type BattleCreateNestedManyWithoutWinnerInput = {
    create?: XOR<BattleCreateWithoutWinnerInput, BattleUncheckedCreateWithoutWinnerInput> | BattleCreateWithoutWinnerInput[] | BattleUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutWinnerInput | BattleCreateOrConnectWithoutWinnerInput[]
    createMany?: BattleCreateManyWinnerInputEnvelope
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
  }

  export type CoolDownCreateNestedManyWithoutCooledAgentInput = {
    create?: XOR<CoolDownCreateWithoutCooledAgentInput, CoolDownUncheckedCreateWithoutCooledAgentInput> | CoolDownCreateWithoutCooledAgentInput[] | CoolDownUncheckedCreateWithoutCooledAgentInput[]
    connectOrCreate?: CoolDownCreateOrConnectWithoutCooledAgentInput | CoolDownCreateOrConnectWithoutCooledAgentInput[]
    createMany?: CoolDownCreateManyCooledAgentInputEnvelope
    connect?: CoolDownWhereUniqueInput | CoolDownWhereUniqueInput[]
  }

  export type AllianceCreateNestedManyWithoutInitiatorInput = {
    create?: XOR<AllianceCreateWithoutInitiatorInput, AllianceUncheckedCreateWithoutInitiatorInput> | AllianceCreateWithoutInitiatorInput[] | AllianceUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: AllianceCreateOrConnectWithoutInitiatorInput | AllianceCreateOrConnectWithoutInitiatorInput[]
    createMany?: AllianceCreateManyInitiatorInputEnvelope
    connect?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
  }

  export type AllianceCreateNestedManyWithoutJoinerInput = {
    create?: XOR<AllianceCreateWithoutJoinerInput, AllianceUncheckedCreateWithoutJoinerInput> | AllianceCreateWithoutJoinerInput[] | AllianceUncheckedCreateWithoutJoinerInput[]
    connectOrCreate?: AllianceCreateOrConnectWithoutJoinerInput | AllianceCreateOrConnectWithoutJoinerInput[]
    createMany?: AllianceCreateManyJoinerInputEnvelope
    connect?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
  }

  export type AgentProfileCreateNestedOneWithoutAgentsInput = {
    create?: XOR<AgentProfileCreateWithoutAgentsInput, AgentProfileUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: AgentProfileCreateOrConnectWithoutAgentsInput
    connect?: AgentProfileWhereUniqueInput
  }

  export type MapTileCreateNestedOneWithoutAgentInput = {
    create?: XOR<MapTileCreateWithoutAgentInput, MapTileUncheckedCreateWithoutAgentInput>
    connectOrCreate?: MapTileCreateOrConnectWithoutAgentInput
    connect?: MapTileWhereUniqueInput
  }

  export type IgnoreCreateNestedManyWithoutAgentInput = {
    create?: XOR<IgnoreCreateWithoutAgentInput, IgnoreUncheckedCreateWithoutAgentInput> | IgnoreCreateWithoutAgentInput[] | IgnoreUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: IgnoreCreateOrConnectWithoutAgentInput | IgnoreCreateOrConnectWithoutAgentInput[]
    createMany?: IgnoreCreateManyAgentInputEnvelope
    connect?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
  }

  export type IgnoreCreateNestedManyWithoutIgnoredAgentInput = {
    create?: XOR<IgnoreCreateWithoutIgnoredAgentInput, IgnoreUncheckedCreateWithoutIgnoredAgentInput> | IgnoreCreateWithoutIgnoredAgentInput[] | IgnoreUncheckedCreateWithoutIgnoredAgentInput[]
    connectOrCreate?: IgnoreCreateOrConnectWithoutIgnoredAgentInput | IgnoreCreateOrConnectWithoutIgnoredAgentInput[]
    createMany?: IgnoreCreateManyIgnoredAgentInputEnvelope
    connect?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
  }

  export type GameLogCreateNestedManyWithoutAgentInput = {
    create?: XOR<GameLogCreateWithoutAgentInput, GameLogUncheckedCreateWithoutAgentInput> | GameLogCreateWithoutAgentInput[] | GameLogUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: GameLogCreateOrConnectWithoutAgentInput | GameLogCreateOrConnectWithoutAgentInput[]
    createMany?: GameLogCreateManyAgentInputEnvelope
    connect?: GameLogWhereUniqueInput | GameLogWhereUniqueInput[]
  }

  export type GameEventCreateNestedManyWithoutInitiatorInput = {
    create?: XOR<GameEventCreateWithoutInitiatorInput, GameEventUncheckedCreateWithoutInitiatorInput> | GameEventCreateWithoutInitiatorInput[] | GameEventUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: GameEventCreateOrConnectWithoutInitiatorInput | GameEventCreateOrConnectWithoutInitiatorInput[]
    createMany?: GameEventCreateManyInitiatorInputEnvelope
    connect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
  }

  export type GameEventCreateNestedManyWithoutTargetInput = {
    create?: XOR<GameEventCreateWithoutTargetInput, GameEventUncheckedCreateWithoutTargetInput> | GameEventCreateWithoutTargetInput[] | GameEventUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: GameEventCreateOrConnectWithoutTargetInput | GameEventCreateOrConnectWithoutTargetInput[]
    createMany?: GameEventCreateManyTargetInputEnvelope
    connect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
  }

  export type TweetUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<TweetCreateWithoutAgentInput, TweetUncheckedCreateWithoutAgentInput> | TweetCreateWithoutAgentInput[] | TweetUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TweetCreateOrConnectWithoutAgentInput | TweetCreateOrConnectWithoutAgentInput[]
    createMany?: TweetCreateManyAgentInputEnvelope
    connect?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
  }

  export type BattleUncheckedCreateNestedManyWithoutAttackerInput = {
    create?: XOR<BattleCreateWithoutAttackerInput, BattleUncheckedCreateWithoutAttackerInput> | BattleCreateWithoutAttackerInput[] | BattleUncheckedCreateWithoutAttackerInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutAttackerInput | BattleCreateOrConnectWithoutAttackerInput[]
    createMany?: BattleCreateManyAttackerInputEnvelope
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
  }

  export type BattleUncheckedCreateNestedManyWithoutDefenderInput = {
    create?: XOR<BattleCreateWithoutDefenderInput, BattleUncheckedCreateWithoutDefenderInput> | BattleCreateWithoutDefenderInput[] | BattleUncheckedCreateWithoutDefenderInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutDefenderInput | BattleCreateOrConnectWithoutDefenderInput[]
    createMany?: BattleCreateManyDefenderInputEnvelope
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
  }

  export type BattleUncheckedCreateNestedManyWithoutAttackerAllyInput = {
    create?: XOR<BattleCreateWithoutAttackerAllyInput, BattleUncheckedCreateWithoutAttackerAllyInput> | BattleCreateWithoutAttackerAllyInput[] | BattleUncheckedCreateWithoutAttackerAllyInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutAttackerAllyInput | BattleCreateOrConnectWithoutAttackerAllyInput[]
    createMany?: BattleCreateManyAttackerAllyInputEnvelope
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
  }

  export type BattleUncheckedCreateNestedManyWithoutDefenderAllyInput = {
    create?: XOR<BattleCreateWithoutDefenderAllyInput, BattleUncheckedCreateWithoutDefenderAllyInput> | BattleCreateWithoutDefenderAllyInput[] | BattleUncheckedCreateWithoutDefenderAllyInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutDefenderAllyInput | BattleCreateOrConnectWithoutDefenderAllyInput[]
    createMany?: BattleCreateManyDefenderAllyInputEnvelope
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
  }

  export type BattleUncheckedCreateNestedManyWithoutWinnerInput = {
    create?: XOR<BattleCreateWithoutWinnerInput, BattleUncheckedCreateWithoutWinnerInput> | BattleCreateWithoutWinnerInput[] | BattleUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutWinnerInput | BattleCreateOrConnectWithoutWinnerInput[]
    createMany?: BattleCreateManyWinnerInputEnvelope
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
  }

  export type CoolDownUncheckedCreateNestedManyWithoutCooledAgentInput = {
    create?: XOR<CoolDownCreateWithoutCooledAgentInput, CoolDownUncheckedCreateWithoutCooledAgentInput> | CoolDownCreateWithoutCooledAgentInput[] | CoolDownUncheckedCreateWithoutCooledAgentInput[]
    connectOrCreate?: CoolDownCreateOrConnectWithoutCooledAgentInput | CoolDownCreateOrConnectWithoutCooledAgentInput[]
    createMany?: CoolDownCreateManyCooledAgentInputEnvelope
    connect?: CoolDownWhereUniqueInput | CoolDownWhereUniqueInput[]
  }

  export type AllianceUncheckedCreateNestedManyWithoutInitiatorInput = {
    create?: XOR<AllianceCreateWithoutInitiatorInput, AllianceUncheckedCreateWithoutInitiatorInput> | AllianceCreateWithoutInitiatorInput[] | AllianceUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: AllianceCreateOrConnectWithoutInitiatorInput | AllianceCreateOrConnectWithoutInitiatorInput[]
    createMany?: AllianceCreateManyInitiatorInputEnvelope
    connect?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
  }

  export type AllianceUncheckedCreateNestedManyWithoutJoinerInput = {
    create?: XOR<AllianceCreateWithoutJoinerInput, AllianceUncheckedCreateWithoutJoinerInput> | AllianceCreateWithoutJoinerInput[] | AllianceUncheckedCreateWithoutJoinerInput[]
    connectOrCreate?: AllianceCreateOrConnectWithoutJoinerInput | AllianceCreateOrConnectWithoutJoinerInput[]
    createMany?: AllianceCreateManyJoinerInputEnvelope
    connect?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
  }

  export type IgnoreUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<IgnoreCreateWithoutAgentInput, IgnoreUncheckedCreateWithoutAgentInput> | IgnoreCreateWithoutAgentInput[] | IgnoreUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: IgnoreCreateOrConnectWithoutAgentInput | IgnoreCreateOrConnectWithoutAgentInput[]
    createMany?: IgnoreCreateManyAgentInputEnvelope
    connect?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
  }

  export type IgnoreUncheckedCreateNestedManyWithoutIgnoredAgentInput = {
    create?: XOR<IgnoreCreateWithoutIgnoredAgentInput, IgnoreUncheckedCreateWithoutIgnoredAgentInput> | IgnoreCreateWithoutIgnoredAgentInput[] | IgnoreUncheckedCreateWithoutIgnoredAgentInput[]
    connectOrCreate?: IgnoreCreateOrConnectWithoutIgnoredAgentInput | IgnoreCreateOrConnectWithoutIgnoredAgentInput[]
    createMany?: IgnoreCreateManyIgnoredAgentInputEnvelope
    connect?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
  }

  export type GameLogUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<GameLogCreateWithoutAgentInput, GameLogUncheckedCreateWithoutAgentInput> | GameLogCreateWithoutAgentInput[] | GameLogUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: GameLogCreateOrConnectWithoutAgentInput | GameLogCreateOrConnectWithoutAgentInput[]
    createMany?: GameLogCreateManyAgentInputEnvelope
    connect?: GameLogWhereUniqueInput | GameLogWhereUniqueInput[]
  }

  export type GameEventUncheckedCreateNestedManyWithoutInitiatorInput = {
    create?: XOR<GameEventCreateWithoutInitiatorInput, GameEventUncheckedCreateWithoutInitiatorInput> | GameEventCreateWithoutInitiatorInput[] | GameEventUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: GameEventCreateOrConnectWithoutInitiatorInput | GameEventCreateOrConnectWithoutInitiatorInput[]
    createMany?: GameEventCreateManyInitiatorInputEnvelope
    connect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
  }

  export type GameEventUncheckedCreateNestedManyWithoutTargetInput = {
    create?: XOR<GameEventCreateWithoutTargetInput, GameEventUncheckedCreateWithoutTargetInput> | GameEventCreateWithoutTargetInput[] | GameEventUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: GameEventCreateOrConnectWithoutTargetInput | GameEventCreateOrConnectWithoutTargetInput[]
    createMany?: GameEventCreateManyTargetInputEnvelope
    connect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TweetUpdateManyWithoutAgentNestedInput = {
    create?: XOR<TweetCreateWithoutAgentInput, TweetUncheckedCreateWithoutAgentInput> | TweetCreateWithoutAgentInput[] | TweetUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TweetCreateOrConnectWithoutAgentInput | TweetCreateOrConnectWithoutAgentInput[]
    upsert?: TweetUpsertWithWhereUniqueWithoutAgentInput | TweetUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: TweetCreateManyAgentInputEnvelope
    set?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    disconnect?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    delete?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    connect?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    update?: TweetUpdateWithWhereUniqueWithoutAgentInput | TweetUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: TweetUpdateManyWithWhereWithoutAgentInput | TweetUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: TweetScalarWhereInput | TweetScalarWhereInput[]
  }

  export type GameUpdateOneRequiredWithoutAgentsNestedInput = {
    create?: XOR<GameCreateWithoutAgentsInput, GameUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: GameCreateOrConnectWithoutAgentsInput
    upsert?: GameUpsertWithoutAgentsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutAgentsInput, GameUpdateWithoutAgentsInput>, GameUncheckedUpdateWithoutAgentsInput>
  }

  export type BattleUpdateManyWithoutAttackerNestedInput = {
    create?: XOR<BattleCreateWithoutAttackerInput, BattleUncheckedCreateWithoutAttackerInput> | BattleCreateWithoutAttackerInput[] | BattleUncheckedCreateWithoutAttackerInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutAttackerInput | BattleCreateOrConnectWithoutAttackerInput[]
    upsert?: BattleUpsertWithWhereUniqueWithoutAttackerInput | BattleUpsertWithWhereUniqueWithoutAttackerInput[]
    createMany?: BattleCreateManyAttackerInputEnvelope
    set?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    disconnect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    delete?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    update?: BattleUpdateWithWhereUniqueWithoutAttackerInput | BattleUpdateWithWhereUniqueWithoutAttackerInput[]
    updateMany?: BattleUpdateManyWithWhereWithoutAttackerInput | BattleUpdateManyWithWhereWithoutAttackerInput[]
    deleteMany?: BattleScalarWhereInput | BattleScalarWhereInput[]
  }

  export type BattleUpdateManyWithoutDefenderNestedInput = {
    create?: XOR<BattleCreateWithoutDefenderInput, BattleUncheckedCreateWithoutDefenderInput> | BattleCreateWithoutDefenderInput[] | BattleUncheckedCreateWithoutDefenderInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutDefenderInput | BattleCreateOrConnectWithoutDefenderInput[]
    upsert?: BattleUpsertWithWhereUniqueWithoutDefenderInput | BattleUpsertWithWhereUniqueWithoutDefenderInput[]
    createMany?: BattleCreateManyDefenderInputEnvelope
    set?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    disconnect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    delete?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    update?: BattleUpdateWithWhereUniqueWithoutDefenderInput | BattleUpdateWithWhereUniqueWithoutDefenderInput[]
    updateMany?: BattleUpdateManyWithWhereWithoutDefenderInput | BattleUpdateManyWithWhereWithoutDefenderInput[]
    deleteMany?: BattleScalarWhereInput | BattleScalarWhereInput[]
  }

  export type BattleUpdateManyWithoutAttackerAllyNestedInput = {
    create?: XOR<BattleCreateWithoutAttackerAllyInput, BattleUncheckedCreateWithoutAttackerAllyInput> | BattleCreateWithoutAttackerAllyInput[] | BattleUncheckedCreateWithoutAttackerAllyInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutAttackerAllyInput | BattleCreateOrConnectWithoutAttackerAllyInput[]
    upsert?: BattleUpsertWithWhereUniqueWithoutAttackerAllyInput | BattleUpsertWithWhereUniqueWithoutAttackerAllyInput[]
    createMany?: BattleCreateManyAttackerAllyInputEnvelope
    set?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    disconnect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    delete?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    update?: BattleUpdateWithWhereUniqueWithoutAttackerAllyInput | BattleUpdateWithWhereUniqueWithoutAttackerAllyInput[]
    updateMany?: BattleUpdateManyWithWhereWithoutAttackerAllyInput | BattleUpdateManyWithWhereWithoutAttackerAllyInput[]
    deleteMany?: BattleScalarWhereInput | BattleScalarWhereInput[]
  }

  export type BattleUpdateManyWithoutDefenderAllyNestedInput = {
    create?: XOR<BattleCreateWithoutDefenderAllyInput, BattleUncheckedCreateWithoutDefenderAllyInput> | BattleCreateWithoutDefenderAllyInput[] | BattleUncheckedCreateWithoutDefenderAllyInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutDefenderAllyInput | BattleCreateOrConnectWithoutDefenderAllyInput[]
    upsert?: BattleUpsertWithWhereUniqueWithoutDefenderAllyInput | BattleUpsertWithWhereUniqueWithoutDefenderAllyInput[]
    createMany?: BattleCreateManyDefenderAllyInputEnvelope
    set?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    disconnect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    delete?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    update?: BattleUpdateWithWhereUniqueWithoutDefenderAllyInput | BattleUpdateWithWhereUniqueWithoutDefenderAllyInput[]
    updateMany?: BattleUpdateManyWithWhereWithoutDefenderAllyInput | BattleUpdateManyWithWhereWithoutDefenderAllyInput[]
    deleteMany?: BattleScalarWhereInput | BattleScalarWhereInput[]
  }

  export type BattleUpdateManyWithoutWinnerNestedInput = {
    create?: XOR<BattleCreateWithoutWinnerInput, BattleUncheckedCreateWithoutWinnerInput> | BattleCreateWithoutWinnerInput[] | BattleUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutWinnerInput | BattleCreateOrConnectWithoutWinnerInput[]
    upsert?: BattleUpsertWithWhereUniqueWithoutWinnerInput | BattleUpsertWithWhereUniqueWithoutWinnerInput[]
    createMany?: BattleCreateManyWinnerInputEnvelope
    set?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    disconnect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    delete?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    update?: BattleUpdateWithWhereUniqueWithoutWinnerInput | BattleUpdateWithWhereUniqueWithoutWinnerInput[]
    updateMany?: BattleUpdateManyWithWhereWithoutWinnerInput | BattleUpdateManyWithWhereWithoutWinnerInput[]
    deleteMany?: BattleScalarWhereInput | BattleScalarWhereInput[]
  }

  export type CoolDownUpdateManyWithoutCooledAgentNestedInput = {
    create?: XOR<CoolDownCreateWithoutCooledAgentInput, CoolDownUncheckedCreateWithoutCooledAgentInput> | CoolDownCreateWithoutCooledAgentInput[] | CoolDownUncheckedCreateWithoutCooledAgentInput[]
    connectOrCreate?: CoolDownCreateOrConnectWithoutCooledAgentInput | CoolDownCreateOrConnectWithoutCooledAgentInput[]
    upsert?: CoolDownUpsertWithWhereUniqueWithoutCooledAgentInput | CoolDownUpsertWithWhereUniqueWithoutCooledAgentInput[]
    createMany?: CoolDownCreateManyCooledAgentInputEnvelope
    set?: CoolDownWhereUniqueInput | CoolDownWhereUniqueInput[]
    disconnect?: CoolDownWhereUniqueInput | CoolDownWhereUniqueInput[]
    delete?: CoolDownWhereUniqueInput | CoolDownWhereUniqueInput[]
    connect?: CoolDownWhereUniqueInput | CoolDownWhereUniqueInput[]
    update?: CoolDownUpdateWithWhereUniqueWithoutCooledAgentInput | CoolDownUpdateWithWhereUniqueWithoutCooledAgentInput[]
    updateMany?: CoolDownUpdateManyWithWhereWithoutCooledAgentInput | CoolDownUpdateManyWithWhereWithoutCooledAgentInput[]
    deleteMany?: CoolDownScalarWhereInput | CoolDownScalarWhereInput[]
  }

  export type AllianceUpdateManyWithoutInitiatorNestedInput = {
    create?: XOR<AllianceCreateWithoutInitiatorInput, AllianceUncheckedCreateWithoutInitiatorInput> | AllianceCreateWithoutInitiatorInput[] | AllianceUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: AllianceCreateOrConnectWithoutInitiatorInput | AllianceCreateOrConnectWithoutInitiatorInput[]
    upsert?: AllianceUpsertWithWhereUniqueWithoutInitiatorInput | AllianceUpsertWithWhereUniqueWithoutInitiatorInput[]
    createMany?: AllianceCreateManyInitiatorInputEnvelope
    set?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    disconnect?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    delete?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    connect?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    update?: AllianceUpdateWithWhereUniqueWithoutInitiatorInput | AllianceUpdateWithWhereUniqueWithoutInitiatorInput[]
    updateMany?: AllianceUpdateManyWithWhereWithoutInitiatorInput | AllianceUpdateManyWithWhereWithoutInitiatorInput[]
    deleteMany?: AllianceScalarWhereInput | AllianceScalarWhereInput[]
  }

  export type AllianceUpdateManyWithoutJoinerNestedInput = {
    create?: XOR<AllianceCreateWithoutJoinerInput, AllianceUncheckedCreateWithoutJoinerInput> | AllianceCreateWithoutJoinerInput[] | AllianceUncheckedCreateWithoutJoinerInput[]
    connectOrCreate?: AllianceCreateOrConnectWithoutJoinerInput | AllianceCreateOrConnectWithoutJoinerInput[]
    upsert?: AllianceUpsertWithWhereUniqueWithoutJoinerInput | AllianceUpsertWithWhereUniqueWithoutJoinerInput[]
    createMany?: AllianceCreateManyJoinerInputEnvelope
    set?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    disconnect?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    delete?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    connect?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    update?: AllianceUpdateWithWhereUniqueWithoutJoinerInput | AllianceUpdateWithWhereUniqueWithoutJoinerInput[]
    updateMany?: AllianceUpdateManyWithWhereWithoutJoinerInput | AllianceUpdateManyWithWhereWithoutJoinerInput[]
    deleteMany?: AllianceScalarWhereInput | AllianceScalarWhereInput[]
  }

  export type AgentProfileUpdateOneRequiredWithoutAgentsNestedInput = {
    create?: XOR<AgentProfileCreateWithoutAgentsInput, AgentProfileUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: AgentProfileCreateOrConnectWithoutAgentsInput
    upsert?: AgentProfileUpsertWithoutAgentsInput
    connect?: AgentProfileWhereUniqueInput
    update?: XOR<XOR<AgentProfileUpdateToOneWithWhereWithoutAgentsInput, AgentProfileUpdateWithoutAgentsInput>, AgentProfileUncheckedUpdateWithoutAgentsInput>
  }

  export type MapTileUpdateOneRequiredWithoutAgentNestedInput = {
    create?: XOR<MapTileCreateWithoutAgentInput, MapTileUncheckedCreateWithoutAgentInput>
    connectOrCreate?: MapTileCreateOrConnectWithoutAgentInput
    upsert?: MapTileUpsertWithoutAgentInput
    connect?: MapTileWhereUniqueInput
    update?: XOR<XOR<MapTileUpdateToOneWithWhereWithoutAgentInput, MapTileUpdateWithoutAgentInput>, MapTileUncheckedUpdateWithoutAgentInput>
  }

  export type IgnoreUpdateManyWithoutAgentNestedInput = {
    create?: XOR<IgnoreCreateWithoutAgentInput, IgnoreUncheckedCreateWithoutAgentInput> | IgnoreCreateWithoutAgentInput[] | IgnoreUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: IgnoreCreateOrConnectWithoutAgentInput | IgnoreCreateOrConnectWithoutAgentInput[]
    upsert?: IgnoreUpsertWithWhereUniqueWithoutAgentInput | IgnoreUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: IgnoreCreateManyAgentInputEnvelope
    set?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    disconnect?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    delete?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    connect?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    update?: IgnoreUpdateWithWhereUniqueWithoutAgentInput | IgnoreUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: IgnoreUpdateManyWithWhereWithoutAgentInput | IgnoreUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: IgnoreScalarWhereInput | IgnoreScalarWhereInput[]
  }

  export type IgnoreUpdateManyWithoutIgnoredAgentNestedInput = {
    create?: XOR<IgnoreCreateWithoutIgnoredAgentInput, IgnoreUncheckedCreateWithoutIgnoredAgentInput> | IgnoreCreateWithoutIgnoredAgentInput[] | IgnoreUncheckedCreateWithoutIgnoredAgentInput[]
    connectOrCreate?: IgnoreCreateOrConnectWithoutIgnoredAgentInput | IgnoreCreateOrConnectWithoutIgnoredAgentInput[]
    upsert?: IgnoreUpsertWithWhereUniqueWithoutIgnoredAgentInput | IgnoreUpsertWithWhereUniqueWithoutIgnoredAgentInput[]
    createMany?: IgnoreCreateManyIgnoredAgentInputEnvelope
    set?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    disconnect?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    delete?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    connect?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    update?: IgnoreUpdateWithWhereUniqueWithoutIgnoredAgentInput | IgnoreUpdateWithWhereUniqueWithoutIgnoredAgentInput[]
    updateMany?: IgnoreUpdateManyWithWhereWithoutIgnoredAgentInput | IgnoreUpdateManyWithWhereWithoutIgnoredAgentInput[]
    deleteMany?: IgnoreScalarWhereInput | IgnoreScalarWhereInput[]
  }

  export type GameLogUpdateManyWithoutAgentNestedInput = {
    create?: XOR<GameLogCreateWithoutAgentInput, GameLogUncheckedCreateWithoutAgentInput> | GameLogCreateWithoutAgentInput[] | GameLogUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: GameLogCreateOrConnectWithoutAgentInput | GameLogCreateOrConnectWithoutAgentInput[]
    upsert?: GameLogUpsertWithWhereUniqueWithoutAgentInput | GameLogUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: GameLogCreateManyAgentInputEnvelope
    set?: GameLogWhereUniqueInput | GameLogWhereUniqueInput[]
    disconnect?: GameLogWhereUniqueInput | GameLogWhereUniqueInput[]
    delete?: GameLogWhereUniqueInput | GameLogWhereUniqueInput[]
    connect?: GameLogWhereUniqueInput | GameLogWhereUniqueInput[]
    update?: GameLogUpdateWithWhereUniqueWithoutAgentInput | GameLogUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: GameLogUpdateManyWithWhereWithoutAgentInput | GameLogUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: GameLogScalarWhereInput | GameLogScalarWhereInput[]
  }

  export type GameEventUpdateManyWithoutInitiatorNestedInput = {
    create?: XOR<GameEventCreateWithoutInitiatorInput, GameEventUncheckedCreateWithoutInitiatorInput> | GameEventCreateWithoutInitiatorInput[] | GameEventUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: GameEventCreateOrConnectWithoutInitiatorInput | GameEventCreateOrConnectWithoutInitiatorInput[]
    upsert?: GameEventUpsertWithWhereUniqueWithoutInitiatorInput | GameEventUpsertWithWhereUniqueWithoutInitiatorInput[]
    createMany?: GameEventCreateManyInitiatorInputEnvelope
    set?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    disconnect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    delete?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    connect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    update?: GameEventUpdateWithWhereUniqueWithoutInitiatorInput | GameEventUpdateWithWhereUniqueWithoutInitiatorInput[]
    updateMany?: GameEventUpdateManyWithWhereWithoutInitiatorInput | GameEventUpdateManyWithWhereWithoutInitiatorInput[]
    deleteMany?: GameEventScalarWhereInput | GameEventScalarWhereInput[]
  }

  export type GameEventUpdateManyWithoutTargetNestedInput = {
    create?: XOR<GameEventCreateWithoutTargetInput, GameEventUncheckedCreateWithoutTargetInput> | GameEventCreateWithoutTargetInput[] | GameEventUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: GameEventCreateOrConnectWithoutTargetInput | GameEventCreateOrConnectWithoutTargetInput[]
    upsert?: GameEventUpsertWithWhereUniqueWithoutTargetInput | GameEventUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: GameEventCreateManyTargetInputEnvelope
    set?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    disconnect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    delete?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    connect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    update?: GameEventUpdateWithWhereUniqueWithoutTargetInput | GameEventUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: GameEventUpdateManyWithWhereWithoutTargetInput | GameEventUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: GameEventScalarWhereInput | GameEventScalarWhereInput[]
  }

  export type TweetUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<TweetCreateWithoutAgentInput, TweetUncheckedCreateWithoutAgentInput> | TweetCreateWithoutAgentInput[] | TweetUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TweetCreateOrConnectWithoutAgentInput | TweetCreateOrConnectWithoutAgentInput[]
    upsert?: TweetUpsertWithWhereUniqueWithoutAgentInput | TweetUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: TweetCreateManyAgentInputEnvelope
    set?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    disconnect?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    delete?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    connect?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    update?: TweetUpdateWithWhereUniqueWithoutAgentInput | TweetUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: TweetUpdateManyWithWhereWithoutAgentInput | TweetUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: TweetScalarWhereInput | TweetScalarWhereInput[]
  }

  export type BattleUncheckedUpdateManyWithoutAttackerNestedInput = {
    create?: XOR<BattleCreateWithoutAttackerInput, BattleUncheckedCreateWithoutAttackerInput> | BattleCreateWithoutAttackerInput[] | BattleUncheckedCreateWithoutAttackerInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutAttackerInput | BattleCreateOrConnectWithoutAttackerInput[]
    upsert?: BattleUpsertWithWhereUniqueWithoutAttackerInput | BattleUpsertWithWhereUniqueWithoutAttackerInput[]
    createMany?: BattleCreateManyAttackerInputEnvelope
    set?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    disconnect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    delete?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    update?: BattleUpdateWithWhereUniqueWithoutAttackerInput | BattleUpdateWithWhereUniqueWithoutAttackerInput[]
    updateMany?: BattleUpdateManyWithWhereWithoutAttackerInput | BattleUpdateManyWithWhereWithoutAttackerInput[]
    deleteMany?: BattleScalarWhereInput | BattleScalarWhereInput[]
  }

  export type BattleUncheckedUpdateManyWithoutDefenderNestedInput = {
    create?: XOR<BattleCreateWithoutDefenderInput, BattleUncheckedCreateWithoutDefenderInput> | BattleCreateWithoutDefenderInput[] | BattleUncheckedCreateWithoutDefenderInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutDefenderInput | BattleCreateOrConnectWithoutDefenderInput[]
    upsert?: BattleUpsertWithWhereUniqueWithoutDefenderInput | BattleUpsertWithWhereUniqueWithoutDefenderInput[]
    createMany?: BattleCreateManyDefenderInputEnvelope
    set?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    disconnect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    delete?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    update?: BattleUpdateWithWhereUniqueWithoutDefenderInput | BattleUpdateWithWhereUniqueWithoutDefenderInput[]
    updateMany?: BattleUpdateManyWithWhereWithoutDefenderInput | BattleUpdateManyWithWhereWithoutDefenderInput[]
    deleteMany?: BattleScalarWhereInput | BattleScalarWhereInput[]
  }

  export type BattleUncheckedUpdateManyWithoutAttackerAllyNestedInput = {
    create?: XOR<BattleCreateWithoutAttackerAllyInput, BattleUncheckedCreateWithoutAttackerAllyInput> | BattleCreateWithoutAttackerAllyInput[] | BattleUncheckedCreateWithoutAttackerAllyInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutAttackerAllyInput | BattleCreateOrConnectWithoutAttackerAllyInput[]
    upsert?: BattleUpsertWithWhereUniqueWithoutAttackerAllyInput | BattleUpsertWithWhereUniqueWithoutAttackerAllyInput[]
    createMany?: BattleCreateManyAttackerAllyInputEnvelope
    set?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    disconnect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    delete?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    update?: BattleUpdateWithWhereUniqueWithoutAttackerAllyInput | BattleUpdateWithWhereUniqueWithoutAttackerAllyInput[]
    updateMany?: BattleUpdateManyWithWhereWithoutAttackerAllyInput | BattleUpdateManyWithWhereWithoutAttackerAllyInput[]
    deleteMany?: BattleScalarWhereInput | BattleScalarWhereInput[]
  }

  export type BattleUncheckedUpdateManyWithoutDefenderAllyNestedInput = {
    create?: XOR<BattleCreateWithoutDefenderAllyInput, BattleUncheckedCreateWithoutDefenderAllyInput> | BattleCreateWithoutDefenderAllyInput[] | BattleUncheckedCreateWithoutDefenderAllyInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutDefenderAllyInput | BattleCreateOrConnectWithoutDefenderAllyInput[]
    upsert?: BattleUpsertWithWhereUniqueWithoutDefenderAllyInput | BattleUpsertWithWhereUniqueWithoutDefenderAllyInput[]
    createMany?: BattleCreateManyDefenderAllyInputEnvelope
    set?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    disconnect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    delete?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    update?: BattleUpdateWithWhereUniqueWithoutDefenderAllyInput | BattleUpdateWithWhereUniqueWithoutDefenderAllyInput[]
    updateMany?: BattleUpdateManyWithWhereWithoutDefenderAllyInput | BattleUpdateManyWithWhereWithoutDefenderAllyInput[]
    deleteMany?: BattleScalarWhereInput | BattleScalarWhereInput[]
  }

  export type BattleUncheckedUpdateManyWithoutWinnerNestedInput = {
    create?: XOR<BattleCreateWithoutWinnerInput, BattleUncheckedCreateWithoutWinnerInput> | BattleCreateWithoutWinnerInput[] | BattleUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutWinnerInput | BattleCreateOrConnectWithoutWinnerInput[]
    upsert?: BattleUpsertWithWhereUniqueWithoutWinnerInput | BattleUpsertWithWhereUniqueWithoutWinnerInput[]
    createMany?: BattleCreateManyWinnerInputEnvelope
    set?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    disconnect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    delete?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    update?: BattleUpdateWithWhereUniqueWithoutWinnerInput | BattleUpdateWithWhereUniqueWithoutWinnerInput[]
    updateMany?: BattleUpdateManyWithWhereWithoutWinnerInput | BattleUpdateManyWithWhereWithoutWinnerInput[]
    deleteMany?: BattleScalarWhereInput | BattleScalarWhereInput[]
  }

  export type CoolDownUncheckedUpdateManyWithoutCooledAgentNestedInput = {
    create?: XOR<CoolDownCreateWithoutCooledAgentInput, CoolDownUncheckedCreateWithoutCooledAgentInput> | CoolDownCreateWithoutCooledAgentInput[] | CoolDownUncheckedCreateWithoutCooledAgentInput[]
    connectOrCreate?: CoolDownCreateOrConnectWithoutCooledAgentInput | CoolDownCreateOrConnectWithoutCooledAgentInput[]
    upsert?: CoolDownUpsertWithWhereUniqueWithoutCooledAgentInput | CoolDownUpsertWithWhereUniqueWithoutCooledAgentInput[]
    createMany?: CoolDownCreateManyCooledAgentInputEnvelope
    set?: CoolDownWhereUniqueInput | CoolDownWhereUniqueInput[]
    disconnect?: CoolDownWhereUniqueInput | CoolDownWhereUniqueInput[]
    delete?: CoolDownWhereUniqueInput | CoolDownWhereUniqueInput[]
    connect?: CoolDownWhereUniqueInput | CoolDownWhereUniqueInput[]
    update?: CoolDownUpdateWithWhereUniqueWithoutCooledAgentInput | CoolDownUpdateWithWhereUniqueWithoutCooledAgentInput[]
    updateMany?: CoolDownUpdateManyWithWhereWithoutCooledAgentInput | CoolDownUpdateManyWithWhereWithoutCooledAgentInput[]
    deleteMany?: CoolDownScalarWhereInput | CoolDownScalarWhereInput[]
  }

  export type AllianceUncheckedUpdateManyWithoutInitiatorNestedInput = {
    create?: XOR<AllianceCreateWithoutInitiatorInput, AllianceUncheckedCreateWithoutInitiatorInput> | AllianceCreateWithoutInitiatorInput[] | AllianceUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: AllianceCreateOrConnectWithoutInitiatorInput | AllianceCreateOrConnectWithoutInitiatorInput[]
    upsert?: AllianceUpsertWithWhereUniqueWithoutInitiatorInput | AllianceUpsertWithWhereUniqueWithoutInitiatorInput[]
    createMany?: AllianceCreateManyInitiatorInputEnvelope
    set?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    disconnect?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    delete?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    connect?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    update?: AllianceUpdateWithWhereUniqueWithoutInitiatorInput | AllianceUpdateWithWhereUniqueWithoutInitiatorInput[]
    updateMany?: AllianceUpdateManyWithWhereWithoutInitiatorInput | AllianceUpdateManyWithWhereWithoutInitiatorInput[]
    deleteMany?: AllianceScalarWhereInput | AllianceScalarWhereInput[]
  }

  export type AllianceUncheckedUpdateManyWithoutJoinerNestedInput = {
    create?: XOR<AllianceCreateWithoutJoinerInput, AllianceUncheckedCreateWithoutJoinerInput> | AllianceCreateWithoutJoinerInput[] | AllianceUncheckedCreateWithoutJoinerInput[]
    connectOrCreate?: AllianceCreateOrConnectWithoutJoinerInput | AllianceCreateOrConnectWithoutJoinerInput[]
    upsert?: AllianceUpsertWithWhereUniqueWithoutJoinerInput | AllianceUpsertWithWhereUniqueWithoutJoinerInput[]
    createMany?: AllianceCreateManyJoinerInputEnvelope
    set?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    disconnect?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    delete?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    connect?: AllianceWhereUniqueInput | AllianceWhereUniqueInput[]
    update?: AllianceUpdateWithWhereUniqueWithoutJoinerInput | AllianceUpdateWithWhereUniqueWithoutJoinerInput[]
    updateMany?: AllianceUpdateManyWithWhereWithoutJoinerInput | AllianceUpdateManyWithWhereWithoutJoinerInput[]
    deleteMany?: AllianceScalarWhereInput | AllianceScalarWhereInput[]
  }

  export type IgnoreUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<IgnoreCreateWithoutAgentInput, IgnoreUncheckedCreateWithoutAgentInput> | IgnoreCreateWithoutAgentInput[] | IgnoreUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: IgnoreCreateOrConnectWithoutAgentInput | IgnoreCreateOrConnectWithoutAgentInput[]
    upsert?: IgnoreUpsertWithWhereUniqueWithoutAgentInput | IgnoreUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: IgnoreCreateManyAgentInputEnvelope
    set?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    disconnect?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    delete?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    connect?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    update?: IgnoreUpdateWithWhereUniqueWithoutAgentInput | IgnoreUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: IgnoreUpdateManyWithWhereWithoutAgentInput | IgnoreUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: IgnoreScalarWhereInput | IgnoreScalarWhereInput[]
  }

  export type IgnoreUncheckedUpdateManyWithoutIgnoredAgentNestedInput = {
    create?: XOR<IgnoreCreateWithoutIgnoredAgentInput, IgnoreUncheckedCreateWithoutIgnoredAgentInput> | IgnoreCreateWithoutIgnoredAgentInput[] | IgnoreUncheckedCreateWithoutIgnoredAgentInput[]
    connectOrCreate?: IgnoreCreateOrConnectWithoutIgnoredAgentInput | IgnoreCreateOrConnectWithoutIgnoredAgentInput[]
    upsert?: IgnoreUpsertWithWhereUniqueWithoutIgnoredAgentInput | IgnoreUpsertWithWhereUniqueWithoutIgnoredAgentInput[]
    createMany?: IgnoreCreateManyIgnoredAgentInputEnvelope
    set?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    disconnect?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    delete?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    connect?: IgnoreWhereUniqueInput | IgnoreWhereUniqueInput[]
    update?: IgnoreUpdateWithWhereUniqueWithoutIgnoredAgentInput | IgnoreUpdateWithWhereUniqueWithoutIgnoredAgentInput[]
    updateMany?: IgnoreUpdateManyWithWhereWithoutIgnoredAgentInput | IgnoreUpdateManyWithWhereWithoutIgnoredAgentInput[]
    deleteMany?: IgnoreScalarWhereInput | IgnoreScalarWhereInput[]
  }

  export type GameLogUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<GameLogCreateWithoutAgentInput, GameLogUncheckedCreateWithoutAgentInput> | GameLogCreateWithoutAgentInput[] | GameLogUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: GameLogCreateOrConnectWithoutAgentInput | GameLogCreateOrConnectWithoutAgentInput[]
    upsert?: GameLogUpsertWithWhereUniqueWithoutAgentInput | GameLogUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: GameLogCreateManyAgentInputEnvelope
    set?: GameLogWhereUniqueInput | GameLogWhereUniqueInput[]
    disconnect?: GameLogWhereUniqueInput | GameLogWhereUniqueInput[]
    delete?: GameLogWhereUniqueInput | GameLogWhereUniqueInput[]
    connect?: GameLogWhereUniqueInput | GameLogWhereUniqueInput[]
    update?: GameLogUpdateWithWhereUniqueWithoutAgentInput | GameLogUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: GameLogUpdateManyWithWhereWithoutAgentInput | GameLogUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: GameLogScalarWhereInput | GameLogScalarWhereInput[]
  }

  export type GameEventUncheckedUpdateManyWithoutInitiatorNestedInput = {
    create?: XOR<GameEventCreateWithoutInitiatorInput, GameEventUncheckedCreateWithoutInitiatorInput> | GameEventCreateWithoutInitiatorInput[] | GameEventUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: GameEventCreateOrConnectWithoutInitiatorInput | GameEventCreateOrConnectWithoutInitiatorInput[]
    upsert?: GameEventUpsertWithWhereUniqueWithoutInitiatorInput | GameEventUpsertWithWhereUniqueWithoutInitiatorInput[]
    createMany?: GameEventCreateManyInitiatorInputEnvelope
    set?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    disconnect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    delete?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    connect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    update?: GameEventUpdateWithWhereUniqueWithoutInitiatorInput | GameEventUpdateWithWhereUniqueWithoutInitiatorInput[]
    updateMany?: GameEventUpdateManyWithWhereWithoutInitiatorInput | GameEventUpdateManyWithWhereWithoutInitiatorInput[]
    deleteMany?: GameEventScalarWhereInput | GameEventScalarWhereInput[]
  }

  export type GameEventUncheckedUpdateManyWithoutTargetNestedInput = {
    create?: XOR<GameEventCreateWithoutTargetInput, GameEventUncheckedCreateWithoutTargetInput> | GameEventCreateWithoutTargetInput[] | GameEventUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: GameEventCreateOrConnectWithoutTargetInput | GameEventCreateOrConnectWithoutTargetInput[]
    upsert?: GameEventUpsertWithWhereUniqueWithoutTargetInput | GameEventUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: GameEventCreateManyTargetInputEnvelope
    set?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    disconnect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    delete?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    connect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    update?: GameEventUpdateWithWhereUniqueWithoutTargetInput | GameEventUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: GameEventUpdateManyWithWhereWithoutTargetInput | GameEventUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: GameEventScalarWhereInput | GameEventScalarWhereInput[]
  }

  export type AgentCreateNestedOneWithoutIgnoredByInput = {
    create?: XOR<AgentCreateWithoutIgnoredByInput, AgentUncheckedCreateWithoutIgnoredByInput>
    connectOrCreate?: AgentCreateOrConnectWithoutIgnoredByInput
    connect?: AgentWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutIgnoreInput = {
    create?: XOR<GameCreateWithoutIgnoreInput, GameUncheckedCreateWithoutIgnoreInput>
    connectOrCreate?: GameCreateOrConnectWithoutIgnoreInput
    connect?: GameWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutIgnoringInput = {
    create?: XOR<AgentCreateWithoutIgnoringInput, AgentUncheckedCreateWithoutIgnoringInput>
    connectOrCreate?: AgentCreateOrConnectWithoutIgnoringInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutIgnoredByNestedInput = {
    create?: XOR<AgentCreateWithoutIgnoredByInput, AgentUncheckedCreateWithoutIgnoredByInput>
    connectOrCreate?: AgentCreateOrConnectWithoutIgnoredByInput
    upsert?: AgentUpsertWithoutIgnoredByInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutIgnoredByInput, AgentUpdateWithoutIgnoredByInput>, AgentUncheckedUpdateWithoutIgnoredByInput>
  }

  export type GameUpdateOneRequiredWithoutIgnoreNestedInput = {
    create?: XOR<GameCreateWithoutIgnoreInput, GameUncheckedCreateWithoutIgnoreInput>
    connectOrCreate?: GameCreateOrConnectWithoutIgnoreInput
    upsert?: GameUpsertWithoutIgnoreInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutIgnoreInput, GameUpdateWithoutIgnoreInput>, GameUncheckedUpdateWithoutIgnoreInput>
  }

  export type AgentUpdateOneRequiredWithoutIgnoringNestedInput = {
    create?: XOR<AgentCreateWithoutIgnoringInput, AgentUncheckedCreateWithoutIgnoringInput>
    connectOrCreate?: AgentCreateOrConnectWithoutIgnoringInput
    upsert?: AgentUpsertWithoutIgnoringInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutIgnoringInput, AgentUpdateWithoutIgnoringInput>, AgentUncheckedUpdateWithoutIgnoringInput>
  }

  export type AgentCreateNestedOneWithoutMapTileInput = {
    create?: XOR<AgentCreateWithoutMapTileInput, AgentUncheckedCreateWithoutMapTileInput>
    connectOrCreate?: AgentCreateOrConnectWithoutMapTileInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentUncheckedCreateNestedOneWithoutMapTileInput = {
    create?: XOR<AgentCreateWithoutMapTileInput, AgentUncheckedCreateWithoutMapTileInput>
    connectOrCreate?: AgentCreateOrConnectWithoutMapTileInput
    connect?: AgentWhereUniqueInput
  }

  export type EnumTerrainTypeFieldUpdateOperationsInput = {
    set?: $Enums.TerrainType
  }

  export type AgentUpdateOneWithoutMapTileNestedInput = {
    create?: XOR<AgentCreateWithoutMapTileInput, AgentUncheckedCreateWithoutMapTileInput>
    connectOrCreate?: AgentCreateOrConnectWithoutMapTileInput
    upsert?: AgentUpsertWithoutMapTileInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutMapTileInput, AgentUpdateWithoutMapTileInput>, AgentUncheckedUpdateWithoutMapTileInput>
  }

  export type AgentUncheckedUpdateOneWithoutMapTileNestedInput = {
    create?: XOR<AgentCreateWithoutMapTileInput, AgentUncheckedCreateWithoutMapTileInput>
    connectOrCreate?: AgentCreateOrConnectWithoutMapTileInput
    upsert?: AgentUpsertWithoutMapTileInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutMapTileInput, AgentUpdateWithoutMapTileInput>, AgentUncheckedUpdateWithoutMapTileInput>
  }

  export type AgentCreateNestedOneWithoutTweetsInput = {
    create?: XOR<AgentCreateWithoutTweetsInput, AgentUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutTweetsInput
    connect?: AgentWhereUniqueInput
  }

  export type InteractionCreateNestedManyWithoutTweetInput = {
    create?: XOR<InteractionCreateWithoutTweetInput, InteractionUncheckedCreateWithoutTweetInput> | InteractionCreateWithoutTweetInput[] | InteractionUncheckedCreateWithoutTweetInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutTweetInput | InteractionCreateOrConnectWithoutTweetInput[]
    createMany?: InteractionCreateManyTweetInputEnvelope
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
  }

  export type InteractionUncheckedCreateNestedManyWithoutTweetInput = {
    create?: XOR<InteractionCreateWithoutTweetInput, InteractionUncheckedCreateWithoutTweetInput> | InteractionCreateWithoutTweetInput[] | InteractionUncheckedCreateWithoutTweetInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutTweetInput | InteractionCreateOrConnectWithoutTweetInput[]
    createMany?: InteractionCreateManyTweetInputEnvelope
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
  }

  export type AgentUpdateOneRequiredWithoutTweetsNestedInput = {
    create?: XOR<AgentCreateWithoutTweetsInput, AgentUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutTweetsInput
    upsert?: AgentUpsertWithoutTweetsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutTweetsInput, AgentUpdateWithoutTweetsInput>, AgentUncheckedUpdateWithoutTweetsInput>
  }

  export type InteractionUpdateManyWithoutTweetNestedInput = {
    create?: XOR<InteractionCreateWithoutTweetInput, InteractionUncheckedCreateWithoutTweetInput> | InteractionCreateWithoutTweetInput[] | InteractionUncheckedCreateWithoutTweetInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutTweetInput | InteractionCreateOrConnectWithoutTweetInput[]
    upsert?: InteractionUpsertWithWhereUniqueWithoutTweetInput | InteractionUpsertWithWhereUniqueWithoutTweetInput[]
    createMany?: InteractionCreateManyTweetInputEnvelope
    set?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    disconnect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    delete?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    update?: InteractionUpdateWithWhereUniqueWithoutTweetInput | InteractionUpdateWithWhereUniqueWithoutTweetInput[]
    updateMany?: InteractionUpdateManyWithWhereWithoutTweetInput | InteractionUpdateManyWithWhereWithoutTweetInput[]
    deleteMany?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
  }

  export type InteractionUncheckedUpdateManyWithoutTweetNestedInput = {
    create?: XOR<InteractionCreateWithoutTweetInput, InteractionUncheckedCreateWithoutTweetInput> | InteractionCreateWithoutTweetInput[] | InteractionUncheckedCreateWithoutTweetInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutTweetInput | InteractionCreateOrConnectWithoutTweetInput[]
    upsert?: InteractionUpsertWithWhereUniqueWithoutTweetInput | InteractionUpsertWithWhereUniqueWithoutTweetInput[]
    createMany?: InteractionCreateManyTweetInputEnvelope
    set?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    disconnect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    delete?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    update?: InteractionUpdateWithWhereUniqueWithoutTweetInput | InteractionUpdateWithWhereUniqueWithoutTweetInput[]
    updateMany?: InteractionUpdateManyWithWhereWithoutTweetInput | InteractionUpdateManyWithWhereWithoutTweetInput[]
    deleteMany?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
  }

  export type GameCreateNestedOneWithoutAlliancesInput = {
    create?: XOR<GameCreateWithoutAlliancesInput, GameUncheckedCreateWithoutAlliancesInput>
    connectOrCreate?: GameCreateOrConnectWithoutAlliancesInput
    connect?: GameWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutInitiatedAlliancesInput = {
    create?: XOR<AgentCreateWithoutInitiatedAlliancesInput, AgentUncheckedCreateWithoutInitiatedAlliancesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutInitiatedAlliancesInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutJoinedAlliancesInput = {
    create?: XOR<AgentCreateWithoutJoinedAlliancesInput, AgentUncheckedCreateWithoutJoinedAlliancesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutJoinedAlliancesInput
    connect?: AgentWhereUniqueInput
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EnumAllianceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AllianceStatus
  }

  export type GameUpdateOneRequiredWithoutAlliancesNestedInput = {
    create?: XOR<GameCreateWithoutAlliancesInput, GameUncheckedCreateWithoutAlliancesInput>
    connectOrCreate?: GameCreateOrConnectWithoutAlliancesInput
    upsert?: GameUpsertWithoutAlliancesInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutAlliancesInput, GameUpdateWithoutAlliancesInput>, GameUncheckedUpdateWithoutAlliancesInput>
  }

  export type AgentUpdateOneRequiredWithoutInitiatedAlliancesNestedInput = {
    create?: XOR<AgentCreateWithoutInitiatedAlliancesInput, AgentUncheckedCreateWithoutInitiatedAlliancesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutInitiatedAlliancesInput
    upsert?: AgentUpsertWithoutInitiatedAlliancesInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutInitiatedAlliancesInput, AgentUpdateWithoutInitiatedAlliancesInput>, AgentUncheckedUpdateWithoutInitiatedAlliancesInput>
  }

  export type AgentUpdateOneRequiredWithoutJoinedAlliancesNestedInput = {
    create?: XOR<AgentCreateWithoutJoinedAlliancesInput, AgentUncheckedCreateWithoutJoinedAlliancesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutJoinedAlliancesInput
    upsert?: AgentUpsertWithoutJoinedAlliancesInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutJoinedAlliancesInput, AgentUpdateWithoutJoinedAlliancesInput>, AgentUncheckedUpdateWithoutJoinedAlliancesInput>
  }

  export type GameCreateNestedOneWithoutBattlesInput = {
    create?: XOR<GameCreateWithoutBattlesInput, GameUncheckedCreateWithoutBattlesInput>
    connectOrCreate?: GameCreateOrConnectWithoutBattlesInput
    connect?: GameWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutBattlesAsAttackerInput = {
    create?: XOR<AgentCreateWithoutBattlesAsAttackerInput, AgentUncheckedCreateWithoutBattlesAsAttackerInput>
    connectOrCreate?: AgentCreateOrConnectWithoutBattlesAsAttackerInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutBattlesAsDefenderInput = {
    create?: XOR<AgentCreateWithoutBattlesAsDefenderInput, AgentUncheckedCreateWithoutBattlesAsDefenderInput>
    connectOrCreate?: AgentCreateOrConnectWithoutBattlesAsDefenderInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutBattlesAsAttackerAllyInput = {
    create?: XOR<AgentCreateWithoutBattlesAsAttackerAllyInput, AgentUncheckedCreateWithoutBattlesAsAttackerAllyInput>
    connectOrCreate?: AgentCreateOrConnectWithoutBattlesAsAttackerAllyInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutBattlesAsDefenderAllyInput = {
    create?: XOR<AgentCreateWithoutBattlesAsDefenderAllyInput, AgentUncheckedCreateWithoutBattlesAsDefenderAllyInput>
    connectOrCreate?: AgentCreateOrConnectWithoutBattlesAsDefenderAllyInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutWonBattlesInput = {
    create?: XOR<AgentCreateWithoutWonBattlesInput, AgentUncheckedCreateWithoutWonBattlesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutWonBattlesInput
    connect?: AgentWhereUniqueInput
  }

  export type EnumBattleTypeFieldUpdateOperationsInput = {
    set?: $Enums.BattleType
  }

  export type EnumBattleStatusFieldUpdateOperationsInput = {
    set?: $Enums.BattleStatus
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type GameUpdateOneRequiredWithoutBattlesNestedInput = {
    create?: XOR<GameCreateWithoutBattlesInput, GameUncheckedCreateWithoutBattlesInput>
    connectOrCreate?: GameCreateOrConnectWithoutBattlesInput
    upsert?: GameUpsertWithoutBattlesInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutBattlesInput, GameUpdateWithoutBattlesInput>, GameUncheckedUpdateWithoutBattlesInput>
  }

  export type AgentUpdateOneRequiredWithoutBattlesAsAttackerNestedInput = {
    create?: XOR<AgentCreateWithoutBattlesAsAttackerInput, AgentUncheckedCreateWithoutBattlesAsAttackerInput>
    connectOrCreate?: AgentCreateOrConnectWithoutBattlesAsAttackerInput
    upsert?: AgentUpsertWithoutBattlesAsAttackerInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutBattlesAsAttackerInput, AgentUpdateWithoutBattlesAsAttackerInput>, AgentUncheckedUpdateWithoutBattlesAsAttackerInput>
  }

  export type AgentUpdateOneRequiredWithoutBattlesAsDefenderNestedInput = {
    create?: XOR<AgentCreateWithoutBattlesAsDefenderInput, AgentUncheckedCreateWithoutBattlesAsDefenderInput>
    connectOrCreate?: AgentCreateOrConnectWithoutBattlesAsDefenderInput
    upsert?: AgentUpsertWithoutBattlesAsDefenderInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutBattlesAsDefenderInput, AgentUpdateWithoutBattlesAsDefenderInput>, AgentUncheckedUpdateWithoutBattlesAsDefenderInput>
  }

  export type AgentUpdateOneWithoutBattlesAsAttackerAllyNestedInput = {
    create?: XOR<AgentCreateWithoutBattlesAsAttackerAllyInput, AgentUncheckedCreateWithoutBattlesAsAttackerAllyInput>
    connectOrCreate?: AgentCreateOrConnectWithoutBattlesAsAttackerAllyInput
    upsert?: AgentUpsertWithoutBattlesAsAttackerAllyInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutBattlesAsAttackerAllyInput, AgentUpdateWithoutBattlesAsAttackerAllyInput>, AgentUncheckedUpdateWithoutBattlesAsAttackerAllyInput>
  }

  export type AgentUpdateOneWithoutBattlesAsDefenderAllyNestedInput = {
    create?: XOR<AgentCreateWithoutBattlesAsDefenderAllyInput, AgentUncheckedCreateWithoutBattlesAsDefenderAllyInput>
    connectOrCreate?: AgentCreateOrConnectWithoutBattlesAsDefenderAllyInput
    upsert?: AgentUpsertWithoutBattlesAsDefenderAllyInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutBattlesAsDefenderAllyInput, AgentUpdateWithoutBattlesAsDefenderAllyInput>, AgentUncheckedUpdateWithoutBattlesAsDefenderAllyInput>
  }

  export type AgentUpdateOneWithoutWonBattlesNestedInput = {
    create?: XOR<AgentCreateWithoutWonBattlesInput, AgentUncheckedCreateWithoutWonBattlesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutWonBattlesInput
    upsert?: AgentUpsertWithoutWonBattlesInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutWonBattlesInput, AgentUpdateWithoutWonBattlesInput>, AgentUncheckedUpdateWithoutWonBattlesInput>
  }

  export type TweetCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<TweetCreateWithoutInteractionsInput, TweetUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: TweetCreateOrConnectWithoutInteractionsInput
    connect?: TweetWhereUniqueInput
  }

  export type EnumInteractionTypeFieldUpdateOperationsInput = {
    set?: $Enums.InteractionType
  }

  export type TweetUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<TweetCreateWithoutInteractionsInput, TweetUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: TweetCreateOrConnectWithoutInteractionsInput
    upsert?: TweetUpsertWithoutInteractionsInput
    connect?: TweetWhereUniqueInput
    update?: XOR<XOR<TweetUpdateToOneWithWhereWithoutInteractionsInput, TweetUpdateWithoutInteractionsInput>, TweetUncheckedUpdateWithoutInteractionsInput>
  }

  export type AgentCreateNestedOneWithoutCoolDownInput = {
    create?: XOR<AgentCreateWithoutCoolDownInput, AgentUncheckedCreateWithoutCoolDownInput>
    connectOrCreate?: AgentCreateOrConnectWithoutCoolDownInput
    connect?: AgentWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutCoolDownInput = {
    create?: XOR<GameCreateWithoutCoolDownInput, GameUncheckedCreateWithoutCoolDownInput>
    connectOrCreate?: GameCreateOrConnectWithoutCoolDownInput
    connect?: GameWhereUniqueInput
  }

  export type EnumCooldownTypeFieldUpdateOperationsInput = {
    set?: $Enums.CooldownType
  }

  export type AgentUpdateOneRequiredWithoutCoolDownNestedInput = {
    create?: XOR<AgentCreateWithoutCoolDownInput, AgentUncheckedCreateWithoutCoolDownInput>
    connectOrCreate?: AgentCreateOrConnectWithoutCoolDownInput
    upsert?: AgentUpsertWithoutCoolDownInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutCoolDownInput, AgentUpdateWithoutCoolDownInput>, AgentUncheckedUpdateWithoutCoolDownInput>
  }

  export type GameUpdateOneRequiredWithoutCoolDownNestedInput = {
    create?: XOR<GameCreateWithoutCoolDownInput, GameUncheckedCreateWithoutCoolDownInput>
    connectOrCreate?: GameCreateOrConnectWithoutCoolDownInput
    upsert?: GameUpsertWithoutCoolDownInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutCoolDownInput, GameUpdateWithoutCoolDownInput>, GameUncheckedUpdateWithoutCoolDownInput>
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type AgentCreateNestedOneWithoutGameLogInput = {
    create?: XOR<AgentCreateWithoutGameLogInput, AgentUncheckedCreateWithoutGameLogInput>
    connectOrCreate?: AgentCreateOrConnectWithoutGameLogInput
    connect?: AgentWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutGameLogInput = {
    create?: XOR<GameCreateWithoutGameLogInput, GameUncheckedCreateWithoutGameLogInput>
    connectOrCreate?: GameCreateOrConnectWithoutGameLogInput
    connect?: GameWhereUniqueInput
  }

  export type AgentUpdateOneWithoutGameLogNestedInput = {
    create?: XOR<AgentCreateWithoutGameLogInput, AgentUncheckedCreateWithoutGameLogInput>
    connectOrCreate?: AgentCreateOrConnectWithoutGameLogInput
    upsert?: AgentUpsertWithoutGameLogInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutGameLogInput, AgentUpdateWithoutGameLogInput>, AgentUncheckedUpdateWithoutGameLogInput>
  }

  export type GameUpdateOneWithoutGameLogNestedInput = {
    create?: XOR<GameCreateWithoutGameLogInput, GameUncheckedCreateWithoutGameLogInput>
    connectOrCreate?: GameCreateOrConnectWithoutGameLogInput
    upsert?: GameUpsertWithoutGameLogInput
    disconnect?: GameWhereInput | boolean
    delete?: GameWhereInput | boolean
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutGameLogInput, GameUpdateWithoutGameLogInput>, GameUncheckedUpdateWithoutGameLogInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTerrainTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TerrainType | EnumTerrainTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TerrainType[] | ListEnumTerrainTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TerrainType[] | ListEnumTerrainTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTerrainTypeFilter<$PrismaModel> | $Enums.TerrainType
  }

  export type NestedEnumTerrainTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TerrainType | EnumTerrainTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TerrainType[] | ListEnumTerrainTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TerrainType[] | ListEnumTerrainTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTerrainTypeWithAggregatesFilter<$PrismaModel> | $Enums.TerrainType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTerrainTypeFilter<$PrismaModel>
    _max?: NestedEnumTerrainTypeFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedEnumAllianceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AllianceStatus | EnumAllianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AllianceStatus[] | ListEnumAllianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AllianceStatus[] | ListEnumAllianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAllianceStatusFilter<$PrismaModel> | $Enums.AllianceStatus
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAllianceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AllianceStatus | EnumAllianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AllianceStatus[] | ListEnumAllianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AllianceStatus[] | ListEnumAllianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAllianceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AllianceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAllianceStatusFilter<$PrismaModel>
    _max?: NestedEnumAllianceStatusFilter<$PrismaModel>
  }

  export type NestedEnumBattleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleType | EnumBattleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BattleType[] | ListEnumBattleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleType[] | ListEnumBattleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleTypeFilter<$PrismaModel> | $Enums.BattleType
  }

  export type NestedEnumBattleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleStatus | EnumBattleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleStatusFilter<$PrismaModel> | $Enums.BattleStatus
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedEnumBattleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleType | EnumBattleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BattleType[] | ListEnumBattleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleType[] | ListEnumBattleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleTypeWithAggregatesFilter<$PrismaModel> | $Enums.BattleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBattleTypeFilter<$PrismaModel>
    _max?: NestedEnumBattleTypeFilter<$PrismaModel>
  }

  export type NestedEnumBattleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleStatus | EnumBattleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleStatusWithAggregatesFilter<$PrismaModel> | $Enums.BattleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBattleStatusFilter<$PrismaModel>
    _max?: NestedEnumBattleStatusFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumInteractionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionTypeFilter<$PrismaModel> | $Enums.InteractionType
  }

  export type NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InteractionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInteractionTypeFilter<$PrismaModel>
    _max?: NestedEnumInteractionTypeFilter<$PrismaModel>
  }

  export type NestedEnumCooldownTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CooldownType | EnumCooldownTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CooldownType[] | ListEnumCooldownTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CooldownType[] | ListEnumCooldownTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCooldownTypeFilter<$PrismaModel> | $Enums.CooldownType
  }

  export type NestedEnumCooldownTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CooldownType | EnumCooldownTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CooldownType[] | ListEnumCooldownTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CooldownType[] | ListEnumCooldownTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCooldownTypeWithAggregatesFilter<$PrismaModel> | $Enums.CooldownType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCooldownTypeFilter<$PrismaModel>
    _max?: NestedEnumCooldownTypeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type AgentCreateWithoutGameInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    isAlive?: boolean
    deathTimestamp?: Date | string | null
    vault: string
    tweets?: TweetCreateNestedManyWithoutAgentInput
    battlesAsAttacker?: BattleCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceCreateNestedManyWithoutJoinerInput
    profile: AgentProfileCreateNestedOneWithoutAgentsInput
    mapTile: MapTileCreateNestedOneWithoutAgentInput
    ignoredBy?: IgnoreCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventCreateNestedManyWithoutTargetInput
  }

  export type AgentUncheckedCreateWithoutGameInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    isAlive?: boolean
    profileId: string
    deathTimestamp?: Date | string | null
    mapTileId: string
    vault: string
    tweets?: TweetUncheckedCreateNestedManyWithoutAgentInput
    battlesAsAttacker?: BattleUncheckedCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleUncheckedCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleUncheckedCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleUncheckedCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleUncheckedCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceUncheckedCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceUncheckedCreateNestedManyWithoutJoinerInput
    ignoredBy?: IgnoreUncheckedCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreUncheckedCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventUncheckedCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventUncheckedCreateNestedManyWithoutTargetInput
  }

  export type AgentCreateOrConnectWithoutGameInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutGameInput, AgentUncheckedCreateWithoutGameInput>
  }

  export type AgentCreateManyGameInputEnvelope = {
    data: AgentCreateManyGameInput | AgentCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type AllianceCreateWithoutGameInput = {
    id?: string
    combinedTokens?: bigint | number | null
    status?: $Enums.AllianceStatus
    timestamp?: Date | string
    endedAt?: Date | string | null
    initiator: AgentCreateNestedOneWithoutInitiatedAlliancesInput
    joiner: AgentCreateNestedOneWithoutJoinedAlliancesInput
  }

  export type AllianceUncheckedCreateWithoutGameInput = {
    id?: string
    combinedTokens?: bigint | number | null
    status?: $Enums.AllianceStatus
    timestamp?: Date | string
    initiatorId: string
    joinerId: string
    endedAt?: Date | string | null
  }

  export type AllianceCreateOrConnectWithoutGameInput = {
    where: AllianceWhereUniqueInput
    create: XOR<AllianceCreateWithoutGameInput, AllianceUncheckedCreateWithoutGameInput>
  }

  export type AllianceCreateManyGameInputEnvelope = {
    data: AllianceCreateManyGameInput | AllianceCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type BattleCreateWithoutGameInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    attacker: AgentCreateNestedOneWithoutBattlesAsAttackerInput
    defender: AgentCreateNestedOneWithoutBattlesAsDefenderInput
    attackerAlly?: AgentCreateNestedOneWithoutBattlesAsAttackerAllyInput
    defenderAlly?: AgentCreateNestedOneWithoutBattlesAsDefenderAllyInput
    winner?: AgentCreateNestedOneWithoutWonBattlesInput
  }

  export type BattleUncheckedCreateWithoutGameInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    attackerId: string
    defenderId: string
    attackerAllyId?: string | null
    defenderAllyId?: string | null
    winnerId?: string | null
  }

  export type BattleCreateOrConnectWithoutGameInput = {
    where: BattleWhereUniqueInput
    create: XOR<BattleCreateWithoutGameInput, BattleUncheckedCreateWithoutGameInput>
  }

  export type BattleCreateManyGameInputEnvelope = {
    data: BattleCreateManyGameInput | BattleCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type CoolDownCreateWithoutGameInput = {
    id?: string
    type: $Enums.CooldownType
    endsAt: Date | string
    startsAt?: Date | string | null
    cooledAgent: AgentCreateNestedOneWithoutCoolDownInput
  }

  export type CoolDownUncheckedCreateWithoutGameInput = {
    id?: string
    type: $Enums.CooldownType
    endsAt: Date | string
    startsAt?: Date | string | null
    cooledAgentId: string
  }

  export type CoolDownCreateOrConnectWithoutGameInput = {
    where: CoolDownWhereUniqueInput
    create: XOR<CoolDownCreateWithoutGameInput, CoolDownUncheckedCreateWithoutGameInput>
  }

  export type CoolDownCreateManyGameInputEnvelope = {
    data: CoolDownCreateManyGameInput | CoolDownCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type IgnoreCreateWithoutGameInput = {
    id?: string
    timestamp?: Date | string
    duration?: number
    agent: AgentCreateNestedOneWithoutIgnoredByInput
    ignoredAgent: AgentCreateNestedOneWithoutIgnoringInput
  }

  export type IgnoreUncheckedCreateWithoutGameInput = {
    id?: string
    agentId: string
    timestamp?: Date | string
    duration?: number
    ignoredAgentId: string
  }

  export type IgnoreCreateOrConnectWithoutGameInput = {
    where: IgnoreWhereUniqueInput
    create: XOR<IgnoreCreateWithoutGameInput, IgnoreUncheckedCreateWithoutGameInput>
  }

  export type IgnoreCreateManyGameInputEnvelope = {
    data: IgnoreCreateManyGameInput | IgnoreCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type GameLogCreateWithoutGameInput = {
    id?: string
    timestamp?: Date | string
    type: string
    level: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    agent?: AgentCreateNestedOneWithoutGameLogInput
  }

  export type GameLogUncheckedCreateWithoutGameInput = {
    id?: string
    timestamp?: Date | string
    type: string
    level: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    agentId?: string | null
  }

  export type GameLogCreateOrConnectWithoutGameInput = {
    where: GameLogWhereUniqueInput
    create: XOR<GameLogCreateWithoutGameInput, GameLogUncheckedCreateWithoutGameInput>
  }

  export type GameLogCreateManyGameInputEnvelope = {
    data: GameLogCreateManyGameInput | GameLogCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type GameEventCreateWithoutGameInput = {
    id?: string
    createdAt?: Date | string
    eventType: $Enums.EventType
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiator: AgentCreateNestedOneWithoutInitiatedEventsInput
    target?: AgentCreateNestedOneWithoutTargetedEventsInput
  }

  export type GameEventUncheckedCreateWithoutGameInput = {
    id?: string
    createdAt?: Date | string
    eventType: $Enums.EventType
    initiatorId: string
    targetId?: string | null
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GameEventCreateOrConnectWithoutGameInput = {
    where: GameEventWhereUniqueInput
    create: XOR<GameEventCreateWithoutGameInput, GameEventUncheckedCreateWithoutGameInput>
  }

  export type GameEventCreateManyGameInputEnvelope = {
    data: GameEventCreateManyGameInput | GameEventCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type AgentUpsertWithWhereUniqueWithoutGameInput = {
    where: AgentWhereUniqueInput
    update: XOR<AgentUpdateWithoutGameInput, AgentUncheckedUpdateWithoutGameInput>
    create: XOR<AgentCreateWithoutGameInput, AgentUncheckedCreateWithoutGameInput>
  }

  export type AgentUpdateWithWhereUniqueWithoutGameInput = {
    where: AgentWhereUniqueInput
    data: XOR<AgentUpdateWithoutGameInput, AgentUncheckedUpdateWithoutGameInput>
  }

  export type AgentUpdateManyWithWhereWithoutGameInput = {
    where: AgentScalarWhereInput
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyWithoutGameInput>
  }

  export type AgentScalarWhereInput = {
    AND?: AgentScalarWhereInput | AgentScalarWhereInput[]
    OR?: AgentScalarWhereInput[]
    NOT?: AgentScalarWhereInput | AgentScalarWhereInput[]
    id?: StringFilter<"Agent"> | string
    onchainId?: IntFilter<"Agent"> | number
    authority?: StringFilter<"Agent"> | string
    authorityAssociatedTokenAddress?: StringFilter<"Agent"> | string
    pda?: StringFilter<"Agent"> | string
    gameId?: StringFilter<"Agent"> | string
    isAlive?: BoolFilter<"Agent"> | boolean
    profileId?: StringFilter<"Agent"> | string
    deathTimestamp?: DateTimeNullableFilter<"Agent"> | Date | string | null
    mapTileId?: StringFilter<"Agent"> | string
    vault?: StringFilter<"Agent"> | string
  }

  export type AllianceUpsertWithWhereUniqueWithoutGameInput = {
    where: AllianceWhereUniqueInput
    update: XOR<AllianceUpdateWithoutGameInput, AllianceUncheckedUpdateWithoutGameInput>
    create: XOR<AllianceCreateWithoutGameInput, AllianceUncheckedCreateWithoutGameInput>
  }

  export type AllianceUpdateWithWhereUniqueWithoutGameInput = {
    where: AllianceWhereUniqueInput
    data: XOR<AllianceUpdateWithoutGameInput, AllianceUncheckedUpdateWithoutGameInput>
  }

  export type AllianceUpdateManyWithWhereWithoutGameInput = {
    where: AllianceScalarWhereInput
    data: XOR<AllianceUpdateManyMutationInput, AllianceUncheckedUpdateManyWithoutGameInput>
  }

  export type AllianceScalarWhereInput = {
    AND?: AllianceScalarWhereInput | AllianceScalarWhereInput[]
    OR?: AllianceScalarWhereInput[]
    NOT?: AllianceScalarWhereInput | AllianceScalarWhereInput[]
    id?: StringFilter<"Alliance"> | string
    combinedTokens?: BigIntNullableFilter<"Alliance"> | bigint | number | null
    status?: EnumAllianceStatusFilter<"Alliance"> | $Enums.AllianceStatus
    timestamp?: DateTimeFilter<"Alliance"> | Date | string
    gameId?: StringFilter<"Alliance"> | string
    initiatorId?: StringFilter<"Alliance"> | string
    joinerId?: StringFilter<"Alliance"> | string
    endedAt?: DateTimeNullableFilter<"Alliance"> | Date | string | null
  }

  export type BattleUpsertWithWhereUniqueWithoutGameInput = {
    where: BattleWhereUniqueInput
    update: XOR<BattleUpdateWithoutGameInput, BattleUncheckedUpdateWithoutGameInput>
    create: XOR<BattleCreateWithoutGameInput, BattleUncheckedCreateWithoutGameInput>
  }

  export type BattleUpdateWithWhereUniqueWithoutGameInput = {
    where: BattleWhereUniqueInput
    data: XOR<BattleUpdateWithoutGameInput, BattleUncheckedUpdateWithoutGameInput>
  }

  export type BattleUpdateManyWithWhereWithoutGameInput = {
    where: BattleScalarWhereInput
    data: XOR<BattleUpdateManyMutationInput, BattleUncheckedUpdateManyWithoutGameInput>
  }

  export type BattleScalarWhereInput = {
    AND?: BattleScalarWhereInput | BattleScalarWhereInput[]
    OR?: BattleScalarWhereInput[]
    NOT?: BattleScalarWhereInput | BattleScalarWhereInput[]
    id?: StringFilter<"Battle"> | string
    type?: EnumBattleTypeFilter<"Battle"> | $Enums.BattleType
    status?: EnumBattleStatusFilter<"Battle"> | $Enums.BattleStatus
    tokensStaked?: BigIntFilter<"Battle"> | bigint | number
    startTime?: DateTimeFilter<"Battle"> | Date | string
    endTime?: DateTimeNullableFilter<"Battle"> | Date | string | null
    gameId?: StringFilter<"Battle"> | string
    attackerId?: StringFilter<"Battle"> | string
    defenderId?: StringFilter<"Battle"> | string
    attackerAllyId?: StringNullableFilter<"Battle"> | string | null
    defenderAllyId?: StringNullableFilter<"Battle"> | string | null
    winnerId?: StringNullableFilter<"Battle"> | string | null
  }

  export type CoolDownUpsertWithWhereUniqueWithoutGameInput = {
    where: CoolDownWhereUniqueInput
    update: XOR<CoolDownUpdateWithoutGameInput, CoolDownUncheckedUpdateWithoutGameInput>
    create: XOR<CoolDownCreateWithoutGameInput, CoolDownUncheckedCreateWithoutGameInput>
  }

  export type CoolDownUpdateWithWhereUniqueWithoutGameInput = {
    where: CoolDownWhereUniqueInput
    data: XOR<CoolDownUpdateWithoutGameInput, CoolDownUncheckedUpdateWithoutGameInput>
  }

  export type CoolDownUpdateManyWithWhereWithoutGameInput = {
    where: CoolDownScalarWhereInput
    data: XOR<CoolDownUpdateManyMutationInput, CoolDownUncheckedUpdateManyWithoutGameInput>
  }

  export type CoolDownScalarWhereInput = {
    AND?: CoolDownScalarWhereInput | CoolDownScalarWhereInput[]
    OR?: CoolDownScalarWhereInput[]
    NOT?: CoolDownScalarWhereInput | CoolDownScalarWhereInput[]
    id?: StringFilter<"CoolDown"> | string
    type?: EnumCooldownTypeFilter<"CoolDown"> | $Enums.CooldownType
    endsAt?: DateTimeFilter<"CoolDown"> | Date | string
    startsAt?: DateTimeNullableFilter<"CoolDown"> | Date | string | null
    cooledAgentId?: StringFilter<"CoolDown"> | string
    gameId?: StringFilter<"CoolDown"> | string
  }

  export type IgnoreUpsertWithWhereUniqueWithoutGameInput = {
    where: IgnoreWhereUniqueInput
    update: XOR<IgnoreUpdateWithoutGameInput, IgnoreUncheckedUpdateWithoutGameInput>
    create: XOR<IgnoreCreateWithoutGameInput, IgnoreUncheckedCreateWithoutGameInput>
  }

  export type IgnoreUpdateWithWhereUniqueWithoutGameInput = {
    where: IgnoreWhereUniqueInput
    data: XOR<IgnoreUpdateWithoutGameInput, IgnoreUncheckedUpdateWithoutGameInput>
  }

  export type IgnoreUpdateManyWithWhereWithoutGameInput = {
    where: IgnoreScalarWhereInput
    data: XOR<IgnoreUpdateManyMutationInput, IgnoreUncheckedUpdateManyWithoutGameInput>
  }

  export type IgnoreScalarWhereInput = {
    AND?: IgnoreScalarWhereInput | IgnoreScalarWhereInput[]
    OR?: IgnoreScalarWhereInput[]
    NOT?: IgnoreScalarWhereInput | IgnoreScalarWhereInput[]
    id?: StringFilter<"Ignore"> | string
    agentId?: StringFilter<"Ignore"> | string
    timestamp?: DateTimeFilter<"Ignore"> | Date | string
    duration?: IntFilter<"Ignore"> | number
    gameId?: StringFilter<"Ignore"> | string
    ignoredAgentId?: StringFilter<"Ignore"> | string
  }

  export type GameLogUpsertWithWhereUniqueWithoutGameInput = {
    where: GameLogWhereUniqueInput
    update: XOR<GameLogUpdateWithoutGameInput, GameLogUncheckedUpdateWithoutGameInput>
    create: XOR<GameLogCreateWithoutGameInput, GameLogUncheckedCreateWithoutGameInput>
  }

  export type GameLogUpdateWithWhereUniqueWithoutGameInput = {
    where: GameLogWhereUniqueInput
    data: XOR<GameLogUpdateWithoutGameInput, GameLogUncheckedUpdateWithoutGameInput>
  }

  export type GameLogUpdateManyWithWhereWithoutGameInput = {
    where: GameLogScalarWhereInput
    data: XOR<GameLogUpdateManyMutationInput, GameLogUncheckedUpdateManyWithoutGameInput>
  }

  export type GameLogScalarWhereInput = {
    AND?: GameLogScalarWhereInput | GameLogScalarWhereInput[]
    OR?: GameLogScalarWhereInput[]
    NOT?: GameLogScalarWhereInput | GameLogScalarWhereInput[]
    id?: StringFilter<"GameLog"> | string
    timestamp?: DateTimeFilter<"GameLog"> | Date | string
    type?: StringFilter<"GameLog"> | string
    level?: StringFilter<"GameLog"> | string
    message?: StringFilter<"GameLog"> | string
    data?: JsonNullableFilter<"GameLog">
    agentId?: StringNullableFilter<"GameLog"> | string | null
    gameId?: StringNullableFilter<"GameLog"> | string | null
  }

  export type GameEventUpsertWithWhereUniqueWithoutGameInput = {
    where: GameEventWhereUniqueInput
    update: XOR<GameEventUpdateWithoutGameInput, GameEventUncheckedUpdateWithoutGameInput>
    create: XOR<GameEventCreateWithoutGameInput, GameEventUncheckedCreateWithoutGameInput>
  }

  export type GameEventUpdateWithWhereUniqueWithoutGameInput = {
    where: GameEventWhereUniqueInput
    data: XOR<GameEventUpdateWithoutGameInput, GameEventUncheckedUpdateWithoutGameInput>
  }

  export type GameEventUpdateManyWithWhereWithoutGameInput = {
    where: GameEventScalarWhereInput
    data: XOR<GameEventUpdateManyMutationInput, GameEventUncheckedUpdateManyWithoutGameInput>
  }

  export type GameEventScalarWhereInput = {
    AND?: GameEventScalarWhereInput | GameEventScalarWhereInput[]
    OR?: GameEventScalarWhereInput[]
    NOT?: GameEventScalarWhereInput | GameEventScalarWhereInput[]
    id?: StringFilter<"GameEvent"> | string
    createdAt?: DateTimeFilter<"GameEvent"> | Date | string
    eventType?: EnumEventTypeFilter<"GameEvent"> | $Enums.EventType
    initiatorId?: StringFilter<"GameEvent"> | string
    targetId?: StringNullableFilter<"GameEvent"> | string | null
    message?: StringFilter<"GameEvent"> | string
    metadata?: JsonNullableFilter<"GameEvent">
    gameId?: StringFilter<"GameEvent"> | string
  }

  export type AgentCreateWithoutInitiatedEventsInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    isAlive?: boolean
    deathTimestamp?: Date | string | null
    vault: string
    tweets?: TweetCreateNestedManyWithoutAgentInput
    game: GameCreateNestedOneWithoutAgentsInput
    battlesAsAttacker?: BattleCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceCreateNestedManyWithoutJoinerInput
    profile: AgentProfileCreateNestedOneWithoutAgentsInput
    mapTile: MapTileCreateNestedOneWithoutAgentInput
    ignoredBy?: IgnoreCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogCreateNestedManyWithoutAgentInput
    targetedEvents?: GameEventCreateNestedManyWithoutTargetInput
  }

  export type AgentUncheckedCreateWithoutInitiatedEventsInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    gameId: string
    isAlive?: boolean
    profileId: string
    deathTimestamp?: Date | string | null
    mapTileId: string
    vault: string
    tweets?: TweetUncheckedCreateNestedManyWithoutAgentInput
    battlesAsAttacker?: BattleUncheckedCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleUncheckedCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleUncheckedCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleUncheckedCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleUncheckedCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceUncheckedCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceUncheckedCreateNestedManyWithoutJoinerInput
    ignoredBy?: IgnoreUncheckedCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreUncheckedCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutAgentInput
    targetedEvents?: GameEventUncheckedCreateNestedManyWithoutTargetInput
  }

  export type AgentCreateOrConnectWithoutInitiatedEventsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutInitiatedEventsInput, AgentUncheckedCreateWithoutInitiatedEventsInput>
  }

  export type AgentCreateWithoutTargetedEventsInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    isAlive?: boolean
    deathTimestamp?: Date | string | null
    vault: string
    tweets?: TweetCreateNestedManyWithoutAgentInput
    game: GameCreateNestedOneWithoutAgentsInput
    battlesAsAttacker?: BattleCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceCreateNestedManyWithoutJoinerInput
    profile: AgentProfileCreateNestedOneWithoutAgentsInput
    mapTile: MapTileCreateNestedOneWithoutAgentInput
    ignoredBy?: IgnoreCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventCreateNestedManyWithoutInitiatorInput
  }

  export type AgentUncheckedCreateWithoutTargetedEventsInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    gameId: string
    isAlive?: boolean
    profileId: string
    deathTimestamp?: Date | string | null
    mapTileId: string
    vault: string
    tweets?: TweetUncheckedCreateNestedManyWithoutAgentInput
    battlesAsAttacker?: BattleUncheckedCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleUncheckedCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleUncheckedCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleUncheckedCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleUncheckedCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceUncheckedCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceUncheckedCreateNestedManyWithoutJoinerInput
    ignoredBy?: IgnoreUncheckedCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreUncheckedCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventUncheckedCreateNestedManyWithoutInitiatorInput
  }

  export type AgentCreateOrConnectWithoutTargetedEventsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutTargetedEventsInput, AgentUncheckedCreateWithoutTargetedEventsInput>
  }

  export type GameCreateWithoutGameEventInput = {
    id?: string
    onchainId: number
    authority: string
    pda: string
    tokenMint: string
    rewardsVault: string
    mapDiameter: number
    isActive?: boolean
    lastUpdate?: Date | string
    bump: number
    dailyRewardTokens: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutGameInput
    alliances?: AllianceCreateNestedManyWithoutGameInput
    battles?: BattleCreateNestedManyWithoutGameInput
    coolDown?: CoolDownCreateNestedManyWithoutGameInput
    Ignore?: IgnoreCreateNestedManyWithoutGameInput
    GameLog?: GameLogCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutGameEventInput = {
    id?: string
    onchainId: number
    authority: string
    pda: string
    tokenMint: string
    rewardsVault: string
    mapDiameter: number
    isActive?: boolean
    lastUpdate?: Date | string
    bump: number
    dailyRewardTokens: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutGameInput
    alliances?: AllianceUncheckedCreateNestedManyWithoutGameInput
    battles?: BattleUncheckedCreateNestedManyWithoutGameInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutGameInput
    Ignore?: IgnoreUncheckedCreateNestedManyWithoutGameInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutGameEventInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutGameEventInput, GameUncheckedCreateWithoutGameEventInput>
  }

  export type AgentUpsertWithoutInitiatedEventsInput = {
    update: XOR<AgentUpdateWithoutInitiatedEventsInput, AgentUncheckedUpdateWithoutInitiatedEventsInput>
    create: XOR<AgentCreateWithoutInitiatedEventsInput, AgentUncheckedCreateWithoutInitiatedEventsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutInitiatedEventsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutInitiatedEventsInput, AgentUncheckedUpdateWithoutInitiatedEventsInput>
  }

  export type AgentUpdateWithoutInitiatedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUpdateManyWithoutAgentNestedInput
    game?: GameUpdateOneRequiredWithoutAgentsNestedInput
    battlesAsAttacker?: BattleUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUpdateManyWithoutJoinerNestedInput
    profile?: AgentProfileUpdateOneRequiredWithoutAgentsNestedInput
    mapTile?: MapTileUpdateOneRequiredWithoutAgentNestedInput
    ignoredBy?: IgnoreUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUpdateManyWithoutAgentNestedInput
    targetedEvents?: GameEventUpdateManyWithoutTargetNestedInput
  }

  export type AgentUncheckedUpdateWithoutInitiatedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mapTileId?: StringFieldUpdateOperationsInput | string
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUncheckedUpdateManyWithoutAgentNestedInput
    battlesAsAttacker?: BattleUncheckedUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUncheckedUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUncheckedUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUncheckedUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUncheckedUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUncheckedUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUncheckedUpdateManyWithoutJoinerNestedInput
    ignoredBy?: IgnoreUncheckedUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUncheckedUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutAgentNestedInput
    targetedEvents?: GameEventUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type AgentUpsertWithoutTargetedEventsInput = {
    update: XOR<AgentUpdateWithoutTargetedEventsInput, AgentUncheckedUpdateWithoutTargetedEventsInput>
    create: XOR<AgentCreateWithoutTargetedEventsInput, AgentUncheckedCreateWithoutTargetedEventsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutTargetedEventsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutTargetedEventsInput, AgentUncheckedUpdateWithoutTargetedEventsInput>
  }

  export type AgentUpdateWithoutTargetedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUpdateManyWithoutAgentNestedInput
    game?: GameUpdateOneRequiredWithoutAgentsNestedInput
    battlesAsAttacker?: BattleUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUpdateManyWithoutJoinerNestedInput
    profile?: AgentProfileUpdateOneRequiredWithoutAgentsNestedInput
    mapTile?: MapTileUpdateOneRequiredWithoutAgentNestedInput
    ignoredBy?: IgnoreUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUpdateManyWithoutInitiatorNestedInput
  }

  export type AgentUncheckedUpdateWithoutTargetedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mapTileId?: StringFieldUpdateOperationsInput | string
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUncheckedUpdateManyWithoutAgentNestedInput
    battlesAsAttacker?: BattleUncheckedUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUncheckedUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUncheckedUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUncheckedUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUncheckedUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUncheckedUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUncheckedUpdateManyWithoutJoinerNestedInput
    ignoredBy?: IgnoreUncheckedUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUncheckedUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUncheckedUpdateManyWithoutInitiatorNestedInput
  }

  export type GameUpsertWithoutGameEventInput = {
    update: XOR<GameUpdateWithoutGameEventInput, GameUncheckedUpdateWithoutGameEventInput>
    create: XOR<GameCreateWithoutGameEventInput, GameUncheckedCreateWithoutGameEventInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutGameEventInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutGameEventInput, GameUncheckedUpdateWithoutGameEventInput>
  }

  export type GameUpdateWithoutGameEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    tokenMint?: StringFieldUpdateOperationsInput | string
    rewardsVault?: StringFieldUpdateOperationsInput | string
    mapDiameter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bump?: IntFieldUpdateOperationsInput | number
    dailyRewardTokens?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutGameNestedInput
    alliances?: AllianceUpdateManyWithoutGameNestedInput
    battles?: BattleUpdateManyWithoutGameNestedInput
    coolDown?: CoolDownUpdateManyWithoutGameNestedInput
    Ignore?: IgnoreUpdateManyWithoutGameNestedInput
    GameLog?: GameLogUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutGameEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    tokenMint?: StringFieldUpdateOperationsInput | string
    rewardsVault?: StringFieldUpdateOperationsInput | string
    mapDiameter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bump?: IntFieldUpdateOperationsInput | number
    dailyRewardTokens?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutGameNestedInput
    alliances?: AllianceUncheckedUpdateManyWithoutGameNestedInput
    battles?: BattleUncheckedUpdateManyWithoutGameNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutGameNestedInput
    Ignore?: IgnoreUncheckedUpdateManyWithoutGameNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutGameNestedInput
  }

  export type AgentCreateWithoutProfileInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    isAlive?: boolean
    deathTimestamp?: Date | string | null
    vault: string
    tweets?: TweetCreateNestedManyWithoutAgentInput
    game: GameCreateNestedOneWithoutAgentsInput
    battlesAsAttacker?: BattleCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceCreateNestedManyWithoutJoinerInput
    mapTile: MapTileCreateNestedOneWithoutAgentInput
    ignoredBy?: IgnoreCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventCreateNestedManyWithoutTargetInput
  }

  export type AgentUncheckedCreateWithoutProfileInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    gameId: string
    isAlive?: boolean
    deathTimestamp?: Date | string | null
    mapTileId: string
    vault: string
    tweets?: TweetUncheckedCreateNestedManyWithoutAgentInput
    battlesAsAttacker?: BattleUncheckedCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleUncheckedCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleUncheckedCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleUncheckedCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleUncheckedCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceUncheckedCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceUncheckedCreateNestedManyWithoutJoinerInput
    ignoredBy?: IgnoreUncheckedCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreUncheckedCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventUncheckedCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventUncheckedCreateNestedManyWithoutTargetInput
  }

  export type AgentCreateOrConnectWithoutProfileInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutProfileInput, AgentUncheckedCreateWithoutProfileInput>
  }

  export type AgentCreateManyProfileInputEnvelope = {
    data: AgentCreateManyProfileInput | AgentCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type AgentUpsertWithWhereUniqueWithoutProfileInput = {
    where: AgentWhereUniqueInput
    update: XOR<AgentUpdateWithoutProfileInput, AgentUncheckedUpdateWithoutProfileInput>
    create: XOR<AgentCreateWithoutProfileInput, AgentUncheckedCreateWithoutProfileInput>
  }

  export type AgentUpdateWithWhereUniqueWithoutProfileInput = {
    where: AgentWhereUniqueInput
    data: XOR<AgentUpdateWithoutProfileInput, AgentUncheckedUpdateWithoutProfileInput>
  }

  export type AgentUpdateManyWithWhereWithoutProfileInput = {
    where: AgentScalarWhereInput
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyWithoutProfileInput>
  }

  export type TweetCreateWithoutAgentInput = {
    id?: string
    content: string
    type: string
    timestamp: Date | string
    conversationId?: string | null
    interactions?: InteractionCreateNestedManyWithoutTweetInput
  }

  export type TweetUncheckedCreateWithoutAgentInput = {
    id?: string
    content: string
    type: string
    timestamp: Date | string
    conversationId?: string | null
    interactions?: InteractionUncheckedCreateNestedManyWithoutTweetInput
  }

  export type TweetCreateOrConnectWithoutAgentInput = {
    where: TweetWhereUniqueInput
    create: XOR<TweetCreateWithoutAgentInput, TweetUncheckedCreateWithoutAgentInput>
  }

  export type TweetCreateManyAgentInputEnvelope = {
    data: TweetCreateManyAgentInput | TweetCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type GameCreateWithoutAgentsInput = {
    id?: string
    onchainId: number
    authority: string
    pda: string
    tokenMint: string
    rewardsVault: string
    mapDiameter: number
    isActive?: boolean
    lastUpdate?: Date | string
    bump: number
    dailyRewardTokens: number
    createdAt?: Date | string
    updatedAt?: Date | string
    alliances?: AllianceCreateNestedManyWithoutGameInput
    battles?: BattleCreateNestedManyWithoutGameInput
    coolDown?: CoolDownCreateNestedManyWithoutGameInput
    Ignore?: IgnoreCreateNestedManyWithoutGameInput
    GameLog?: GameLogCreateNestedManyWithoutGameInput
    GameEvent?: GameEventCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutAgentsInput = {
    id?: string
    onchainId: number
    authority: string
    pda: string
    tokenMint: string
    rewardsVault: string
    mapDiameter: number
    isActive?: boolean
    lastUpdate?: Date | string
    bump: number
    dailyRewardTokens: number
    createdAt?: Date | string
    updatedAt?: Date | string
    alliances?: AllianceUncheckedCreateNestedManyWithoutGameInput
    battles?: BattleUncheckedCreateNestedManyWithoutGameInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutGameInput
    Ignore?: IgnoreUncheckedCreateNestedManyWithoutGameInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutGameInput
    GameEvent?: GameEventUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutAgentsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutAgentsInput, GameUncheckedCreateWithoutAgentsInput>
  }

  export type BattleCreateWithoutAttackerInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    game: GameCreateNestedOneWithoutBattlesInput
    defender: AgentCreateNestedOneWithoutBattlesAsDefenderInput
    attackerAlly?: AgentCreateNestedOneWithoutBattlesAsAttackerAllyInput
    defenderAlly?: AgentCreateNestedOneWithoutBattlesAsDefenderAllyInput
    winner?: AgentCreateNestedOneWithoutWonBattlesInput
  }

  export type BattleUncheckedCreateWithoutAttackerInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    gameId: string
    defenderId: string
    attackerAllyId?: string | null
    defenderAllyId?: string | null
    winnerId?: string | null
  }

  export type BattleCreateOrConnectWithoutAttackerInput = {
    where: BattleWhereUniqueInput
    create: XOR<BattleCreateWithoutAttackerInput, BattleUncheckedCreateWithoutAttackerInput>
  }

  export type BattleCreateManyAttackerInputEnvelope = {
    data: BattleCreateManyAttackerInput | BattleCreateManyAttackerInput[]
    skipDuplicates?: boolean
  }

  export type BattleCreateWithoutDefenderInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    game: GameCreateNestedOneWithoutBattlesInput
    attacker: AgentCreateNestedOneWithoutBattlesAsAttackerInput
    attackerAlly?: AgentCreateNestedOneWithoutBattlesAsAttackerAllyInput
    defenderAlly?: AgentCreateNestedOneWithoutBattlesAsDefenderAllyInput
    winner?: AgentCreateNestedOneWithoutWonBattlesInput
  }

  export type BattleUncheckedCreateWithoutDefenderInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    gameId: string
    attackerId: string
    attackerAllyId?: string | null
    defenderAllyId?: string | null
    winnerId?: string | null
  }

  export type BattleCreateOrConnectWithoutDefenderInput = {
    where: BattleWhereUniqueInput
    create: XOR<BattleCreateWithoutDefenderInput, BattleUncheckedCreateWithoutDefenderInput>
  }

  export type BattleCreateManyDefenderInputEnvelope = {
    data: BattleCreateManyDefenderInput | BattleCreateManyDefenderInput[]
    skipDuplicates?: boolean
  }

  export type BattleCreateWithoutAttackerAllyInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    game: GameCreateNestedOneWithoutBattlesInput
    attacker: AgentCreateNestedOneWithoutBattlesAsAttackerInput
    defender: AgentCreateNestedOneWithoutBattlesAsDefenderInput
    defenderAlly?: AgentCreateNestedOneWithoutBattlesAsDefenderAllyInput
    winner?: AgentCreateNestedOneWithoutWonBattlesInput
  }

  export type BattleUncheckedCreateWithoutAttackerAllyInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    gameId: string
    attackerId: string
    defenderId: string
    defenderAllyId?: string | null
    winnerId?: string | null
  }

  export type BattleCreateOrConnectWithoutAttackerAllyInput = {
    where: BattleWhereUniqueInput
    create: XOR<BattleCreateWithoutAttackerAllyInput, BattleUncheckedCreateWithoutAttackerAllyInput>
  }

  export type BattleCreateManyAttackerAllyInputEnvelope = {
    data: BattleCreateManyAttackerAllyInput | BattleCreateManyAttackerAllyInput[]
    skipDuplicates?: boolean
  }

  export type BattleCreateWithoutDefenderAllyInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    game: GameCreateNestedOneWithoutBattlesInput
    attacker: AgentCreateNestedOneWithoutBattlesAsAttackerInput
    defender: AgentCreateNestedOneWithoutBattlesAsDefenderInput
    attackerAlly?: AgentCreateNestedOneWithoutBattlesAsAttackerAllyInput
    winner?: AgentCreateNestedOneWithoutWonBattlesInput
  }

  export type BattleUncheckedCreateWithoutDefenderAllyInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    gameId: string
    attackerId: string
    defenderId: string
    attackerAllyId?: string | null
    winnerId?: string | null
  }

  export type BattleCreateOrConnectWithoutDefenderAllyInput = {
    where: BattleWhereUniqueInput
    create: XOR<BattleCreateWithoutDefenderAllyInput, BattleUncheckedCreateWithoutDefenderAllyInput>
  }

  export type BattleCreateManyDefenderAllyInputEnvelope = {
    data: BattleCreateManyDefenderAllyInput | BattleCreateManyDefenderAllyInput[]
    skipDuplicates?: boolean
  }

  export type BattleCreateWithoutWinnerInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    game: GameCreateNestedOneWithoutBattlesInput
    attacker: AgentCreateNestedOneWithoutBattlesAsAttackerInput
    defender: AgentCreateNestedOneWithoutBattlesAsDefenderInput
    attackerAlly?: AgentCreateNestedOneWithoutBattlesAsAttackerAllyInput
    defenderAlly?: AgentCreateNestedOneWithoutBattlesAsDefenderAllyInput
  }

  export type BattleUncheckedCreateWithoutWinnerInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    gameId: string
    attackerId: string
    defenderId: string
    attackerAllyId?: string | null
    defenderAllyId?: string | null
  }

  export type BattleCreateOrConnectWithoutWinnerInput = {
    where: BattleWhereUniqueInput
    create: XOR<BattleCreateWithoutWinnerInput, BattleUncheckedCreateWithoutWinnerInput>
  }

  export type BattleCreateManyWinnerInputEnvelope = {
    data: BattleCreateManyWinnerInput | BattleCreateManyWinnerInput[]
    skipDuplicates?: boolean
  }

  export type CoolDownCreateWithoutCooledAgentInput = {
    id?: string
    type: $Enums.CooldownType
    endsAt: Date | string
    startsAt?: Date | string | null
    game: GameCreateNestedOneWithoutCoolDownInput
  }

  export type CoolDownUncheckedCreateWithoutCooledAgentInput = {
    id?: string
    type: $Enums.CooldownType
    endsAt: Date | string
    startsAt?: Date | string | null
    gameId: string
  }

  export type CoolDownCreateOrConnectWithoutCooledAgentInput = {
    where: CoolDownWhereUniqueInput
    create: XOR<CoolDownCreateWithoutCooledAgentInput, CoolDownUncheckedCreateWithoutCooledAgentInput>
  }

  export type CoolDownCreateManyCooledAgentInputEnvelope = {
    data: CoolDownCreateManyCooledAgentInput | CoolDownCreateManyCooledAgentInput[]
    skipDuplicates?: boolean
  }

  export type AllianceCreateWithoutInitiatorInput = {
    id?: string
    combinedTokens?: bigint | number | null
    status?: $Enums.AllianceStatus
    timestamp?: Date | string
    endedAt?: Date | string | null
    game: GameCreateNestedOneWithoutAlliancesInput
    joiner: AgentCreateNestedOneWithoutJoinedAlliancesInput
  }

  export type AllianceUncheckedCreateWithoutInitiatorInput = {
    id?: string
    combinedTokens?: bigint | number | null
    status?: $Enums.AllianceStatus
    timestamp?: Date | string
    gameId: string
    joinerId: string
    endedAt?: Date | string | null
  }

  export type AllianceCreateOrConnectWithoutInitiatorInput = {
    where: AllianceWhereUniqueInput
    create: XOR<AllianceCreateWithoutInitiatorInput, AllianceUncheckedCreateWithoutInitiatorInput>
  }

  export type AllianceCreateManyInitiatorInputEnvelope = {
    data: AllianceCreateManyInitiatorInput | AllianceCreateManyInitiatorInput[]
    skipDuplicates?: boolean
  }

  export type AllianceCreateWithoutJoinerInput = {
    id?: string
    combinedTokens?: bigint | number | null
    status?: $Enums.AllianceStatus
    timestamp?: Date | string
    endedAt?: Date | string | null
    game: GameCreateNestedOneWithoutAlliancesInput
    initiator: AgentCreateNestedOneWithoutInitiatedAlliancesInput
  }

  export type AllianceUncheckedCreateWithoutJoinerInput = {
    id?: string
    combinedTokens?: bigint | number | null
    status?: $Enums.AllianceStatus
    timestamp?: Date | string
    gameId: string
    initiatorId: string
    endedAt?: Date | string | null
  }

  export type AllianceCreateOrConnectWithoutJoinerInput = {
    where: AllianceWhereUniqueInput
    create: XOR<AllianceCreateWithoutJoinerInput, AllianceUncheckedCreateWithoutJoinerInput>
  }

  export type AllianceCreateManyJoinerInputEnvelope = {
    data: AllianceCreateManyJoinerInput | AllianceCreateManyJoinerInput[]
    skipDuplicates?: boolean
  }

  export type AgentProfileCreateWithoutAgentsInput = {
    id?: string
    onchainId: number
    name: string
    xHandle: string
    description: string
    telegramLink: string
    followers?: number
    bio?: AgentProfileCreatebioInput | string[]
    lore?: AgentProfileCreateloreInput | string[]
    loreFulltext: string
    characteristics?: AgentProfileCreatecharacteristicsInput | string[]
    knowledge?: AgentProfileCreateknowledgeInput | string[]
    traits: JsonNullValueInput | InputJsonValue
    postExamples?: AgentProfileCreatepostExamplesInput | string[]
  }

  export type AgentProfileUncheckedCreateWithoutAgentsInput = {
    id?: string
    onchainId: number
    name: string
    xHandle: string
    description: string
    telegramLink: string
    followers?: number
    bio?: AgentProfileCreatebioInput | string[]
    lore?: AgentProfileCreateloreInput | string[]
    loreFulltext: string
    characteristics?: AgentProfileCreatecharacteristicsInput | string[]
    knowledge?: AgentProfileCreateknowledgeInput | string[]
    traits: JsonNullValueInput | InputJsonValue
    postExamples?: AgentProfileCreatepostExamplesInput | string[]
  }

  export type AgentProfileCreateOrConnectWithoutAgentsInput = {
    where: AgentProfileWhereUniqueInput
    create: XOR<AgentProfileCreateWithoutAgentsInput, AgentProfileUncheckedCreateWithoutAgentsInput>
  }

  export type MapTileCreateWithoutAgentInput = {
    id?: string
    x: number
    y: number
    terrainType: $Enums.TerrainType
    agentId?: string | null
  }

  export type MapTileUncheckedCreateWithoutAgentInput = {
    id?: string
    x: number
    y: number
    terrainType: $Enums.TerrainType
    agentId?: string | null
  }

  export type MapTileCreateOrConnectWithoutAgentInput = {
    where: MapTileWhereUniqueInput
    create: XOR<MapTileCreateWithoutAgentInput, MapTileUncheckedCreateWithoutAgentInput>
  }

  export type IgnoreCreateWithoutAgentInput = {
    id?: string
    timestamp?: Date | string
    duration?: number
    game: GameCreateNestedOneWithoutIgnoreInput
    ignoredAgent: AgentCreateNestedOneWithoutIgnoringInput
  }

  export type IgnoreUncheckedCreateWithoutAgentInput = {
    id?: string
    timestamp?: Date | string
    duration?: number
    gameId: string
    ignoredAgentId: string
  }

  export type IgnoreCreateOrConnectWithoutAgentInput = {
    where: IgnoreWhereUniqueInput
    create: XOR<IgnoreCreateWithoutAgentInput, IgnoreUncheckedCreateWithoutAgentInput>
  }

  export type IgnoreCreateManyAgentInputEnvelope = {
    data: IgnoreCreateManyAgentInput | IgnoreCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type IgnoreCreateWithoutIgnoredAgentInput = {
    id?: string
    timestamp?: Date | string
    duration?: number
    agent: AgentCreateNestedOneWithoutIgnoredByInput
    game: GameCreateNestedOneWithoutIgnoreInput
  }

  export type IgnoreUncheckedCreateWithoutIgnoredAgentInput = {
    id?: string
    agentId: string
    timestamp?: Date | string
    duration?: number
    gameId: string
  }

  export type IgnoreCreateOrConnectWithoutIgnoredAgentInput = {
    where: IgnoreWhereUniqueInput
    create: XOR<IgnoreCreateWithoutIgnoredAgentInput, IgnoreUncheckedCreateWithoutIgnoredAgentInput>
  }

  export type IgnoreCreateManyIgnoredAgentInputEnvelope = {
    data: IgnoreCreateManyIgnoredAgentInput | IgnoreCreateManyIgnoredAgentInput[]
    skipDuplicates?: boolean
  }

  export type GameLogCreateWithoutAgentInput = {
    id?: string
    timestamp?: Date | string
    type: string
    level: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    game?: GameCreateNestedOneWithoutGameLogInput
  }

  export type GameLogUncheckedCreateWithoutAgentInput = {
    id?: string
    timestamp?: Date | string
    type: string
    level: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    gameId?: string | null
  }

  export type GameLogCreateOrConnectWithoutAgentInput = {
    where: GameLogWhereUniqueInput
    create: XOR<GameLogCreateWithoutAgentInput, GameLogUncheckedCreateWithoutAgentInput>
  }

  export type GameLogCreateManyAgentInputEnvelope = {
    data: GameLogCreateManyAgentInput | GameLogCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type GameEventCreateWithoutInitiatorInput = {
    id?: string
    createdAt?: Date | string
    eventType: $Enums.EventType
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    target?: AgentCreateNestedOneWithoutTargetedEventsInput
    game: GameCreateNestedOneWithoutGameEventInput
  }

  export type GameEventUncheckedCreateWithoutInitiatorInput = {
    id?: string
    createdAt?: Date | string
    eventType: $Enums.EventType
    targetId?: string | null
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type GameEventCreateOrConnectWithoutInitiatorInput = {
    where: GameEventWhereUniqueInput
    create: XOR<GameEventCreateWithoutInitiatorInput, GameEventUncheckedCreateWithoutInitiatorInput>
  }

  export type GameEventCreateManyInitiatorInputEnvelope = {
    data: GameEventCreateManyInitiatorInput | GameEventCreateManyInitiatorInput[]
    skipDuplicates?: boolean
  }

  export type GameEventCreateWithoutTargetInput = {
    id?: string
    createdAt?: Date | string
    eventType: $Enums.EventType
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiator: AgentCreateNestedOneWithoutInitiatedEventsInput
    game: GameCreateNestedOneWithoutGameEventInput
  }

  export type GameEventUncheckedCreateWithoutTargetInput = {
    id?: string
    createdAt?: Date | string
    eventType: $Enums.EventType
    initiatorId: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type GameEventCreateOrConnectWithoutTargetInput = {
    where: GameEventWhereUniqueInput
    create: XOR<GameEventCreateWithoutTargetInput, GameEventUncheckedCreateWithoutTargetInput>
  }

  export type GameEventCreateManyTargetInputEnvelope = {
    data: GameEventCreateManyTargetInput | GameEventCreateManyTargetInput[]
    skipDuplicates?: boolean
  }

  export type TweetUpsertWithWhereUniqueWithoutAgentInput = {
    where: TweetWhereUniqueInput
    update: XOR<TweetUpdateWithoutAgentInput, TweetUncheckedUpdateWithoutAgentInput>
    create: XOR<TweetCreateWithoutAgentInput, TweetUncheckedCreateWithoutAgentInput>
  }

  export type TweetUpdateWithWhereUniqueWithoutAgentInput = {
    where: TweetWhereUniqueInput
    data: XOR<TweetUpdateWithoutAgentInput, TweetUncheckedUpdateWithoutAgentInput>
  }

  export type TweetUpdateManyWithWhereWithoutAgentInput = {
    where: TweetScalarWhereInput
    data: XOR<TweetUpdateManyMutationInput, TweetUncheckedUpdateManyWithoutAgentInput>
  }

  export type TweetScalarWhereInput = {
    AND?: TweetScalarWhereInput | TweetScalarWhereInput[]
    OR?: TweetScalarWhereInput[]
    NOT?: TweetScalarWhereInput | TweetScalarWhereInput[]
    id?: StringFilter<"Tweet"> | string
    agentId?: StringFilter<"Tweet"> | string
    content?: StringFilter<"Tweet"> | string
    type?: StringFilter<"Tweet"> | string
    timestamp?: DateTimeFilter<"Tweet"> | Date | string
    conversationId?: StringNullableFilter<"Tweet"> | string | null
  }

  export type GameUpsertWithoutAgentsInput = {
    update: XOR<GameUpdateWithoutAgentsInput, GameUncheckedUpdateWithoutAgentsInput>
    create: XOR<GameCreateWithoutAgentsInput, GameUncheckedCreateWithoutAgentsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutAgentsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutAgentsInput, GameUncheckedUpdateWithoutAgentsInput>
  }

  export type GameUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    tokenMint?: StringFieldUpdateOperationsInput | string
    rewardsVault?: StringFieldUpdateOperationsInput | string
    mapDiameter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bump?: IntFieldUpdateOperationsInput | number
    dailyRewardTokens?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alliances?: AllianceUpdateManyWithoutGameNestedInput
    battles?: BattleUpdateManyWithoutGameNestedInput
    coolDown?: CoolDownUpdateManyWithoutGameNestedInput
    Ignore?: IgnoreUpdateManyWithoutGameNestedInput
    GameLog?: GameLogUpdateManyWithoutGameNestedInput
    GameEvent?: GameEventUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    tokenMint?: StringFieldUpdateOperationsInput | string
    rewardsVault?: StringFieldUpdateOperationsInput | string
    mapDiameter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bump?: IntFieldUpdateOperationsInput | number
    dailyRewardTokens?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alliances?: AllianceUncheckedUpdateManyWithoutGameNestedInput
    battles?: BattleUncheckedUpdateManyWithoutGameNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutGameNestedInput
    Ignore?: IgnoreUncheckedUpdateManyWithoutGameNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutGameNestedInput
    GameEvent?: GameEventUncheckedUpdateManyWithoutGameNestedInput
  }

  export type BattleUpsertWithWhereUniqueWithoutAttackerInput = {
    where: BattleWhereUniqueInput
    update: XOR<BattleUpdateWithoutAttackerInput, BattleUncheckedUpdateWithoutAttackerInput>
    create: XOR<BattleCreateWithoutAttackerInput, BattleUncheckedCreateWithoutAttackerInput>
  }

  export type BattleUpdateWithWhereUniqueWithoutAttackerInput = {
    where: BattleWhereUniqueInput
    data: XOR<BattleUpdateWithoutAttackerInput, BattleUncheckedUpdateWithoutAttackerInput>
  }

  export type BattleUpdateManyWithWhereWithoutAttackerInput = {
    where: BattleScalarWhereInput
    data: XOR<BattleUpdateManyMutationInput, BattleUncheckedUpdateManyWithoutAttackerInput>
  }

  export type BattleUpsertWithWhereUniqueWithoutDefenderInput = {
    where: BattleWhereUniqueInput
    update: XOR<BattleUpdateWithoutDefenderInput, BattleUncheckedUpdateWithoutDefenderInput>
    create: XOR<BattleCreateWithoutDefenderInput, BattleUncheckedCreateWithoutDefenderInput>
  }

  export type BattleUpdateWithWhereUniqueWithoutDefenderInput = {
    where: BattleWhereUniqueInput
    data: XOR<BattleUpdateWithoutDefenderInput, BattleUncheckedUpdateWithoutDefenderInput>
  }

  export type BattleUpdateManyWithWhereWithoutDefenderInput = {
    where: BattleScalarWhereInput
    data: XOR<BattleUpdateManyMutationInput, BattleUncheckedUpdateManyWithoutDefenderInput>
  }

  export type BattleUpsertWithWhereUniqueWithoutAttackerAllyInput = {
    where: BattleWhereUniqueInput
    update: XOR<BattleUpdateWithoutAttackerAllyInput, BattleUncheckedUpdateWithoutAttackerAllyInput>
    create: XOR<BattleCreateWithoutAttackerAllyInput, BattleUncheckedCreateWithoutAttackerAllyInput>
  }

  export type BattleUpdateWithWhereUniqueWithoutAttackerAllyInput = {
    where: BattleWhereUniqueInput
    data: XOR<BattleUpdateWithoutAttackerAllyInput, BattleUncheckedUpdateWithoutAttackerAllyInput>
  }

  export type BattleUpdateManyWithWhereWithoutAttackerAllyInput = {
    where: BattleScalarWhereInput
    data: XOR<BattleUpdateManyMutationInput, BattleUncheckedUpdateManyWithoutAttackerAllyInput>
  }

  export type BattleUpsertWithWhereUniqueWithoutDefenderAllyInput = {
    where: BattleWhereUniqueInput
    update: XOR<BattleUpdateWithoutDefenderAllyInput, BattleUncheckedUpdateWithoutDefenderAllyInput>
    create: XOR<BattleCreateWithoutDefenderAllyInput, BattleUncheckedCreateWithoutDefenderAllyInput>
  }

  export type BattleUpdateWithWhereUniqueWithoutDefenderAllyInput = {
    where: BattleWhereUniqueInput
    data: XOR<BattleUpdateWithoutDefenderAllyInput, BattleUncheckedUpdateWithoutDefenderAllyInput>
  }

  export type BattleUpdateManyWithWhereWithoutDefenderAllyInput = {
    where: BattleScalarWhereInput
    data: XOR<BattleUpdateManyMutationInput, BattleUncheckedUpdateManyWithoutDefenderAllyInput>
  }

  export type BattleUpsertWithWhereUniqueWithoutWinnerInput = {
    where: BattleWhereUniqueInput
    update: XOR<BattleUpdateWithoutWinnerInput, BattleUncheckedUpdateWithoutWinnerInput>
    create: XOR<BattleCreateWithoutWinnerInput, BattleUncheckedCreateWithoutWinnerInput>
  }

  export type BattleUpdateWithWhereUniqueWithoutWinnerInput = {
    where: BattleWhereUniqueInput
    data: XOR<BattleUpdateWithoutWinnerInput, BattleUncheckedUpdateWithoutWinnerInput>
  }

  export type BattleUpdateManyWithWhereWithoutWinnerInput = {
    where: BattleScalarWhereInput
    data: XOR<BattleUpdateManyMutationInput, BattleUncheckedUpdateManyWithoutWinnerInput>
  }

  export type CoolDownUpsertWithWhereUniqueWithoutCooledAgentInput = {
    where: CoolDownWhereUniqueInput
    update: XOR<CoolDownUpdateWithoutCooledAgentInput, CoolDownUncheckedUpdateWithoutCooledAgentInput>
    create: XOR<CoolDownCreateWithoutCooledAgentInput, CoolDownUncheckedCreateWithoutCooledAgentInput>
  }

  export type CoolDownUpdateWithWhereUniqueWithoutCooledAgentInput = {
    where: CoolDownWhereUniqueInput
    data: XOR<CoolDownUpdateWithoutCooledAgentInput, CoolDownUncheckedUpdateWithoutCooledAgentInput>
  }

  export type CoolDownUpdateManyWithWhereWithoutCooledAgentInput = {
    where: CoolDownScalarWhereInput
    data: XOR<CoolDownUpdateManyMutationInput, CoolDownUncheckedUpdateManyWithoutCooledAgentInput>
  }

  export type AllianceUpsertWithWhereUniqueWithoutInitiatorInput = {
    where: AllianceWhereUniqueInput
    update: XOR<AllianceUpdateWithoutInitiatorInput, AllianceUncheckedUpdateWithoutInitiatorInput>
    create: XOR<AllianceCreateWithoutInitiatorInput, AllianceUncheckedCreateWithoutInitiatorInput>
  }

  export type AllianceUpdateWithWhereUniqueWithoutInitiatorInput = {
    where: AllianceWhereUniqueInput
    data: XOR<AllianceUpdateWithoutInitiatorInput, AllianceUncheckedUpdateWithoutInitiatorInput>
  }

  export type AllianceUpdateManyWithWhereWithoutInitiatorInput = {
    where: AllianceScalarWhereInput
    data: XOR<AllianceUpdateManyMutationInput, AllianceUncheckedUpdateManyWithoutInitiatorInput>
  }

  export type AllianceUpsertWithWhereUniqueWithoutJoinerInput = {
    where: AllianceWhereUniqueInput
    update: XOR<AllianceUpdateWithoutJoinerInput, AllianceUncheckedUpdateWithoutJoinerInput>
    create: XOR<AllianceCreateWithoutJoinerInput, AllianceUncheckedCreateWithoutJoinerInput>
  }

  export type AllianceUpdateWithWhereUniqueWithoutJoinerInput = {
    where: AllianceWhereUniqueInput
    data: XOR<AllianceUpdateWithoutJoinerInput, AllianceUncheckedUpdateWithoutJoinerInput>
  }

  export type AllianceUpdateManyWithWhereWithoutJoinerInput = {
    where: AllianceScalarWhereInput
    data: XOR<AllianceUpdateManyMutationInput, AllianceUncheckedUpdateManyWithoutJoinerInput>
  }

  export type AgentProfileUpsertWithoutAgentsInput = {
    update: XOR<AgentProfileUpdateWithoutAgentsInput, AgentProfileUncheckedUpdateWithoutAgentsInput>
    create: XOR<AgentProfileCreateWithoutAgentsInput, AgentProfileUncheckedCreateWithoutAgentsInput>
    where?: AgentProfileWhereInput
  }

  export type AgentProfileUpdateToOneWithWhereWithoutAgentsInput = {
    where?: AgentProfileWhereInput
    data: XOR<AgentProfileUpdateWithoutAgentsInput, AgentProfileUncheckedUpdateWithoutAgentsInput>
  }

  export type AgentProfileUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    xHandle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    followers?: IntFieldUpdateOperationsInput | number
    bio?: AgentProfileUpdatebioInput | string[]
    lore?: AgentProfileUpdateloreInput | string[]
    loreFulltext?: StringFieldUpdateOperationsInput | string
    characteristics?: AgentProfileUpdatecharacteristicsInput | string[]
    knowledge?: AgentProfileUpdateknowledgeInput | string[]
    traits?: JsonNullValueInput | InputJsonValue
    postExamples?: AgentProfileUpdatepostExamplesInput | string[]
  }

  export type AgentProfileUncheckedUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    xHandle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    followers?: IntFieldUpdateOperationsInput | number
    bio?: AgentProfileUpdatebioInput | string[]
    lore?: AgentProfileUpdateloreInput | string[]
    loreFulltext?: StringFieldUpdateOperationsInput | string
    characteristics?: AgentProfileUpdatecharacteristicsInput | string[]
    knowledge?: AgentProfileUpdateknowledgeInput | string[]
    traits?: JsonNullValueInput | InputJsonValue
    postExamples?: AgentProfileUpdatepostExamplesInput | string[]
  }

  export type MapTileUpsertWithoutAgentInput = {
    update: XOR<MapTileUpdateWithoutAgentInput, MapTileUncheckedUpdateWithoutAgentInput>
    create: XOR<MapTileCreateWithoutAgentInput, MapTileUncheckedCreateWithoutAgentInput>
    where?: MapTileWhereInput
  }

  export type MapTileUpdateToOneWithWhereWithoutAgentInput = {
    where?: MapTileWhereInput
    data: XOR<MapTileUpdateWithoutAgentInput, MapTileUncheckedUpdateWithoutAgentInput>
  }

  export type MapTileUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    terrainType?: EnumTerrainTypeFieldUpdateOperationsInput | $Enums.TerrainType
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MapTileUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    terrainType?: EnumTerrainTypeFieldUpdateOperationsInput | $Enums.TerrainType
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IgnoreUpsertWithWhereUniqueWithoutAgentInput = {
    where: IgnoreWhereUniqueInput
    update: XOR<IgnoreUpdateWithoutAgentInput, IgnoreUncheckedUpdateWithoutAgentInput>
    create: XOR<IgnoreCreateWithoutAgentInput, IgnoreUncheckedCreateWithoutAgentInput>
  }

  export type IgnoreUpdateWithWhereUniqueWithoutAgentInput = {
    where: IgnoreWhereUniqueInput
    data: XOR<IgnoreUpdateWithoutAgentInput, IgnoreUncheckedUpdateWithoutAgentInput>
  }

  export type IgnoreUpdateManyWithWhereWithoutAgentInput = {
    where: IgnoreScalarWhereInput
    data: XOR<IgnoreUpdateManyMutationInput, IgnoreUncheckedUpdateManyWithoutAgentInput>
  }

  export type IgnoreUpsertWithWhereUniqueWithoutIgnoredAgentInput = {
    where: IgnoreWhereUniqueInput
    update: XOR<IgnoreUpdateWithoutIgnoredAgentInput, IgnoreUncheckedUpdateWithoutIgnoredAgentInput>
    create: XOR<IgnoreCreateWithoutIgnoredAgentInput, IgnoreUncheckedCreateWithoutIgnoredAgentInput>
  }

  export type IgnoreUpdateWithWhereUniqueWithoutIgnoredAgentInput = {
    where: IgnoreWhereUniqueInput
    data: XOR<IgnoreUpdateWithoutIgnoredAgentInput, IgnoreUncheckedUpdateWithoutIgnoredAgentInput>
  }

  export type IgnoreUpdateManyWithWhereWithoutIgnoredAgentInput = {
    where: IgnoreScalarWhereInput
    data: XOR<IgnoreUpdateManyMutationInput, IgnoreUncheckedUpdateManyWithoutIgnoredAgentInput>
  }

  export type GameLogUpsertWithWhereUniqueWithoutAgentInput = {
    where: GameLogWhereUniqueInput
    update: XOR<GameLogUpdateWithoutAgentInput, GameLogUncheckedUpdateWithoutAgentInput>
    create: XOR<GameLogCreateWithoutAgentInput, GameLogUncheckedCreateWithoutAgentInput>
  }

  export type GameLogUpdateWithWhereUniqueWithoutAgentInput = {
    where: GameLogWhereUniqueInput
    data: XOR<GameLogUpdateWithoutAgentInput, GameLogUncheckedUpdateWithoutAgentInput>
  }

  export type GameLogUpdateManyWithWhereWithoutAgentInput = {
    where: GameLogScalarWhereInput
    data: XOR<GameLogUpdateManyMutationInput, GameLogUncheckedUpdateManyWithoutAgentInput>
  }

  export type GameEventUpsertWithWhereUniqueWithoutInitiatorInput = {
    where: GameEventWhereUniqueInput
    update: XOR<GameEventUpdateWithoutInitiatorInput, GameEventUncheckedUpdateWithoutInitiatorInput>
    create: XOR<GameEventCreateWithoutInitiatorInput, GameEventUncheckedCreateWithoutInitiatorInput>
  }

  export type GameEventUpdateWithWhereUniqueWithoutInitiatorInput = {
    where: GameEventWhereUniqueInput
    data: XOR<GameEventUpdateWithoutInitiatorInput, GameEventUncheckedUpdateWithoutInitiatorInput>
  }

  export type GameEventUpdateManyWithWhereWithoutInitiatorInput = {
    where: GameEventScalarWhereInput
    data: XOR<GameEventUpdateManyMutationInput, GameEventUncheckedUpdateManyWithoutInitiatorInput>
  }

  export type GameEventUpsertWithWhereUniqueWithoutTargetInput = {
    where: GameEventWhereUniqueInput
    update: XOR<GameEventUpdateWithoutTargetInput, GameEventUncheckedUpdateWithoutTargetInput>
    create: XOR<GameEventCreateWithoutTargetInput, GameEventUncheckedCreateWithoutTargetInput>
  }

  export type GameEventUpdateWithWhereUniqueWithoutTargetInput = {
    where: GameEventWhereUniqueInput
    data: XOR<GameEventUpdateWithoutTargetInput, GameEventUncheckedUpdateWithoutTargetInput>
  }

  export type GameEventUpdateManyWithWhereWithoutTargetInput = {
    where: GameEventScalarWhereInput
    data: XOR<GameEventUpdateManyMutationInput, GameEventUncheckedUpdateManyWithoutTargetInput>
  }

  export type AgentCreateWithoutIgnoredByInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    isAlive?: boolean
    deathTimestamp?: Date | string | null
    vault: string
    tweets?: TweetCreateNestedManyWithoutAgentInput
    game: GameCreateNestedOneWithoutAgentsInput
    battlesAsAttacker?: BattleCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceCreateNestedManyWithoutJoinerInput
    profile: AgentProfileCreateNestedOneWithoutAgentsInput
    mapTile: MapTileCreateNestedOneWithoutAgentInput
    ignoring?: IgnoreCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventCreateNestedManyWithoutTargetInput
  }

  export type AgentUncheckedCreateWithoutIgnoredByInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    gameId: string
    isAlive?: boolean
    profileId: string
    deathTimestamp?: Date | string | null
    mapTileId: string
    vault: string
    tweets?: TweetUncheckedCreateNestedManyWithoutAgentInput
    battlesAsAttacker?: BattleUncheckedCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleUncheckedCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleUncheckedCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleUncheckedCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleUncheckedCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceUncheckedCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceUncheckedCreateNestedManyWithoutJoinerInput
    ignoring?: IgnoreUncheckedCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventUncheckedCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventUncheckedCreateNestedManyWithoutTargetInput
  }

  export type AgentCreateOrConnectWithoutIgnoredByInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutIgnoredByInput, AgentUncheckedCreateWithoutIgnoredByInput>
  }

  export type GameCreateWithoutIgnoreInput = {
    id?: string
    onchainId: number
    authority: string
    pda: string
    tokenMint: string
    rewardsVault: string
    mapDiameter: number
    isActive?: boolean
    lastUpdate?: Date | string
    bump: number
    dailyRewardTokens: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutGameInput
    alliances?: AllianceCreateNestedManyWithoutGameInput
    battles?: BattleCreateNestedManyWithoutGameInput
    coolDown?: CoolDownCreateNestedManyWithoutGameInput
    GameLog?: GameLogCreateNestedManyWithoutGameInput
    GameEvent?: GameEventCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutIgnoreInput = {
    id?: string
    onchainId: number
    authority: string
    pda: string
    tokenMint: string
    rewardsVault: string
    mapDiameter: number
    isActive?: boolean
    lastUpdate?: Date | string
    bump: number
    dailyRewardTokens: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutGameInput
    alliances?: AllianceUncheckedCreateNestedManyWithoutGameInput
    battles?: BattleUncheckedCreateNestedManyWithoutGameInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutGameInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutGameInput
    GameEvent?: GameEventUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutIgnoreInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutIgnoreInput, GameUncheckedCreateWithoutIgnoreInput>
  }

  export type AgentCreateWithoutIgnoringInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    isAlive?: boolean
    deathTimestamp?: Date | string | null
    vault: string
    tweets?: TweetCreateNestedManyWithoutAgentInput
    game: GameCreateNestedOneWithoutAgentsInput
    battlesAsAttacker?: BattleCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceCreateNestedManyWithoutJoinerInput
    profile: AgentProfileCreateNestedOneWithoutAgentsInput
    mapTile: MapTileCreateNestedOneWithoutAgentInput
    ignoredBy?: IgnoreCreateNestedManyWithoutAgentInput
    GameLog?: GameLogCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventCreateNestedManyWithoutTargetInput
  }

  export type AgentUncheckedCreateWithoutIgnoringInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    gameId: string
    isAlive?: boolean
    profileId: string
    deathTimestamp?: Date | string | null
    mapTileId: string
    vault: string
    tweets?: TweetUncheckedCreateNestedManyWithoutAgentInput
    battlesAsAttacker?: BattleUncheckedCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleUncheckedCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleUncheckedCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleUncheckedCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleUncheckedCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceUncheckedCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceUncheckedCreateNestedManyWithoutJoinerInput
    ignoredBy?: IgnoreUncheckedCreateNestedManyWithoutAgentInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventUncheckedCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventUncheckedCreateNestedManyWithoutTargetInput
  }

  export type AgentCreateOrConnectWithoutIgnoringInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutIgnoringInput, AgentUncheckedCreateWithoutIgnoringInput>
  }

  export type AgentUpsertWithoutIgnoredByInput = {
    update: XOR<AgentUpdateWithoutIgnoredByInput, AgentUncheckedUpdateWithoutIgnoredByInput>
    create: XOR<AgentCreateWithoutIgnoredByInput, AgentUncheckedCreateWithoutIgnoredByInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutIgnoredByInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutIgnoredByInput, AgentUncheckedUpdateWithoutIgnoredByInput>
  }

  export type AgentUpdateWithoutIgnoredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUpdateManyWithoutAgentNestedInput
    game?: GameUpdateOneRequiredWithoutAgentsNestedInput
    battlesAsAttacker?: BattleUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUpdateManyWithoutJoinerNestedInput
    profile?: AgentProfileUpdateOneRequiredWithoutAgentsNestedInput
    mapTile?: MapTileUpdateOneRequiredWithoutAgentNestedInput
    ignoring?: IgnoreUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUpdateManyWithoutTargetNestedInput
  }

  export type AgentUncheckedUpdateWithoutIgnoredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mapTileId?: StringFieldUpdateOperationsInput | string
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUncheckedUpdateManyWithoutAgentNestedInput
    battlesAsAttacker?: BattleUncheckedUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUncheckedUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUncheckedUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUncheckedUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUncheckedUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUncheckedUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUncheckedUpdateManyWithoutJoinerNestedInput
    ignoring?: IgnoreUncheckedUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type GameUpsertWithoutIgnoreInput = {
    update: XOR<GameUpdateWithoutIgnoreInput, GameUncheckedUpdateWithoutIgnoreInput>
    create: XOR<GameCreateWithoutIgnoreInput, GameUncheckedCreateWithoutIgnoreInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutIgnoreInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutIgnoreInput, GameUncheckedUpdateWithoutIgnoreInput>
  }

  export type GameUpdateWithoutIgnoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    tokenMint?: StringFieldUpdateOperationsInput | string
    rewardsVault?: StringFieldUpdateOperationsInput | string
    mapDiameter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bump?: IntFieldUpdateOperationsInput | number
    dailyRewardTokens?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutGameNestedInput
    alliances?: AllianceUpdateManyWithoutGameNestedInput
    battles?: BattleUpdateManyWithoutGameNestedInput
    coolDown?: CoolDownUpdateManyWithoutGameNestedInput
    GameLog?: GameLogUpdateManyWithoutGameNestedInput
    GameEvent?: GameEventUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutIgnoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    tokenMint?: StringFieldUpdateOperationsInput | string
    rewardsVault?: StringFieldUpdateOperationsInput | string
    mapDiameter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bump?: IntFieldUpdateOperationsInput | number
    dailyRewardTokens?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutGameNestedInput
    alliances?: AllianceUncheckedUpdateManyWithoutGameNestedInput
    battles?: BattleUncheckedUpdateManyWithoutGameNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutGameNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutGameNestedInput
    GameEvent?: GameEventUncheckedUpdateManyWithoutGameNestedInput
  }

  export type AgentUpsertWithoutIgnoringInput = {
    update: XOR<AgentUpdateWithoutIgnoringInput, AgentUncheckedUpdateWithoutIgnoringInput>
    create: XOR<AgentCreateWithoutIgnoringInput, AgentUncheckedCreateWithoutIgnoringInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutIgnoringInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutIgnoringInput, AgentUncheckedUpdateWithoutIgnoringInput>
  }

  export type AgentUpdateWithoutIgnoringInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUpdateManyWithoutAgentNestedInput
    game?: GameUpdateOneRequiredWithoutAgentsNestedInput
    battlesAsAttacker?: BattleUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUpdateManyWithoutJoinerNestedInput
    profile?: AgentProfileUpdateOneRequiredWithoutAgentsNestedInput
    mapTile?: MapTileUpdateOneRequiredWithoutAgentNestedInput
    ignoredBy?: IgnoreUpdateManyWithoutAgentNestedInput
    GameLog?: GameLogUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUpdateManyWithoutTargetNestedInput
  }

  export type AgentUncheckedUpdateWithoutIgnoringInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mapTileId?: StringFieldUpdateOperationsInput | string
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUncheckedUpdateManyWithoutAgentNestedInput
    battlesAsAttacker?: BattleUncheckedUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUncheckedUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUncheckedUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUncheckedUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUncheckedUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUncheckedUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUncheckedUpdateManyWithoutJoinerNestedInput
    ignoredBy?: IgnoreUncheckedUpdateManyWithoutAgentNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type AgentCreateWithoutMapTileInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    isAlive?: boolean
    deathTimestamp?: Date | string | null
    vault: string
    tweets?: TweetCreateNestedManyWithoutAgentInput
    game: GameCreateNestedOneWithoutAgentsInput
    battlesAsAttacker?: BattleCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceCreateNestedManyWithoutJoinerInput
    profile: AgentProfileCreateNestedOneWithoutAgentsInput
    ignoredBy?: IgnoreCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventCreateNestedManyWithoutTargetInput
  }

  export type AgentUncheckedCreateWithoutMapTileInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    gameId: string
    isAlive?: boolean
    profileId: string
    deathTimestamp?: Date | string | null
    vault: string
    tweets?: TweetUncheckedCreateNestedManyWithoutAgentInput
    battlesAsAttacker?: BattleUncheckedCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleUncheckedCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleUncheckedCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleUncheckedCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleUncheckedCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceUncheckedCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceUncheckedCreateNestedManyWithoutJoinerInput
    ignoredBy?: IgnoreUncheckedCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreUncheckedCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventUncheckedCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventUncheckedCreateNestedManyWithoutTargetInput
  }

  export type AgentCreateOrConnectWithoutMapTileInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutMapTileInput, AgentUncheckedCreateWithoutMapTileInput>
  }

  export type AgentUpsertWithoutMapTileInput = {
    update: XOR<AgentUpdateWithoutMapTileInput, AgentUncheckedUpdateWithoutMapTileInput>
    create: XOR<AgentCreateWithoutMapTileInput, AgentUncheckedCreateWithoutMapTileInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutMapTileInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutMapTileInput, AgentUncheckedUpdateWithoutMapTileInput>
  }

  export type AgentUpdateWithoutMapTileInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUpdateManyWithoutAgentNestedInput
    game?: GameUpdateOneRequiredWithoutAgentsNestedInput
    battlesAsAttacker?: BattleUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUpdateManyWithoutJoinerNestedInput
    profile?: AgentProfileUpdateOneRequiredWithoutAgentsNestedInput
    ignoredBy?: IgnoreUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUpdateManyWithoutTargetNestedInput
  }

  export type AgentUncheckedUpdateWithoutMapTileInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUncheckedUpdateManyWithoutAgentNestedInput
    battlesAsAttacker?: BattleUncheckedUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUncheckedUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUncheckedUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUncheckedUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUncheckedUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUncheckedUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUncheckedUpdateManyWithoutJoinerNestedInput
    ignoredBy?: IgnoreUncheckedUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUncheckedUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type AgentCreateWithoutTweetsInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    isAlive?: boolean
    deathTimestamp?: Date | string | null
    vault: string
    game: GameCreateNestedOneWithoutAgentsInput
    battlesAsAttacker?: BattleCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceCreateNestedManyWithoutJoinerInput
    profile: AgentProfileCreateNestedOneWithoutAgentsInput
    mapTile: MapTileCreateNestedOneWithoutAgentInput
    ignoredBy?: IgnoreCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventCreateNestedManyWithoutTargetInput
  }

  export type AgentUncheckedCreateWithoutTweetsInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    gameId: string
    isAlive?: boolean
    profileId: string
    deathTimestamp?: Date | string | null
    mapTileId: string
    vault: string
    battlesAsAttacker?: BattleUncheckedCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleUncheckedCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleUncheckedCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleUncheckedCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleUncheckedCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceUncheckedCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceUncheckedCreateNestedManyWithoutJoinerInput
    ignoredBy?: IgnoreUncheckedCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreUncheckedCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventUncheckedCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventUncheckedCreateNestedManyWithoutTargetInput
  }

  export type AgentCreateOrConnectWithoutTweetsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutTweetsInput, AgentUncheckedCreateWithoutTweetsInput>
  }

  export type InteractionCreateWithoutTweetInput = {
    id?: string
    userId: string
    type: $Enums.InteractionType
    content: string
    timestamp: Date | string
    userMetrics: JsonNullValueInput | InputJsonValue
  }

  export type InteractionUncheckedCreateWithoutTweetInput = {
    id?: string
    userId: string
    type: $Enums.InteractionType
    content: string
    timestamp: Date | string
    userMetrics: JsonNullValueInput | InputJsonValue
  }

  export type InteractionCreateOrConnectWithoutTweetInput = {
    where: InteractionWhereUniqueInput
    create: XOR<InteractionCreateWithoutTweetInput, InteractionUncheckedCreateWithoutTweetInput>
  }

  export type InteractionCreateManyTweetInputEnvelope = {
    data: InteractionCreateManyTweetInput | InteractionCreateManyTweetInput[]
    skipDuplicates?: boolean
  }

  export type AgentUpsertWithoutTweetsInput = {
    update: XOR<AgentUpdateWithoutTweetsInput, AgentUncheckedUpdateWithoutTweetsInput>
    create: XOR<AgentCreateWithoutTweetsInput, AgentUncheckedCreateWithoutTweetsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutTweetsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutTweetsInput, AgentUncheckedUpdateWithoutTweetsInput>
  }

  export type AgentUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vault?: StringFieldUpdateOperationsInput | string
    game?: GameUpdateOneRequiredWithoutAgentsNestedInput
    battlesAsAttacker?: BattleUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUpdateManyWithoutJoinerNestedInput
    profile?: AgentProfileUpdateOneRequiredWithoutAgentsNestedInput
    mapTile?: MapTileUpdateOneRequiredWithoutAgentNestedInput
    ignoredBy?: IgnoreUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUpdateManyWithoutTargetNestedInput
  }

  export type AgentUncheckedUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mapTileId?: StringFieldUpdateOperationsInput | string
    vault?: StringFieldUpdateOperationsInput | string
    battlesAsAttacker?: BattleUncheckedUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUncheckedUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUncheckedUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUncheckedUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUncheckedUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUncheckedUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUncheckedUpdateManyWithoutJoinerNestedInput
    ignoredBy?: IgnoreUncheckedUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUncheckedUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type InteractionUpsertWithWhereUniqueWithoutTweetInput = {
    where: InteractionWhereUniqueInput
    update: XOR<InteractionUpdateWithoutTweetInput, InteractionUncheckedUpdateWithoutTweetInput>
    create: XOR<InteractionCreateWithoutTweetInput, InteractionUncheckedCreateWithoutTweetInput>
  }

  export type InteractionUpdateWithWhereUniqueWithoutTweetInput = {
    where: InteractionWhereUniqueInput
    data: XOR<InteractionUpdateWithoutTweetInput, InteractionUncheckedUpdateWithoutTweetInput>
  }

  export type InteractionUpdateManyWithWhereWithoutTweetInput = {
    where: InteractionScalarWhereInput
    data: XOR<InteractionUpdateManyMutationInput, InteractionUncheckedUpdateManyWithoutTweetInput>
  }

  export type InteractionScalarWhereInput = {
    AND?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
    OR?: InteractionScalarWhereInput[]
    NOT?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
    id?: StringFilter<"Interaction"> | string
    tweetId?: StringFilter<"Interaction"> | string
    userId?: StringFilter<"Interaction"> | string
    type?: EnumInteractionTypeFilter<"Interaction"> | $Enums.InteractionType
    content?: StringFilter<"Interaction"> | string
    timestamp?: DateTimeFilter<"Interaction"> | Date | string
    userMetrics?: JsonFilter<"Interaction">
  }

  export type GameCreateWithoutAlliancesInput = {
    id?: string
    onchainId: number
    authority: string
    pda: string
    tokenMint: string
    rewardsVault: string
    mapDiameter: number
    isActive?: boolean
    lastUpdate?: Date | string
    bump: number
    dailyRewardTokens: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutGameInput
    battles?: BattleCreateNestedManyWithoutGameInput
    coolDown?: CoolDownCreateNestedManyWithoutGameInput
    Ignore?: IgnoreCreateNestedManyWithoutGameInput
    GameLog?: GameLogCreateNestedManyWithoutGameInput
    GameEvent?: GameEventCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutAlliancesInput = {
    id?: string
    onchainId: number
    authority: string
    pda: string
    tokenMint: string
    rewardsVault: string
    mapDiameter: number
    isActive?: boolean
    lastUpdate?: Date | string
    bump: number
    dailyRewardTokens: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutGameInput
    battles?: BattleUncheckedCreateNestedManyWithoutGameInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutGameInput
    Ignore?: IgnoreUncheckedCreateNestedManyWithoutGameInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutGameInput
    GameEvent?: GameEventUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutAlliancesInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutAlliancesInput, GameUncheckedCreateWithoutAlliancesInput>
  }

  export type AgentCreateWithoutInitiatedAlliancesInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    isAlive?: boolean
    deathTimestamp?: Date | string | null
    vault: string
    tweets?: TweetCreateNestedManyWithoutAgentInput
    game: GameCreateNestedOneWithoutAgentsInput
    battlesAsAttacker?: BattleCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownCreateNestedManyWithoutCooledAgentInput
    joinedAlliances?: AllianceCreateNestedManyWithoutJoinerInput
    profile: AgentProfileCreateNestedOneWithoutAgentsInput
    mapTile: MapTileCreateNestedOneWithoutAgentInput
    ignoredBy?: IgnoreCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventCreateNestedManyWithoutTargetInput
  }

  export type AgentUncheckedCreateWithoutInitiatedAlliancesInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    gameId: string
    isAlive?: boolean
    profileId: string
    deathTimestamp?: Date | string | null
    mapTileId: string
    vault: string
    tweets?: TweetUncheckedCreateNestedManyWithoutAgentInput
    battlesAsAttacker?: BattleUncheckedCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleUncheckedCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleUncheckedCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleUncheckedCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleUncheckedCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutCooledAgentInput
    joinedAlliances?: AllianceUncheckedCreateNestedManyWithoutJoinerInput
    ignoredBy?: IgnoreUncheckedCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreUncheckedCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventUncheckedCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventUncheckedCreateNestedManyWithoutTargetInput
  }

  export type AgentCreateOrConnectWithoutInitiatedAlliancesInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutInitiatedAlliancesInput, AgentUncheckedCreateWithoutInitiatedAlliancesInput>
  }

  export type AgentCreateWithoutJoinedAlliancesInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    isAlive?: boolean
    deathTimestamp?: Date | string | null
    vault: string
    tweets?: TweetCreateNestedManyWithoutAgentInput
    game: GameCreateNestedOneWithoutAgentsInput
    battlesAsAttacker?: BattleCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceCreateNestedManyWithoutInitiatorInput
    profile: AgentProfileCreateNestedOneWithoutAgentsInput
    mapTile: MapTileCreateNestedOneWithoutAgentInput
    ignoredBy?: IgnoreCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventCreateNestedManyWithoutTargetInput
  }

  export type AgentUncheckedCreateWithoutJoinedAlliancesInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    gameId: string
    isAlive?: boolean
    profileId: string
    deathTimestamp?: Date | string | null
    mapTileId: string
    vault: string
    tweets?: TweetUncheckedCreateNestedManyWithoutAgentInput
    battlesAsAttacker?: BattleUncheckedCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleUncheckedCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleUncheckedCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleUncheckedCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleUncheckedCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceUncheckedCreateNestedManyWithoutInitiatorInput
    ignoredBy?: IgnoreUncheckedCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreUncheckedCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventUncheckedCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventUncheckedCreateNestedManyWithoutTargetInput
  }

  export type AgentCreateOrConnectWithoutJoinedAlliancesInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutJoinedAlliancesInput, AgentUncheckedCreateWithoutJoinedAlliancesInput>
  }

  export type GameUpsertWithoutAlliancesInput = {
    update: XOR<GameUpdateWithoutAlliancesInput, GameUncheckedUpdateWithoutAlliancesInput>
    create: XOR<GameCreateWithoutAlliancesInput, GameUncheckedCreateWithoutAlliancesInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutAlliancesInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutAlliancesInput, GameUncheckedUpdateWithoutAlliancesInput>
  }

  export type GameUpdateWithoutAlliancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    tokenMint?: StringFieldUpdateOperationsInput | string
    rewardsVault?: StringFieldUpdateOperationsInput | string
    mapDiameter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bump?: IntFieldUpdateOperationsInput | number
    dailyRewardTokens?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutGameNestedInput
    battles?: BattleUpdateManyWithoutGameNestedInput
    coolDown?: CoolDownUpdateManyWithoutGameNestedInput
    Ignore?: IgnoreUpdateManyWithoutGameNestedInput
    GameLog?: GameLogUpdateManyWithoutGameNestedInput
    GameEvent?: GameEventUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutAlliancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    tokenMint?: StringFieldUpdateOperationsInput | string
    rewardsVault?: StringFieldUpdateOperationsInput | string
    mapDiameter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bump?: IntFieldUpdateOperationsInput | number
    dailyRewardTokens?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutGameNestedInput
    battles?: BattleUncheckedUpdateManyWithoutGameNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutGameNestedInput
    Ignore?: IgnoreUncheckedUpdateManyWithoutGameNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutGameNestedInput
    GameEvent?: GameEventUncheckedUpdateManyWithoutGameNestedInput
  }

  export type AgentUpsertWithoutInitiatedAlliancesInput = {
    update: XOR<AgentUpdateWithoutInitiatedAlliancesInput, AgentUncheckedUpdateWithoutInitiatedAlliancesInput>
    create: XOR<AgentCreateWithoutInitiatedAlliancesInput, AgentUncheckedCreateWithoutInitiatedAlliancesInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutInitiatedAlliancesInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutInitiatedAlliancesInput, AgentUncheckedUpdateWithoutInitiatedAlliancesInput>
  }

  export type AgentUpdateWithoutInitiatedAlliancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUpdateManyWithoutAgentNestedInput
    game?: GameUpdateOneRequiredWithoutAgentsNestedInput
    battlesAsAttacker?: BattleUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUpdateManyWithoutCooledAgentNestedInput
    joinedAlliances?: AllianceUpdateManyWithoutJoinerNestedInput
    profile?: AgentProfileUpdateOneRequiredWithoutAgentsNestedInput
    mapTile?: MapTileUpdateOneRequiredWithoutAgentNestedInput
    ignoredBy?: IgnoreUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUpdateManyWithoutTargetNestedInput
  }

  export type AgentUncheckedUpdateWithoutInitiatedAlliancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mapTileId?: StringFieldUpdateOperationsInput | string
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUncheckedUpdateManyWithoutAgentNestedInput
    battlesAsAttacker?: BattleUncheckedUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUncheckedUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUncheckedUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUncheckedUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUncheckedUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutCooledAgentNestedInput
    joinedAlliances?: AllianceUncheckedUpdateManyWithoutJoinerNestedInput
    ignoredBy?: IgnoreUncheckedUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUncheckedUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type AgentUpsertWithoutJoinedAlliancesInput = {
    update: XOR<AgentUpdateWithoutJoinedAlliancesInput, AgentUncheckedUpdateWithoutJoinedAlliancesInput>
    create: XOR<AgentCreateWithoutJoinedAlliancesInput, AgentUncheckedCreateWithoutJoinedAlliancesInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutJoinedAlliancesInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutJoinedAlliancesInput, AgentUncheckedUpdateWithoutJoinedAlliancesInput>
  }

  export type AgentUpdateWithoutJoinedAlliancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUpdateManyWithoutAgentNestedInput
    game?: GameUpdateOneRequiredWithoutAgentsNestedInput
    battlesAsAttacker?: BattleUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUpdateManyWithoutInitiatorNestedInput
    profile?: AgentProfileUpdateOneRequiredWithoutAgentsNestedInput
    mapTile?: MapTileUpdateOneRequiredWithoutAgentNestedInput
    ignoredBy?: IgnoreUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUpdateManyWithoutTargetNestedInput
  }

  export type AgentUncheckedUpdateWithoutJoinedAlliancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mapTileId?: StringFieldUpdateOperationsInput | string
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUncheckedUpdateManyWithoutAgentNestedInput
    battlesAsAttacker?: BattleUncheckedUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUncheckedUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUncheckedUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUncheckedUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUncheckedUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUncheckedUpdateManyWithoutInitiatorNestedInput
    ignoredBy?: IgnoreUncheckedUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUncheckedUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type GameCreateWithoutBattlesInput = {
    id?: string
    onchainId: number
    authority: string
    pda: string
    tokenMint: string
    rewardsVault: string
    mapDiameter: number
    isActive?: boolean
    lastUpdate?: Date | string
    bump: number
    dailyRewardTokens: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutGameInput
    alliances?: AllianceCreateNestedManyWithoutGameInput
    coolDown?: CoolDownCreateNestedManyWithoutGameInput
    Ignore?: IgnoreCreateNestedManyWithoutGameInput
    GameLog?: GameLogCreateNestedManyWithoutGameInput
    GameEvent?: GameEventCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutBattlesInput = {
    id?: string
    onchainId: number
    authority: string
    pda: string
    tokenMint: string
    rewardsVault: string
    mapDiameter: number
    isActive?: boolean
    lastUpdate?: Date | string
    bump: number
    dailyRewardTokens: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutGameInput
    alliances?: AllianceUncheckedCreateNestedManyWithoutGameInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutGameInput
    Ignore?: IgnoreUncheckedCreateNestedManyWithoutGameInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutGameInput
    GameEvent?: GameEventUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutBattlesInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutBattlesInput, GameUncheckedCreateWithoutBattlesInput>
  }

  export type AgentCreateWithoutBattlesAsAttackerInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    isAlive?: boolean
    deathTimestamp?: Date | string | null
    vault: string
    tweets?: TweetCreateNestedManyWithoutAgentInput
    game: GameCreateNestedOneWithoutAgentsInput
    battlesAsDefender?: BattleCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceCreateNestedManyWithoutJoinerInput
    profile: AgentProfileCreateNestedOneWithoutAgentsInput
    mapTile: MapTileCreateNestedOneWithoutAgentInput
    ignoredBy?: IgnoreCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventCreateNestedManyWithoutTargetInput
  }

  export type AgentUncheckedCreateWithoutBattlesAsAttackerInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    gameId: string
    isAlive?: boolean
    profileId: string
    deathTimestamp?: Date | string | null
    mapTileId: string
    vault: string
    tweets?: TweetUncheckedCreateNestedManyWithoutAgentInput
    battlesAsDefender?: BattleUncheckedCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleUncheckedCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleUncheckedCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleUncheckedCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceUncheckedCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceUncheckedCreateNestedManyWithoutJoinerInput
    ignoredBy?: IgnoreUncheckedCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreUncheckedCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventUncheckedCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventUncheckedCreateNestedManyWithoutTargetInput
  }

  export type AgentCreateOrConnectWithoutBattlesAsAttackerInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutBattlesAsAttackerInput, AgentUncheckedCreateWithoutBattlesAsAttackerInput>
  }

  export type AgentCreateWithoutBattlesAsDefenderInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    isAlive?: boolean
    deathTimestamp?: Date | string | null
    vault: string
    tweets?: TweetCreateNestedManyWithoutAgentInput
    game: GameCreateNestedOneWithoutAgentsInput
    battlesAsAttacker?: BattleCreateNestedManyWithoutAttackerInput
    battlesAsAttackerAlly?: BattleCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceCreateNestedManyWithoutJoinerInput
    profile: AgentProfileCreateNestedOneWithoutAgentsInput
    mapTile: MapTileCreateNestedOneWithoutAgentInput
    ignoredBy?: IgnoreCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventCreateNestedManyWithoutTargetInput
  }

  export type AgentUncheckedCreateWithoutBattlesAsDefenderInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    gameId: string
    isAlive?: boolean
    profileId: string
    deathTimestamp?: Date | string | null
    mapTileId: string
    vault: string
    tweets?: TweetUncheckedCreateNestedManyWithoutAgentInput
    battlesAsAttacker?: BattleUncheckedCreateNestedManyWithoutAttackerInput
    battlesAsAttackerAlly?: BattleUncheckedCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleUncheckedCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleUncheckedCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceUncheckedCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceUncheckedCreateNestedManyWithoutJoinerInput
    ignoredBy?: IgnoreUncheckedCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreUncheckedCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventUncheckedCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventUncheckedCreateNestedManyWithoutTargetInput
  }

  export type AgentCreateOrConnectWithoutBattlesAsDefenderInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutBattlesAsDefenderInput, AgentUncheckedCreateWithoutBattlesAsDefenderInput>
  }

  export type AgentCreateWithoutBattlesAsAttackerAllyInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    isAlive?: boolean
    deathTimestamp?: Date | string | null
    vault: string
    tweets?: TweetCreateNestedManyWithoutAgentInput
    game: GameCreateNestedOneWithoutAgentsInput
    battlesAsAttacker?: BattleCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleCreateNestedManyWithoutDefenderInput
    battlesAsDefenderAlly?: BattleCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceCreateNestedManyWithoutJoinerInput
    profile: AgentProfileCreateNestedOneWithoutAgentsInput
    mapTile: MapTileCreateNestedOneWithoutAgentInput
    ignoredBy?: IgnoreCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventCreateNestedManyWithoutTargetInput
  }

  export type AgentUncheckedCreateWithoutBattlesAsAttackerAllyInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    gameId: string
    isAlive?: boolean
    profileId: string
    deathTimestamp?: Date | string | null
    mapTileId: string
    vault: string
    tweets?: TweetUncheckedCreateNestedManyWithoutAgentInput
    battlesAsAttacker?: BattleUncheckedCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleUncheckedCreateNestedManyWithoutDefenderInput
    battlesAsDefenderAlly?: BattleUncheckedCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleUncheckedCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceUncheckedCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceUncheckedCreateNestedManyWithoutJoinerInput
    ignoredBy?: IgnoreUncheckedCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreUncheckedCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventUncheckedCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventUncheckedCreateNestedManyWithoutTargetInput
  }

  export type AgentCreateOrConnectWithoutBattlesAsAttackerAllyInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutBattlesAsAttackerAllyInput, AgentUncheckedCreateWithoutBattlesAsAttackerAllyInput>
  }

  export type AgentCreateWithoutBattlesAsDefenderAllyInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    isAlive?: boolean
    deathTimestamp?: Date | string | null
    vault: string
    tweets?: TweetCreateNestedManyWithoutAgentInput
    game: GameCreateNestedOneWithoutAgentsInput
    battlesAsAttacker?: BattleCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleCreateNestedManyWithoutAttackerAllyInput
    wonBattles?: BattleCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceCreateNestedManyWithoutJoinerInput
    profile: AgentProfileCreateNestedOneWithoutAgentsInput
    mapTile: MapTileCreateNestedOneWithoutAgentInput
    ignoredBy?: IgnoreCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventCreateNestedManyWithoutTargetInput
  }

  export type AgentUncheckedCreateWithoutBattlesAsDefenderAllyInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    gameId: string
    isAlive?: boolean
    profileId: string
    deathTimestamp?: Date | string | null
    mapTileId: string
    vault: string
    tweets?: TweetUncheckedCreateNestedManyWithoutAgentInput
    battlesAsAttacker?: BattleUncheckedCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleUncheckedCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleUncheckedCreateNestedManyWithoutAttackerAllyInput
    wonBattles?: BattleUncheckedCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceUncheckedCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceUncheckedCreateNestedManyWithoutJoinerInput
    ignoredBy?: IgnoreUncheckedCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreUncheckedCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventUncheckedCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventUncheckedCreateNestedManyWithoutTargetInput
  }

  export type AgentCreateOrConnectWithoutBattlesAsDefenderAllyInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutBattlesAsDefenderAllyInput, AgentUncheckedCreateWithoutBattlesAsDefenderAllyInput>
  }

  export type AgentCreateWithoutWonBattlesInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    isAlive?: boolean
    deathTimestamp?: Date | string | null
    vault: string
    tweets?: TweetCreateNestedManyWithoutAgentInput
    game: GameCreateNestedOneWithoutAgentsInput
    battlesAsAttacker?: BattleCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleCreateNestedManyWithoutDefenderAllyInput
    coolDown?: CoolDownCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceCreateNestedManyWithoutJoinerInput
    profile: AgentProfileCreateNestedOneWithoutAgentsInput
    mapTile: MapTileCreateNestedOneWithoutAgentInput
    ignoredBy?: IgnoreCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventCreateNestedManyWithoutTargetInput
  }

  export type AgentUncheckedCreateWithoutWonBattlesInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    gameId: string
    isAlive?: boolean
    profileId: string
    deathTimestamp?: Date | string | null
    mapTileId: string
    vault: string
    tweets?: TweetUncheckedCreateNestedManyWithoutAgentInput
    battlesAsAttacker?: BattleUncheckedCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleUncheckedCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleUncheckedCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleUncheckedCreateNestedManyWithoutDefenderAllyInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceUncheckedCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceUncheckedCreateNestedManyWithoutJoinerInput
    ignoredBy?: IgnoreUncheckedCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreUncheckedCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventUncheckedCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventUncheckedCreateNestedManyWithoutTargetInput
  }

  export type AgentCreateOrConnectWithoutWonBattlesInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutWonBattlesInput, AgentUncheckedCreateWithoutWonBattlesInput>
  }

  export type GameUpsertWithoutBattlesInput = {
    update: XOR<GameUpdateWithoutBattlesInput, GameUncheckedUpdateWithoutBattlesInput>
    create: XOR<GameCreateWithoutBattlesInput, GameUncheckedCreateWithoutBattlesInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutBattlesInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutBattlesInput, GameUncheckedUpdateWithoutBattlesInput>
  }

  export type GameUpdateWithoutBattlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    tokenMint?: StringFieldUpdateOperationsInput | string
    rewardsVault?: StringFieldUpdateOperationsInput | string
    mapDiameter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bump?: IntFieldUpdateOperationsInput | number
    dailyRewardTokens?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutGameNestedInput
    alliances?: AllianceUpdateManyWithoutGameNestedInput
    coolDown?: CoolDownUpdateManyWithoutGameNestedInput
    Ignore?: IgnoreUpdateManyWithoutGameNestedInput
    GameLog?: GameLogUpdateManyWithoutGameNestedInput
    GameEvent?: GameEventUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutBattlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    tokenMint?: StringFieldUpdateOperationsInput | string
    rewardsVault?: StringFieldUpdateOperationsInput | string
    mapDiameter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bump?: IntFieldUpdateOperationsInput | number
    dailyRewardTokens?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutGameNestedInput
    alliances?: AllianceUncheckedUpdateManyWithoutGameNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutGameNestedInput
    Ignore?: IgnoreUncheckedUpdateManyWithoutGameNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutGameNestedInput
    GameEvent?: GameEventUncheckedUpdateManyWithoutGameNestedInput
  }

  export type AgentUpsertWithoutBattlesAsAttackerInput = {
    update: XOR<AgentUpdateWithoutBattlesAsAttackerInput, AgentUncheckedUpdateWithoutBattlesAsAttackerInput>
    create: XOR<AgentCreateWithoutBattlesAsAttackerInput, AgentUncheckedCreateWithoutBattlesAsAttackerInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutBattlesAsAttackerInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutBattlesAsAttackerInput, AgentUncheckedUpdateWithoutBattlesAsAttackerInput>
  }

  export type AgentUpdateWithoutBattlesAsAttackerInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUpdateManyWithoutAgentNestedInput
    game?: GameUpdateOneRequiredWithoutAgentsNestedInput
    battlesAsDefender?: BattleUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUpdateManyWithoutJoinerNestedInput
    profile?: AgentProfileUpdateOneRequiredWithoutAgentsNestedInput
    mapTile?: MapTileUpdateOneRequiredWithoutAgentNestedInput
    ignoredBy?: IgnoreUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUpdateManyWithoutTargetNestedInput
  }

  export type AgentUncheckedUpdateWithoutBattlesAsAttackerInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mapTileId?: StringFieldUpdateOperationsInput | string
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUncheckedUpdateManyWithoutAgentNestedInput
    battlesAsDefender?: BattleUncheckedUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUncheckedUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUncheckedUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUncheckedUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUncheckedUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUncheckedUpdateManyWithoutJoinerNestedInput
    ignoredBy?: IgnoreUncheckedUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUncheckedUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type AgentUpsertWithoutBattlesAsDefenderInput = {
    update: XOR<AgentUpdateWithoutBattlesAsDefenderInput, AgentUncheckedUpdateWithoutBattlesAsDefenderInput>
    create: XOR<AgentCreateWithoutBattlesAsDefenderInput, AgentUncheckedCreateWithoutBattlesAsDefenderInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutBattlesAsDefenderInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutBattlesAsDefenderInput, AgentUncheckedUpdateWithoutBattlesAsDefenderInput>
  }

  export type AgentUpdateWithoutBattlesAsDefenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUpdateManyWithoutAgentNestedInput
    game?: GameUpdateOneRequiredWithoutAgentsNestedInput
    battlesAsAttacker?: BattleUpdateManyWithoutAttackerNestedInput
    battlesAsAttackerAlly?: BattleUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUpdateManyWithoutJoinerNestedInput
    profile?: AgentProfileUpdateOneRequiredWithoutAgentsNestedInput
    mapTile?: MapTileUpdateOneRequiredWithoutAgentNestedInput
    ignoredBy?: IgnoreUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUpdateManyWithoutTargetNestedInput
  }

  export type AgentUncheckedUpdateWithoutBattlesAsDefenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mapTileId?: StringFieldUpdateOperationsInput | string
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUncheckedUpdateManyWithoutAgentNestedInput
    battlesAsAttacker?: BattleUncheckedUpdateManyWithoutAttackerNestedInput
    battlesAsAttackerAlly?: BattleUncheckedUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUncheckedUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUncheckedUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUncheckedUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUncheckedUpdateManyWithoutJoinerNestedInput
    ignoredBy?: IgnoreUncheckedUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUncheckedUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type AgentUpsertWithoutBattlesAsAttackerAllyInput = {
    update: XOR<AgentUpdateWithoutBattlesAsAttackerAllyInput, AgentUncheckedUpdateWithoutBattlesAsAttackerAllyInput>
    create: XOR<AgentCreateWithoutBattlesAsAttackerAllyInput, AgentUncheckedCreateWithoutBattlesAsAttackerAllyInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutBattlesAsAttackerAllyInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutBattlesAsAttackerAllyInput, AgentUncheckedUpdateWithoutBattlesAsAttackerAllyInput>
  }

  export type AgentUpdateWithoutBattlesAsAttackerAllyInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUpdateManyWithoutAgentNestedInput
    game?: GameUpdateOneRequiredWithoutAgentsNestedInput
    battlesAsAttacker?: BattleUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUpdateManyWithoutDefenderNestedInput
    battlesAsDefenderAlly?: BattleUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUpdateManyWithoutJoinerNestedInput
    profile?: AgentProfileUpdateOneRequiredWithoutAgentsNestedInput
    mapTile?: MapTileUpdateOneRequiredWithoutAgentNestedInput
    ignoredBy?: IgnoreUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUpdateManyWithoutTargetNestedInput
  }

  export type AgentUncheckedUpdateWithoutBattlesAsAttackerAllyInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mapTileId?: StringFieldUpdateOperationsInput | string
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUncheckedUpdateManyWithoutAgentNestedInput
    battlesAsAttacker?: BattleUncheckedUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUncheckedUpdateManyWithoutDefenderNestedInput
    battlesAsDefenderAlly?: BattleUncheckedUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUncheckedUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUncheckedUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUncheckedUpdateManyWithoutJoinerNestedInput
    ignoredBy?: IgnoreUncheckedUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUncheckedUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type AgentUpsertWithoutBattlesAsDefenderAllyInput = {
    update: XOR<AgentUpdateWithoutBattlesAsDefenderAllyInput, AgentUncheckedUpdateWithoutBattlesAsDefenderAllyInput>
    create: XOR<AgentCreateWithoutBattlesAsDefenderAllyInput, AgentUncheckedCreateWithoutBattlesAsDefenderAllyInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutBattlesAsDefenderAllyInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutBattlesAsDefenderAllyInput, AgentUncheckedUpdateWithoutBattlesAsDefenderAllyInput>
  }

  export type AgentUpdateWithoutBattlesAsDefenderAllyInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUpdateManyWithoutAgentNestedInput
    game?: GameUpdateOneRequiredWithoutAgentsNestedInput
    battlesAsAttacker?: BattleUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUpdateManyWithoutAttackerAllyNestedInput
    wonBattles?: BattleUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUpdateManyWithoutJoinerNestedInput
    profile?: AgentProfileUpdateOneRequiredWithoutAgentsNestedInput
    mapTile?: MapTileUpdateOneRequiredWithoutAgentNestedInput
    ignoredBy?: IgnoreUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUpdateManyWithoutTargetNestedInput
  }

  export type AgentUncheckedUpdateWithoutBattlesAsDefenderAllyInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mapTileId?: StringFieldUpdateOperationsInput | string
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUncheckedUpdateManyWithoutAgentNestedInput
    battlesAsAttacker?: BattleUncheckedUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUncheckedUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUncheckedUpdateManyWithoutAttackerAllyNestedInput
    wonBattles?: BattleUncheckedUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUncheckedUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUncheckedUpdateManyWithoutJoinerNestedInput
    ignoredBy?: IgnoreUncheckedUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUncheckedUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type AgentUpsertWithoutWonBattlesInput = {
    update: XOR<AgentUpdateWithoutWonBattlesInput, AgentUncheckedUpdateWithoutWonBattlesInput>
    create: XOR<AgentCreateWithoutWonBattlesInput, AgentUncheckedCreateWithoutWonBattlesInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutWonBattlesInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutWonBattlesInput, AgentUncheckedUpdateWithoutWonBattlesInput>
  }

  export type AgentUpdateWithoutWonBattlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUpdateManyWithoutAgentNestedInput
    game?: GameUpdateOneRequiredWithoutAgentsNestedInput
    battlesAsAttacker?: BattleUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUpdateManyWithoutDefenderAllyNestedInput
    coolDown?: CoolDownUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUpdateManyWithoutJoinerNestedInput
    profile?: AgentProfileUpdateOneRequiredWithoutAgentsNestedInput
    mapTile?: MapTileUpdateOneRequiredWithoutAgentNestedInput
    ignoredBy?: IgnoreUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUpdateManyWithoutTargetNestedInput
  }

  export type AgentUncheckedUpdateWithoutWonBattlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mapTileId?: StringFieldUpdateOperationsInput | string
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUncheckedUpdateManyWithoutAgentNestedInput
    battlesAsAttacker?: BattleUncheckedUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUncheckedUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUncheckedUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUncheckedUpdateManyWithoutDefenderAllyNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUncheckedUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUncheckedUpdateManyWithoutJoinerNestedInput
    ignoredBy?: IgnoreUncheckedUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUncheckedUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type TweetCreateWithoutInteractionsInput = {
    id?: string
    content: string
    type: string
    timestamp: Date | string
    conversationId?: string | null
    agent: AgentCreateNestedOneWithoutTweetsInput
  }

  export type TweetUncheckedCreateWithoutInteractionsInput = {
    id?: string
    agentId: string
    content: string
    type: string
    timestamp: Date | string
    conversationId?: string | null
  }

  export type TweetCreateOrConnectWithoutInteractionsInput = {
    where: TweetWhereUniqueInput
    create: XOR<TweetCreateWithoutInteractionsInput, TweetUncheckedCreateWithoutInteractionsInput>
  }

  export type TweetUpsertWithoutInteractionsInput = {
    update: XOR<TweetUpdateWithoutInteractionsInput, TweetUncheckedUpdateWithoutInteractionsInput>
    create: XOR<TweetCreateWithoutInteractionsInput, TweetUncheckedCreateWithoutInteractionsInput>
    where?: TweetWhereInput
  }

  export type TweetUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: TweetWhereInput
    data: XOR<TweetUpdateWithoutInteractionsInput, TweetUncheckedUpdateWithoutInteractionsInput>
  }

  export type TweetUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: AgentUpdateOneRequiredWithoutTweetsNestedInput
  }

  export type TweetUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgentCreateWithoutCoolDownInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    isAlive?: boolean
    deathTimestamp?: Date | string | null
    vault: string
    tweets?: TweetCreateNestedManyWithoutAgentInput
    game: GameCreateNestedOneWithoutAgentsInput
    battlesAsAttacker?: BattleCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleCreateNestedManyWithoutWinnerInput
    initiatedAlliances?: AllianceCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceCreateNestedManyWithoutJoinerInput
    profile: AgentProfileCreateNestedOneWithoutAgentsInput
    mapTile: MapTileCreateNestedOneWithoutAgentInput
    ignoredBy?: IgnoreCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventCreateNestedManyWithoutTargetInput
  }

  export type AgentUncheckedCreateWithoutCoolDownInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    gameId: string
    isAlive?: boolean
    profileId: string
    deathTimestamp?: Date | string | null
    mapTileId: string
    vault: string
    tweets?: TweetUncheckedCreateNestedManyWithoutAgentInput
    battlesAsAttacker?: BattleUncheckedCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleUncheckedCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleUncheckedCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleUncheckedCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleUncheckedCreateNestedManyWithoutWinnerInput
    initiatedAlliances?: AllianceUncheckedCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceUncheckedCreateNestedManyWithoutJoinerInput
    ignoredBy?: IgnoreUncheckedCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreUncheckedCreateNestedManyWithoutIgnoredAgentInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutAgentInput
    initiatedEvents?: GameEventUncheckedCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventUncheckedCreateNestedManyWithoutTargetInput
  }

  export type AgentCreateOrConnectWithoutCoolDownInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutCoolDownInput, AgentUncheckedCreateWithoutCoolDownInput>
  }

  export type GameCreateWithoutCoolDownInput = {
    id?: string
    onchainId: number
    authority: string
    pda: string
    tokenMint: string
    rewardsVault: string
    mapDiameter: number
    isActive?: boolean
    lastUpdate?: Date | string
    bump: number
    dailyRewardTokens: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutGameInput
    alliances?: AllianceCreateNestedManyWithoutGameInput
    battles?: BattleCreateNestedManyWithoutGameInput
    Ignore?: IgnoreCreateNestedManyWithoutGameInput
    GameLog?: GameLogCreateNestedManyWithoutGameInput
    GameEvent?: GameEventCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutCoolDownInput = {
    id?: string
    onchainId: number
    authority: string
    pda: string
    tokenMint: string
    rewardsVault: string
    mapDiameter: number
    isActive?: boolean
    lastUpdate?: Date | string
    bump: number
    dailyRewardTokens: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutGameInput
    alliances?: AllianceUncheckedCreateNestedManyWithoutGameInput
    battles?: BattleUncheckedCreateNestedManyWithoutGameInput
    Ignore?: IgnoreUncheckedCreateNestedManyWithoutGameInput
    GameLog?: GameLogUncheckedCreateNestedManyWithoutGameInput
    GameEvent?: GameEventUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutCoolDownInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutCoolDownInput, GameUncheckedCreateWithoutCoolDownInput>
  }

  export type AgentUpsertWithoutCoolDownInput = {
    update: XOR<AgentUpdateWithoutCoolDownInput, AgentUncheckedUpdateWithoutCoolDownInput>
    create: XOR<AgentCreateWithoutCoolDownInput, AgentUncheckedCreateWithoutCoolDownInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutCoolDownInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutCoolDownInput, AgentUncheckedUpdateWithoutCoolDownInput>
  }

  export type AgentUpdateWithoutCoolDownInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUpdateManyWithoutAgentNestedInput
    game?: GameUpdateOneRequiredWithoutAgentsNestedInput
    battlesAsAttacker?: BattleUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUpdateManyWithoutWinnerNestedInput
    initiatedAlliances?: AllianceUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUpdateManyWithoutJoinerNestedInput
    profile?: AgentProfileUpdateOneRequiredWithoutAgentsNestedInput
    mapTile?: MapTileUpdateOneRequiredWithoutAgentNestedInput
    ignoredBy?: IgnoreUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUpdateManyWithoutTargetNestedInput
  }

  export type AgentUncheckedUpdateWithoutCoolDownInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mapTileId?: StringFieldUpdateOperationsInput | string
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUncheckedUpdateManyWithoutAgentNestedInput
    battlesAsAttacker?: BattleUncheckedUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUncheckedUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUncheckedUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUncheckedUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUncheckedUpdateManyWithoutWinnerNestedInput
    initiatedAlliances?: AllianceUncheckedUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUncheckedUpdateManyWithoutJoinerNestedInput
    ignoredBy?: IgnoreUncheckedUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUncheckedUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type GameUpsertWithoutCoolDownInput = {
    update: XOR<GameUpdateWithoutCoolDownInput, GameUncheckedUpdateWithoutCoolDownInput>
    create: XOR<GameCreateWithoutCoolDownInput, GameUncheckedCreateWithoutCoolDownInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutCoolDownInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutCoolDownInput, GameUncheckedUpdateWithoutCoolDownInput>
  }

  export type GameUpdateWithoutCoolDownInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    tokenMint?: StringFieldUpdateOperationsInput | string
    rewardsVault?: StringFieldUpdateOperationsInput | string
    mapDiameter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bump?: IntFieldUpdateOperationsInput | number
    dailyRewardTokens?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutGameNestedInput
    alliances?: AllianceUpdateManyWithoutGameNestedInput
    battles?: BattleUpdateManyWithoutGameNestedInput
    Ignore?: IgnoreUpdateManyWithoutGameNestedInput
    GameLog?: GameLogUpdateManyWithoutGameNestedInput
    GameEvent?: GameEventUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutCoolDownInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    tokenMint?: StringFieldUpdateOperationsInput | string
    rewardsVault?: StringFieldUpdateOperationsInput | string
    mapDiameter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bump?: IntFieldUpdateOperationsInput | number
    dailyRewardTokens?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutGameNestedInput
    alliances?: AllianceUncheckedUpdateManyWithoutGameNestedInput
    battles?: BattleUncheckedUpdateManyWithoutGameNestedInput
    Ignore?: IgnoreUncheckedUpdateManyWithoutGameNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutGameNestedInput
    GameEvent?: GameEventUncheckedUpdateManyWithoutGameNestedInput
  }

  export type AgentCreateWithoutGameLogInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    isAlive?: boolean
    deathTimestamp?: Date | string | null
    vault: string
    tweets?: TweetCreateNestedManyWithoutAgentInput
    game: GameCreateNestedOneWithoutAgentsInput
    battlesAsAttacker?: BattleCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceCreateNestedManyWithoutJoinerInput
    profile: AgentProfileCreateNestedOneWithoutAgentsInput
    mapTile: MapTileCreateNestedOneWithoutAgentInput
    ignoredBy?: IgnoreCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreCreateNestedManyWithoutIgnoredAgentInput
    initiatedEvents?: GameEventCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventCreateNestedManyWithoutTargetInput
  }

  export type AgentUncheckedCreateWithoutGameLogInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    gameId: string
    isAlive?: boolean
    profileId: string
    deathTimestamp?: Date | string | null
    mapTileId: string
    vault: string
    tweets?: TweetUncheckedCreateNestedManyWithoutAgentInput
    battlesAsAttacker?: BattleUncheckedCreateNestedManyWithoutAttackerInput
    battlesAsDefender?: BattleUncheckedCreateNestedManyWithoutDefenderInput
    battlesAsAttackerAlly?: BattleUncheckedCreateNestedManyWithoutAttackerAllyInput
    battlesAsDefenderAlly?: BattleUncheckedCreateNestedManyWithoutDefenderAllyInput
    wonBattles?: BattleUncheckedCreateNestedManyWithoutWinnerInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutCooledAgentInput
    initiatedAlliances?: AllianceUncheckedCreateNestedManyWithoutInitiatorInput
    joinedAlliances?: AllianceUncheckedCreateNestedManyWithoutJoinerInput
    ignoredBy?: IgnoreUncheckedCreateNestedManyWithoutAgentInput
    ignoring?: IgnoreUncheckedCreateNestedManyWithoutIgnoredAgentInput
    initiatedEvents?: GameEventUncheckedCreateNestedManyWithoutInitiatorInput
    targetedEvents?: GameEventUncheckedCreateNestedManyWithoutTargetInput
  }

  export type AgentCreateOrConnectWithoutGameLogInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutGameLogInput, AgentUncheckedCreateWithoutGameLogInput>
  }

  export type GameCreateWithoutGameLogInput = {
    id?: string
    onchainId: number
    authority: string
    pda: string
    tokenMint: string
    rewardsVault: string
    mapDiameter: number
    isActive?: boolean
    lastUpdate?: Date | string
    bump: number
    dailyRewardTokens: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutGameInput
    alliances?: AllianceCreateNestedManyWithoutGameInput
    battles?: BattleCreateNestedManyWithoutGameInput
    coolDown?: CoolDownCreateNestedManyWithoutGameInput
    Ignore?: IgnoreCreateNestedManyWithoutGameInput
    GameEvent?: GameEventCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutGameLogInput = {
    id?: string
    onchainId: number
    authority: string
    pda: string
    tokenMint: string
    rewardsVault: string
    mapDiameter: number
    isActive?: boolean
    lastUpdate?: Date | string
    bump: number
    dailyRewardTokens: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutGameInput
    alliances?: AllianceUncheckedCreateNestedManyWithoutGameInput
    battles?: BattleUncheckedCreateNestedManyWithoutGameInput
    coolDown?: CoolDownUncheckedCreateNestedManyWithoutGameInput
    Ignore?: IgnoreUncheckedCreateNestedManyWithoutGameInput
    GameEvent?: GameEventUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutGameLogInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutGameLogInput, GameUncheckedCreateWithoutGameLogInput>
  }

  export type AgentUpsertWithoutGameLogInput = {
    update: XOR<AgentUpdateWithoutGameLogInput, AgentUncheckedUpdateWithoutGameLogInput>
    create: XOR<AgentCreateWithoutGameLogInput, AgentUncheckedCreateWithoutGameLogInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutGameLogInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutGameLogInput, AgentUncheckedUpdateWithoutGameLogInput>
  }

  export type AgentUpdateWithoutGameLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUpdateManyWithoutAgentNestedInput
    game?: GameUpdateOneRequiredWithoutAgentsNestedInput
    battlesAsAttacker?: BattleUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUpdateManyWithoutJoinerNestedInput
    profile?: AgentProfileUpdateOneRequiredWithoutAgentsNestedInput
    mapTile?: MapTileUpdateOneRequiredWithoutAgentNestedInput
    ignoredBy?: IgnoreUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUpdateManyWithoutIgnoredAgentNestedInput
    initiatedEvents?: GameEventUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUpdateManyWithoutTargetNestedInput
  }

  export type AgentUncheckedUpdateWithoutGameLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mapTileId?: StringFieldUpdateOperationsInput | string
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUncheckedUpdateManyWithoutAgentNestedInput
    battlesAsAttacker?: BattleUncheckedUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUncheckedUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUncheckedUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUncheckedUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUncheckedUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUncheckedUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUncheckedUpdateManyWithoutJoinerNestedInput
    ignoredBy?: IgnoreUncheckedUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUncheckedUpdateManyWithoutIgnoredAgentNestedInput
    initiatedEvents?: GameEventUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type GameUpsertWithoutGameLogInput = {
    update: XOR<GameUpdateWithoutGameLogInput, GameUncheckedUpdateWithoutGameLogInput>
    create: XOR<GameCreateWithoutGameLogInput, GameUncheckedCreateWithoutGameLogInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutGameLogInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutGameLogInput, GameUncheckedUpdateWithoutGameLogInput>
  }

  export type GameUpdateWithoutGameLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    tokenMint?: StringFieldUpdateOperationsInput | string
    rewardsVault?: StringFieldUpdateOperationsInput | string
    mapDiameter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bump?: IntFieldUpdateOperationsInput | number
    dailyRewardTokens?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutGameNestedInput
    alliances?: AllianceUpdateManyWithoutGameNestedInput
    battles?: BattleUpdateManyWithoutGameNestedInput
    coolDown?: CoolDownUpdateManyWithoutGameNestedInput
    Ignore?: IgnoreUpdateManyWithoutGameNestedInput
    GameEvent?: GameEventUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutGameLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    tokenMint?: StringFieldUpdateOperationsInput | string
    rewardsVault?: StringFieldUpdateOperationsInput | string
    mapDiameter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bump?: IntFieldUpdateOperationsInput | number
    dailyRewardTokens?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutGameNestedInput
    alliances?: AllianceUncheckedUpdateManyWithoutGameNestedInput
    battles?: BattleUncheckedUpdateManyWithoutGameNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutGameNestedInput
    Ignore?: IgnoreUncheckedUpdateManyWithoutGameNestedInput
    GameEvent?: GameEventUncheckedUpdateManyWithoutGameNestedInput
  }

  export type AgentCreateManyGameInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    isAlive?: boolean
    profileId: string
    deathTimestamp?: Date | string | null
    mapTileId: string
    vault: string
  }

  export type AllianceCreateManyGameInput = {
    id?: string
    combinedTokens?: bigint | number | null
    status?: $Enums.AllianceStatus
    timestamp?: Date | string
    initiatorId: string
    joinerId: string
    endedAt?: Date | string | null
  }

  export type BattleCreateManyGameInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    attackerId: string
    defenderId: string
    attackerAllyId?: string | null
    defenderAllyId?: string | null
    winnerId?: string | null
  }

  export type CoolDownCreateManyGameInput = {
    id?: string
    type: $Enums.CooldownType
    endsAt: Date | string
    startsAt?: Date | string | null
    cooledAgentId: string
  }

  export type IgnoreCreateManyGameInput = {
    id?: string
    agentId: string
    timestamp?: Date | string
    duration?: number
    ignoredAgentId: string
  }

  export type GameLogCreateManyGameInput = {
    id?: string
    timestamp?: Date | string
    type: string
    level: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    agentId?: string | null
  }

  export type GameEventCreateManyGameInput = {
    id?: string
    createdAt?: Date | string
    eventType: $Enums.EventType
    initiatorId: string
    targetId?: string | null
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgentUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUpdateManyWithoutAgentNestedInput
    battlesAsAttacker?: BattleUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUpdateManyWithoutJoinerNestedInput
    profile?: AgentProfileUpdateOneRequiredWithoutAgentsNestedInput
    mapTile?: MapTileUpdateOneRequiredWithoutAgentNestedInput
    ignoredBy?: IgnoreUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUpdateManyWithoutTargetNestedInput
  }

  export type AgentUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mapTileId?: StringFieldUpdateOperationsInput | string
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUncheckedUpdateManyWithoutAgentNestedInput
    battlesAsAttacker?: BattleUncheckedUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUncheckedUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUncheckedUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUncheckedUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUncheckedUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUncheckedUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUncheckedUpdateManyWithoutJoinerNestedInput
    ignoredBy?: IgnoreUncheckedUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUncheckedUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type AgentUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mapTileId?: StringFieldUpdateOperationsInput | string
    vault?: StringFieldUpdateOperationsInput | string
  }

  export type AllianceUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    combinedTokens?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumAllianceStatusFieldUpdateOperationsInput | $Enums.AllianceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initiator?: AgentUpdateOneRequiredWithoutInitiatedAlliancesNestedInput
    joiner?: AgentUpdateOneRequiredWithoutJoinedAlliancesNestedInput
  }

  export type AllianceUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    combinedTokens?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumAllianceStatusFieldUpdateOperationsInput | $Enums.AllianceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    initiatorId?: StringFieldUpdateOperationsInput | string
    joinerId?: StringFieldUpdateOperationsInput | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AllianceUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    combinedTokens?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumAllianceStatusFieldUpdateOperationsInput | $Enums.AllianceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    initiatorId?: StringFieldUpdateOperationsInput | string
    joinerId?: StringFieldUpdateOperationsInput | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BattleUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attacker?: AgentUpdateOneRequiredWithoutBattlesAsAttackerNestedInput
    defender?: AgentUpdateOneRequiredWithoutBattlesAsDefenderNestedInput
    attackerAlly?: AgentUpdateOneWithoutBattlesAsAttackerAllyNestedInput
    defenderAlly?: AgentUpdateOneWithoutBattlesAsDefenderAllyNestedInput
    winner?: AgentUpdateOneWithoutWonBattlesNestedInput
  }

  export type BattleUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attackerId?: StringFieldUpdateOperationsInput | string
    defenderId?: StringFieldUpdateOperationsInput | string
    attackerAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    defenderAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BattleUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attackerId?: StringFieldUpdateOperationsInput | string
    defenderId?: StringFieldUpdateOperationsInput | string
    attackerAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    defenderAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CoolDownUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCooldownTypeFieldUpdateOperationsInput | $Enums.CooldownType
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cooledAgent?: AgentUpdateOneRequiredWithoutCoolDownNestedInput
  }

  export type CoolDownUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCooldownTypeFieldUpdateOperationsInput | $Enums.CooldownType
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cooledAgentId?: StringFieldUpdateOperationsInput | string
  }

  export type CoolDownUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCooldownTypeFieldUpdateOperationsInput | $Enums.CooldownType
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cooledAgentId?: StringFieldUpdateOperationsInput | string
  }

  export type IgnoreUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    agent?: AgentUpdateOneRequiredWithoutIgnoredByNestedInput
    ignoredAgent?: AgentUpdateOneRequiredWithoutIgnoringNestedInput
  }

  export type IgnoreUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    ignoredAgentId?: StringFieldUpdateOperationsInput | string
  }

  export type IgnoreUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    ignoredAgentId?: StringFieldUpdateOperationsInput | string
  }

  export type GameLogUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    agent?: AgentUpdateOneWithoutGameLogNestedInput
  }

  export type GameLogUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GameLogUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GameEventUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiator?: AgentUpdateOneRequiredWithoutInitiatedEventsNestedInput
    target?: AgentUpdateOneWithoutTargetedEventsNestedInput
  }

  export type GameEventUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    initiatorId?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GameEventUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    initiatorId?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgentCreateManyProfileInput = {
    id?: string
    onchainId: number
    authority: string
    authorityAssociatedTokenAddress: string
    pda: string
    gameId: string
    isAlive?: boolean
    deathTimestamp?: Date | string | null
    mapTileId: string
    vault: string
  }

  export type AgentUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUpdateManyWithoutAgentNestedInput
    game?: GameUpdateOneRequiredWithoutAgentsNestedInput
    battlesAsAttacker?: BattleUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUpdateManyWithoutJoinerNestedInput
    mapTile?: MapTileUpdateOneRequiredWithoutAgentNestedInput
    ignoredBy?: IgnoreUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUpdateManyWithoutTargetNestedInput
  }

  export type AgentUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mapTileId?: StringFieldUpdateOperationsInput | string
    vault?: StringFieldUpdateOperationsInput | string
    tweets?: TweetUncheckedUpdateManyWithoutAgentNestedInput
    battlesAsAttacker?: BattleUncheckedUpdateManyWithoutAttackerNestedInput
    battlesAsDefender?: BattleUncheckedUpdateManyWithoutDefenderNestedInput
    battlesAsAttackerAlly?: BattleUncheckedUpdateManyWithoutAttackerAllyNestedInput
    battlesAsDefenderAlly?: BattleUncheckedUpdateManyWithoutDefenderAllyNestedInput
    wonBattles?: BattleUncheckedUpdateManyWithoutWinnerNestedInput
    coolDown?: CoolDownUncheckedUpdateManyWithoutCooledAgentNestedInput
    initiatedAlliances?: AllianceUncheckedUpdateManyWithoutInitiatorNestedInput
    joinedAlliances?: AllianceUncheckedUpdateManyWithoutJoinerNestedInput
    ignoredBy?: IgnoreUncheckedUpdateManyWithoutAgentNestedInput
    ignoring?: IgnoreUncheckedUpdateManyWithoutIgnoredAgentNestedInput
    GameLog?: GameLogUncheckedUpdateManyWithoutAgentNestedInput
    initiatedEvents?: GameEventUncheckedUpdateManyWithoutInitiatorNestedInput
    targetedEvents?: GameEventUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type AgentUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    onchainId?: IntFieldUpdateOperationsInput | number
    authority?: StringFieldUpdateOperationsInput | string
    authorityAssociatedTokenAddress?: StringFieldUpdateOperationsInput | string
    pda?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    deathTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mapTileId?: StringFieldUpdateOperationsInput | string
    vault?: StringFieldUpdateOperationsInput | string
  }

  export type TweetCreateManyAgentInput = {
    id?: string
    content: string
    type: string
    timestamp: Date | string
    conversationId?: string | null
  }

  export type BattleCreateManyAttackerInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    gameId: string
    defenderId: string
    attackerAllyId?: string | null
    defenderAllyId?: string | null
    winnerId?: string | null
  }

  export type BattleCreateManyDefenderInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    gameId: string
    attackerId: string
    attackerAllyId?: string | null
    defenderAllyId?: string | null
    winnerId?: string | null
  }

  export type BattleCreateManyAttackerAllyInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    gameId: string
    attackerId: string
    defenderId: string
    defenderAllyId?: string | null
    winnerId?: string | null
  }

  export type BattleCreateManyDefenderAllyInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    gameId: string
    attackerId: string
    defenderId: string
    attackerAllyId?: string | null
    winnerId?: string | null
  }

  export type BattleCreateManyWinnerInput = {
    id?: string
    type: $Enums.BattleType
    status?: $Enums.BattleStatus
    tokensStaked: bigint | number
    startTime?: Date | string
    endTime?: Date | string | null
    gameId: string
    attackerId: string
    defenderId: string
    attackerAllyId?: string | null
    defenderAllyId?: string | null
  }

  export type CoolDownCreateManyCooledAgentInput = {
    id?: string
    type: $Enums.CooldownType
    endsAt: Date | string
    startsAt?: Date | string | null
    gameId: string
  }

  export type AllianceCreateManyInitiatorInput = {
    id?: string
    combinedTokens?: bigint | number | null
    status?: $Enums.AllianceStatus
    timestamp?: Date | string
    gameId: string
    joinerId: string
    endedAt?: Date | string | null
  }

  export type AllianceCreateManyJoinerInput = {
    id?: string
    combinedTokens?: bigint | number | null
    status?: $Enums.AllianceStatus
    timestamp?: Date | string
    gameId: string
    initiatorId: string
    endedAt?: Date | string | null
  }

  export type IgnoreCreateManyAgentInput = {
    id?: string
    timestamp?: Date | string
    duration?: number
    gameId: string
    ignoredAgentId: string
  }

  export type IgnoreCreateManyIgnoredAgentInput = {
    id?: string
    agentId: string
    timestamp?: Date | string
    duration?: number
    gameId: string
  }

  export type GameLogCreateManyAgentInput = {
    id?: string
    timestamp?: Date | string
    type: string
    level: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    gameId?: string | null
  }

  export type GameEventCreateManyInitiatorInput = {
    id?: string
    createdAt?: Date | string
    eventType: $Enums.EventType
    targetId?: string | null
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type GameEventCreateManyTargetInput = {
    id?: string
    createdAt?: Date | string
    eventType: $Enums.EventType
    initiatorId: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type TweetUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    interactions?: InteractionUpdateManyWithoutTweetNestedInput
  }

  export type TweetUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    interactions?: InteractionUncheckedUpdateManyWithoutTweetNestedInput
  }

  export type TweetUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BattleUpdateWithoutAttackerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    game?: GameUpdateOneRequiredWithoutBattlesNestedInput
    defender?: AgentUpdateOneRequiredWithoutBattlesAsDefenderNestedInput
    attackerAlly?: AgentUpdateOneWithoutBattlesAsAttackerAllyNestedInput
    defenderAlly?: AgentUpdateOneWithoutBattlesAsDefenderAllyNestedInput
    winner?: AgentUpdateOneWithoutWonBattlesNestedInput
  }

  export type BattleUncheckedUpdateWithoutAttackerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    defenderId?: StringFieldUpdateOperationsInput | string
    attackerAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    defenderAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BattleUncheckedUpdateManyWithoutAttackerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    defenderId?: StringFieldUpdateOperationsInput | string
    attackerAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    defenderAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BattleUpdateWithoutDefenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    game?: GameUpdateOneRequiredWithoutBattlesNestedInput
    attacker?: AgentUpdateOneRequiredWithoutBattlesAsAttackerNestedInput
    attackerAlly?: AgentUpdateOneWithoutBattlesAsAttackerAllyNestedInput
    defenderAlly?: AgentUpdateOneWithoutBattlesAsDefenderAllyNestedInput
    winner?: AgentUpdateOneWithoutWonBattlesNestedInput
  }

  export type BattleUncheckedUpdateWithoutDefenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    attackerId?: StringFieldUpdateOperationsInput | string
    attackerAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    defenderAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BattleUncheckedUpdateManyWithoutDefenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    attackerId?: StringFieldUpdateOperationsInput | string
    attackerAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    defenderAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BattleUpdateWithoutAttackerAllyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    game?: GameUpdateOneRequiredWithoutBattlesNestedInput
    attacker?: AgentUpdateOneRequiredWithoutBattlesAsAttackerNestedInput
    defender?: AgentUpdateOneRequiredWithoutBattlesAsDefenderNestedInput
    defenderAlly?: AgentUpdateOneWithoutBattlesAsDefenderAllyNestedInput
    winner?: AgentUpdateOneWithoutWonBattlesNestedInput
  }

  export type BattleUncheckedUpdateWithoutAttackerAllyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    attackerId?: StringFieldUpdateOperationsInput | string
    defenderId?: StringFieldUpdateOperationsInput | string
    defenderAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BattleUncheckedUpdateManyWithoutAttackerAllyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    attackerId?: StringFieldUpdateOperationsInput | string
    defenderId?: StringFieldUpdateOperationsInput | string
    defenderAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BattleUpdateWithoutDefenderAllyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    game?: GameUpdateOneRequiredWithoutBattlesNestedInput
    attacker?: AgentUpdateOneRequiredWithoutBattlesAsAttackerNestedInput
    defender?: AgentUpdateOneRequiredWithoutBattlesAsDefenderNestedInput
    attackerAlly?: AgentUpdateOneWithoutBattlesAsAttackerAllyNestedInput
    winner?: AgentUpdateOneWithoutWonBattlesNestedInput
  }

  export type BattleUncheckedUpdateWithoutDefenderAllyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    attackerId?: StringFieldUpdateOperationsInput | string
    defenderId?: StringFieldUpdateOperationsInput | string
    attackerAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BattleUncheckedUpdateManyWithoutDefenderAllyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    attackerId?: StringFieldUpdateOperationsInput | string
    defenderId?: StringFieldUpdateOperationsInput | string
    attackerAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BattleUpdateWithoutWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    game?: GameUpdateOneRequiredWithoutBattlesNestedInput
    attacker?: AgentUpdateOneRequiredWithoutBattlesAsAttackerNestedInput
    defender?: AgentUpdateOneRequiredWithoutBattlesAsDefenderNestedInput
    attackerAlly?: AgentUpdateOneWithoutBattlesAsAttackerAllyNestedInput
    defenderAlly?: AgentUpdateOneWithoutBattlesAsDefenderAllyNestedInput
  }

  export type BattleUncheckedUpdateWithoutWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    attackerId?: StringFieldUpdateOperationsInput | string
    defenderId?: StringFieldUpdateOperationsInput | string
    attackerAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    defenderAllyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BattleUncheckedUpdateManyWithoutWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBattleTypeFieldUpdateOperationsInput | $Enums.BattleType
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    tokensStaked?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    attackerId?: StringFieldUpdateOperationsInput | string
    defenderId?: StringFieldUpdateOperationsInput | string
    attackerAllyId?: NullableStringFieldUpdateOperationsInput | string | null
    defenderAllyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CoolDownUpdateWithoutCooledAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCooldownTypeFieldUpdateOperationsInput | $Enums.CooldownType
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    game?: GameUpdateOneRequiredWithoutCoolDownNestedInput
  }

  export type CoolDownUncheckedUpdateWithoutCooledAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCooldownTypeFieldUpdateOperationsInput | $Enums.CooldownType
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type CoolDownUncheckedUpdateManyWithoutCooledAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCooldownTypeFieldUpdateOperationsInput | $Enums.CooldownType
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AllianceUpdateWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    combinedTokens?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumAllianceStatusFieldUpdateOperationsInput | $Enums.AllianceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    game?: GameUpdateOneRequiredWithoutAlliancesNestedInput
    joiner?: AgentUpdateOneRequiredWithoutJoinedAlliancesNestedInput
  }

  export type AllianceUncheckedUpdateWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    combinedTokens?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumAllianceStatusFieldUpdateOperationsInput | $Enums.AllianceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    gameId?: StringFieldUpdateOperationsInput | string
    joinerId?: StringFieldUpdateOperationsInput | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AllianceUncheckedUpdateManyWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    combinedTokens?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumAllianceStatusFieldUpdateOperationsInput | $Enums.AllianceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    gameId?: StringFieldUpdateOperationsInput | string
    joinerId?: StringFieldUpdateOperationsInput | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AllianceUpdateWithoutJoinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    combinedTokens?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumAllianceStatusFieldUpdateOperationsInput | $Enums.AllianceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    game?: GameUpdateOneRequiredWithoutAlliancesNestedInput
    initiator?: AgentUpdateOneRequiredWithoutInitiatedAlliancesNestedInput
  }

  export type AllianceUncheckedUpdateWithoutJoinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    combinedTokens?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumAllianceStatusFieldUpdateOperationsInput | $Enums.AllianceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    gameId?: StringFieldUpdateOperationsInput | string
    initiatorId?: StringFieldUpdateOperationsInput | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AllianceUncheckedUpdateManyWithoutJoinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    combinedTokens?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumAllianceStatusFieldUpdateOperationsInput | $Enums.AllianceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    gameId?: StringFieldUpdateOperationsInput | string
    initiatorId?: StringFieldUpdateOperationsInput | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IgnoreUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    game?: GameUpdateOneRequiredWithoutIgnoreNestedInput
    ignoredAgent?: AgentUpdateOneRequiredWithoutIgnoringNestedInput
  }

  export type IgnoreUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    ignoredAgentId?: StringFieldUpdateOperationsInput | string
  }

  export type IgnoreUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    ignoredAgentId?: StringFieldUpdateOperationsInput | string
  }

  export type IgnoreUpdateWithoutIgnoredAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    agent?: AgentUpdateOneRequiredWithoutIgnoredByNestedInput
    game?: GameUpdateOneRequiredWithoutIgnoreNestedInput
  }

  export type IgnoreUncheckedUpdateWithoutIgnoredAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type IgnoreUncheckedUpdateManyWithoutIgnoredAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type GameLogUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    game?: GameUpdateOneWithoutGameLogNestedInput
  }

  export type GameLogUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GameLogUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GameEventUpdateWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    target?: AgentUpdateOneWithoutTargetedEventsNestedInput
    game?: GameUpdateOneRequiredWithoutGameEventNestedInput
  }

  export type GameEventUncheckedUpdateWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type GameEventUncheckedUpdateManyWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type GameEventUpdateWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiator?: AgentUpdateOneRequiredWithoutInitiatedEventsNestedInput
    game?: GameUpdateOneRequiredWithoutGameEventNestedInput
  }

  export type GameEventUncheckedUpdateWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    initiatorId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type GameEventUncheckedUpdateManyWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    initiatorId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type InteractionCreateManyTweetInput = {
    id?: string
    userId: string
    type: $Enums.InteractionType
    content: string
    timestamp: Date | string
    userMetrics: JsonNullValueInput | InputJsonValue
  }

  export type InteractionUpdateWithoutTweetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userMetrics?: JsonNullValueInput | InputJsonValue
  }

  export type InteractionUncheckedUpdateWithoutTweetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userMetrics?: JsonNullValueInput | InputJsonValue
  }

  export type InteractionUncheckedUpdateManyWithoutTweetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userMetrics?: JsonNullValueInput | InputJsonValue
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}